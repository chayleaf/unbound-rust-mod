/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const PTHREADSTACKSIZE: u32 = 2097152;
pub const LDNS_MAX_LABELLEN: u32 = 63;
pub const LDNS_MAX_DOMAINLEN: u32 = 255;
pub const LDNS_MAX_POINTERS: u32 = 65535;
pub const LDNS_RR_OVERHEAD: u32 = 10;
pub const LDNS_DNSSEC_KEYPROTO: u32 = 3;
pub const LDNS_KEY_ZONE_KEY: u32 = 256;
pub const LDNS_KEY_SEP_KEY: u32 = 1;
pub const LDNS_KEY_REVOKE_KEY: u32 = 128;
pub const LDNS_RDATA_FIELD_DESCRIPTORS_COMMON: u32 = 259;
pub const LDNS_MAX_RDFLEN: u32 = 65535;
pub const LDNS_RDF_SIZE_BYTE: u32 = 1;
pub const LDNS_RDF_SIZE_WORD: u32 = 2;
pub const LDNS_RDF_SIZE_DOUBLEWORD: u32 = 4;
pub const LDNS_RDF_SIZE_6BYTES: u32 = 6;
pub const LDNS_RDF_SIZE_8BYTES: u32 = 8;
pub const LDNS_RDF_SIZE_16BYTES: u32 = 16;
pub const LDNS_NSEC3_VARS_OPTOUT_MASK: u32 = 1;
pub const LDNS_APL_IP4: u32 = 1;
pub const LDNS_APL_IP6: u32 = 2;
pub const LDNS_APL_MASK: u32 = 127;
pub const LDNS_APL_NEGATION: u32 = 128;
pub const LDNS_EDNS_MASK_DO_BIT: u32 = 32768;
pub const LDNS_TSIG_ERROR_NOERROR: u32 = 0;
pub const LDNS_TSIG_ERROR_BADSIG: u32 = 16;
pub const LDNS_TSIG_ERROR_BADKEY: u32 = 17;
pub const LDNS_TSIG_ERROR_BADTIME: u32 = 18;
pub const LDNS_TSIG_ERROR_BADMODE: u32 = 19;
pub const LDNS_TSIG_ERROR_BADNAME: u32 = 20;
pub const LDNS_TSIG_ERROR_BADALG: u32 = 21;
pub const LDNS_EXT_RCODE_BADCOOKIE: u32 = 23;
pub const LDNS_HEADER_SIZE: u32 = 12;
pub const LDNS_RD_MASK: u32 = 1;
pub const LDNS_RD_SHIFT: u32 = 0;
pub const LDNS_TC_MASK: u32 = 2;
pub const LDNS_TC_SHIFT: u32 = 1;
pub const LDNS_AA_MASK: u32 = 4;
pub const LDNS_AA_SHIFT: u32 = 2;
pub const LDNS_OPCODE_MASK: u32 = 120;
pub const LDNS_OPCODE_SHIFT: u32 = 3;
pub const LDNS_QR_MASK: u32 = 128;
pub const LDNS_QR_SHIFT: u32 = 7;
pub const LDNS_RCODE_MASK: u32 = 15;
pub const LDNS_RCODE_SHIFT: u32 = 0;
pub const LDNS_CD_MASK: u32 = 16;
pub const LDNS_CD_SHIFT: u32 = 4;
pub const LDNS_AD_MASK: u32 = 32;
pub const LDNS_AD_SHIFT: u32 = 5;
pub const LDNS_Z_MASK: u32 = 64;
pub const LDNS_Z_SHIFT: u32 = 6;
pub const LDNS_RA_MASK: u32 = 128;
pub const LDNS_RA_SHIFT: u32 = 7;
pub const LDNS_QDCOUNT_OFF: u32 = 4;
pub const LDNS_ANCOUNT_OFF: u32 = 6;
pub const LDNS_NSCOUNT_OFF: u32 = 8;
pub const LDNS_ARCOUNT_OFF: u32 = 10;
pub const MAX_MODULE: u32 = 16;
pub const MAX_KNOWN_EDNS_OPTS: u32 = 256;
pub type __gnuc_va_list = __builtin_va_list;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
pub type va_list = __gnuc_va_list;
pub type socklen_t = __socklen_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
pub type pthread_t = ::std::os::raw::c_ulong;
pub type pthread_key_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[doc = " 0 - no verbose messages"]
pub const verbosity_value_NO_VERBOSE: verbosity_value = 0;
#[doc = " 1 - operational information"]
pub const verbosity_value_VERB_OPS: verbosity_value = 1;
#[doc = " 2 - detailed information"]
pub const verbosity_value_VERB_DETAIL: verbosity_value = 2;
#[doc = " 3 - query level information"]
pub const verbosity_value_VERB_QUERY: verbosity_value = 3;
#[doc = " 4 - algorithm level information"]
pub const verbosity_value_VERB_ALGO: verbosity_value = 4;
#[doc = " 5 - querier client information"]
pub const verbosity_value_VERB_CLIENT: verbosity_value = 5;
#[doc = " verbosity value:"]
pub type verbosity_value = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " The global verbosity setting"]
    pub static mut verbosity: verbosity_value;
}
extern "C" {
    #[doc = " log a verbose message, pass the level for this message.\n It has printf formatted arguments. No trailing newline is needed.\n @param level: verbosity level for this message, compared to global\n\tverbosity setting.\n @param format: printf-style format string. Arguments follow."]
    pub fn verbose(level: verbosity_value, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " call this to initialize logging services.\n @param filename: if NULL stderr is used.\n @param use_syslog: set to true to ignore filename and use syslog(3).\n @param chrootdir: to which directory we have been chrooted, if any."]
    pub fn log_init(
        filename: *const ::std::os::raw::c_char,
        use_syslog: ::std::os::raw::c_int,
        chrootdir: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Set logging to go to the specified file *.\n This setting does not affect the use_syslog setting.\n @param f: to that file, or pass NULL to disable logging."]
    pub fn log_file(f: *mut FILE);
}
extern "C" {
    #[doc = " Init a thread (will print this number for the thread log entries).\n Must be called from the thread itself. If not called 0 is printed.\n @param num: number to print for this thread. Owned by caller, must\n\tcontinue to exist."]
    pub fn log_thread_set(num: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the thread id from logging system.  Set after log_init is\n initialised, or log_thread_set for newly created threads.\n This initialisation happens in unbound as a daemon, in daemon\n startup code, when that spawns threads.\n @return thread number, from 0 and up.  Before initialised, returns 0."]
    pub fn log_thread_get() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set identity to print, default is 'unbound'.\n @param id: string to print. Name of executable."]
    pub fn log_ident_set(id: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set default identity to print, default is 'unbound'.\n @param id: string to print. Name of executable."]
    pub fn log_ident_set_default(id: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Revert identity to print, back to the recorded default value."]
    pub fn log_ident_revert_to_default();
}
extern "C" {
    #[doc = " Set identity to print if there is an identity, otherwise\n set the default.\n @param identity: the identity to set."]
    pub fn log_ident_set_or_default(identity: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set if the time value is printed ascii or decimal in log entries.\n @param use_asc: if true, ascii is printed, otherwise decimal.\n\tIf the conversion fails or you have no time functions,\n\tdecimal is printed."]
    pub fn log_set_time_asc(use_asc: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " get log lock"]
    pub fn log_get_lock() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Log informational message.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn log_info(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Log error message.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn log_err(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Log warning message.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn log_warn(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Log a hex-string to the log. Can be any length.\n performs mallocs to do so, slow. But debug useful.\n @param msg: string desc to accompany the hexdump.\n @param data: data to dump in hex format.\n @param length: length of data."]
    pub fn log_hex(
        msg: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    #[doc = " Log query.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn log_query(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Log reply.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn log_reply(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Easy alternative for log_hex, takes a sldns_buffer.\n @param level: verbosity level for this message, compared to global\n\tverbosity setting.\n @param msg: string desc to print\n @param buf: the buffer."]
    pub fn log_buf(
        level: verbosity_value,
        msg: *const ::std::os::raw::c_char,
        buf: *mut sldns_buffer,
    );
}
extern "C" {
    #[doc = " Log fatal error message, and exit the current process.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn fatal_exit(format: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[doc = " va_list argument version of log_info.\n @param pri: priority type, for example 5 (INFO).\n @param type: string to designate type of message (info, error).\n @param format: the printf style format to print. no newline.\n @param args: arguments for format string."]
    pub fn log_vmsg(
        pri: ::std::os::raw::c_int,
        type_: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
#[doc = " use pthread mutex for basic lock"]
pub type lock_basic_type = pthread_mutex_t;
#[doc = " we use the pthread rwlock"]
pub type lock_rw_type = pthread_rwlock_t;
#[doc = " use pthread spinlock for the quick lock"]
pub type lock_quick_type = pthread_spinlock_t;
#[doc = " Thread creation"]
pub type ub_thread_type = pthread_t;
pub type ub_thread_key_type = pthread_key_t;
extern "C" {
    #[doc = " Block all signals for this thread.\n fatal exit on error."]
    pub fn ub_thread_blocksigs();
}
extern "C" {
    #[doc = " unblock one signal for this thread."]
    pub fn ub_thread_sig_unblock(sig: ::std::os::raw::c_int);
}
#[doc = " the type of a hash value"]
pub type hashvalue_type = u32;
#[doc = " An entry into the hash table.\n To change overflow_next you need to hold the bin lock.\n To change the lru items you need to hold the hashtable lock.\n This structure is designed as part of key struct. And key pointer helps\n to get the surrounding structure. Data should be allocated on its own."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruhash_entry {
    #[doc = " rwlock for access to the contents of the entry\n Note that it does _not_ cover the lru_ and overflow_ ptrs.\n Even with a writelock, you cannot change hash and key.\n You need to delete it to change hash or key."]
    pub lock: lock_rw_type,
    #[doc = " next entry in overflow chain. Covered by hashlock and binlock."]
    pub overflow_next: *mut lruhash_entry,
    #[doc = " next entry in lru chain. covered by hashlock."]
    pub lru_next: *mut lruhash_entry,
    #[doc = " prev entry in lru chain. covered by hashlock."]
    pub lru_prev: *mut lruhash_entry,
    #[doc = " hash value of the key. It may not change, until entry deleted."]
    pub hash: hashvalue_type,
    #[doc = " key"]
    pub key: *mut ::std::os::raw::c_void,
    #[doc = " data"]
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alloc_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regional {
    _unused: [u8; 0],
}
#[doc = " type used to uniquely identify rrsets. Cannot be reused without\n clearing the cache."]
pub type rrset_id_type = u64;
#[doc = " The identifying information for an RRset."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packed_rrset_key {
    #[doc = " The domain name. If not null (for id=0) it is allocated, and\n contains the wireformat domain name.\n This dname is not canonicalized."]
    pub dname: *mut u8,
    #[doc = " Length of the domain name, including last 0 root octet."]
    pub dname_len: usize,
    #[doc = " Flags. 32bit to be easy for hashing:\n \to PACKED_RRSET_NSEC_AT_APEX\n \to PACKED_RRSET_PARENT_SIDE\n \to PACKED_RRSET_SOA_NEG\n \to PACKED_RRSET_FIXEDTTL (not supposed to be cached)\n \to PACKED_RRSET_RPZ"]
    pub flags: u32,
    #[doc = " the rrset type in network format"]
    pub type_: u16,
    #[doc = " the rrset class in network format"]
    pub rrset_class: u16,
}
#[doc = " This structure contains an RRset. A set of resource records that\n share the same domain name, type and class.\n\n Due to memory management and threading, the key structure cannot be\n deleted, although the data can be. The id can be set to 0 to store and the\n structure can be recycled with a new id."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ub_packed_rrset_key {
    #[doc = " entry into hashtable. Note the lock is never destroyed,\n  even when this key is retired to the cache.\n the data pointer (if not null) points to a struct packed_rrset."]
    pub entry: lruhash_entry,
    #[doc = " the ID of this rrset. unique, based on threadid + sequenceno.\n ids are not reused, except after flushing the cache.\n zero is an unused entry, and never a valid id.\n Check this value after getting entry.lock.\n The other values in this struct may only be altered after changing\n the id (which needs a writelock on entry.lock)."]
    pub id: rrset_id_type,
    #[doc = " key data: dname, type and class"]
    pub rk: packed_rrset_key,
}
#[doc = " UNCHECKED means that object has yet to be validated."]
pub const sec_status_sec_status_unchecked: sec_status = 0;
#[doc = " BOGUS means that the object (RRset or message) failed to validate\n  (according to local policy), but should have validated."]
pub const sec_status_sec_status_bogus: sec_status = 1;
#[doc = " INDETERMINATE means that the object is insecure, but not\n authoritatively so. Generally this means that the RRset is not\n below a configured trust anchor."]
pub const sec_status_sec_status_indeterminate: sec_status = 2;
#[doc = " INSECURE means that the object is authoritatively known to be\n insecure. Generally this means that this RRset is below a trust\n anchor, but also below a verified, insecure delegation."]
pub const sec_status_sec_status_insecure: sec_status = 3;
#[doc = " SECURE_SENTINEL_FAIL means that the object (RRset or message)\n validated according to local policy but did not succeed in the root\n KSK sentinel test (draft-ietf-dnsop-kskroll-sentinel)."]
pub const sec_status_sec_status_secure_sentinel_fail: sec_status = 4;
#[doc = " SECURE means that the object (RRset or message) validated\n according to local policy."]
pub const sec_status_sec_status_secure: sec_status = 5;
#[doc = " Security status from validation for data.\n The order is significant; more secure, more proven later."]
pub type sec_status = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sldns_struct_lookup_table {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " lookuptable for rr classes"]
    pub static mut sldns_rr_classes: *mut sldns_struct_lookup_table;
}
#[doc = " the Internet"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_IN: sldns_enum_rr_class = 1;
#[doc = " Chaos class"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_CH: sldns_enum_rr_class = 3;
#[doc = " Hesiod (Dyer 87)"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_HS: sldns_enum_rr_class = 4;
#[doc = " None class, dynamic update"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_NONE: sldns_enum_rr_class = 254;
#[doc = " Any class"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_ANY: sldns_enum_rr_class = 255;
#[doc = " Any class"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_FIRST: sldns_enum_rr_class = 0;
#[doc = " Any class"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_LAST: sldns_enum_rr_class = 65535;
#[doc = " Any class"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_COUNT: sldns_enum_rr_class = 65536;
#[doc = "  The different RR classes."]
pub type sldns_enum_rr_class = ::std::os::raw::c_uint;
#[doc = "  The different RR classes."]
pub use self::sldns_enum_rr_class as sldns_rr_class;
#[doc = " compression is allowed"]
pub const sldns_enum_rr_compress_LDNS_RR_COMPRESS: sldns_enum_rr_compress = 0;
#[doc = " compression is allowed"]
pub const sldns_enum_rr_compress_LDNS_RR_NO_COMPRESS: sldns_enum_rr_compress = 1;
#[doc = "  Used to specify whether compression is allowed."]
pub type sldns_enum_rr_compress = ::std::os::raw::c_uint;
#[doc = "  Used to specify whether compression is allowed."]
pub use self::sldns_enum_rr_compress as sldns_rr_compress;
#[doc = "  a host address"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_A: sldns_enum_rr_type = 1;
#[doc = "  an authoritative name server"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NS: sldns_enum_rr_type = 2;
#[doc = "  a mail destination (Obsolete - use MX)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MD: sldns_enum_rr_type = 3;
#[doc = "  a mail forwarder (Obsolete - use MX)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MF: sldns_enum_rr_type = 4;
#[doc = "  the canonical name for an alias"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CNAME: sldns_enum_rr_type = 5;
#[doc = "  marks the start of a zone of authority"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SOA: sldns_enum_rr_type = 6;
#[doc = "  a mailbox domain name (EXPERIMENTAL)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MB: sldns_enum_rr_type = 7;
#[doc = "  a mail group member (EXPERIMENTAL)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MG: sldns_enum_rr_type = 8;
#[doc = "  a mail rename domain name (EXPERIMENTAL)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MR: sldns_enum_rr_type = 9;
#[doc = "  a null RR (EXPERIMENTAL)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NULL: sldns_enum_rr_type = 10;
#[doc = "  a well known service description"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_WKS: sldns_enum_rr_type = 11;
#[doc = "  a domain name pointer"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_PTR: sldns_enum_rr_type = 12;
#[doc = "  host information"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_HINFO: sldns_enum_rr_type = 13;
#[doc = "  mailbox or mail list information"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MINFO: sldns_enum_rr_type = 14;
#[doc = "  mail exchange"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MX: sldns_enum_rr_type = 15;
#[doc = "  text strings"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TXT: sldns_enum_rr_type = 16;
#[doc = "  RFC1183"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_RP: sldns_enum_rr_type = 17;
#[doc = "  RFC1183"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_AFSDB: sldns_enum_rr_type = 18;
#[doc = "  RFC1183"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_X25: sldns_enum_rr_type = 19;
#[doc = "  RFC1183"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_ISDN: sldns_enum_rr_type = 20;
#[doc = "  RFC1183"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_RT: sldns_enum_rr_type = 21;
#[doc = "  RFC1706"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSAP: sldns_enum_rr_type = 22;
#[doc = "  RFC1348"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSAP_PTR: sldns_enum_rr_type = 23;
#[doc = "  2535typecode"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SIG: sldns_enum_rr_type = 24;
#[doc = "  2535typecode"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_KEY: sldns_enum_rr_type = 25;
#[doc = "  RFC2163"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_PX: sldns_enum_rr_type = 26;
#[doc = "  RFC1712"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_GPOS: sldns_enum_rr_type = 27;
#[doc = "  ipv6 address"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_AAAA: sldns_enum_rr_type = 28;
#[doc = "  LOC record  RFC1876"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_LOC: sldns_enum_rr_type = 29;
#[doc = "  2535typecode"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NXT: sldns_enum_rr_type = 30;
#[doc = "  draft-ietf-nimrod-dns-01.txt"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_EID: sldns_enum_rr_type = 31;
#[doc = "  draft-ietf-nimrod-dns-01.txt"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NIMLOC: sldns_enum_rr_type = 32;
#[doc = "  SRV record RFC2782"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SRV: sldns_enum_rr_type = 33;
#[doc = "  http://www.jhsoft.com/rfc/af-saa-0069.000.rtf"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_ATMA: sldns_enum_rr_type = 34;
#[doc = "  RFC2915"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NAPTR: sldns_enum_rr_type = 35;
#[doc = "  RFC2230"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_KX: sldns_enum_rr_type = 36;
#[doc = "  RFC2538"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CERT: sldns_enum_rr_type = 37;
#[doc = "  RFC2874"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_A6: sldns_enum_rr_type = 38;
#[doc = "  RFC2672"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_DNAME: sldns_enum_rr_type = 39;
#[doc = "  dnsind-kitchen-sink-02.txt"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SINK: sldns_enum_rr_type = 40;
#[doc = "  Pseudo OPT record..."]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_OPT: sldns_enum_rr_type = 41;
#[doc = "  RFC3123"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_APL: sldns_enum_rr_type = 42;
#[doc = "  RFC4034, RFC3658"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_DS: sldns_enum_rr_type = 43;
#[doc = "  SSH Key Fingerprint"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SSHFP: sldns_enum_rr_type = 44;
#[doc = "  IPsec Key"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_IPSECKEY: sldns_enum_rr_type = 45;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_RRSIG: sldns_enum_rr_type = 46;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSEC: sldns_enum_rr_type = 47;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_DNSKEY: sldns_enum_rr_type = 48;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_DHCID: sldns_enum_rr_type = 49;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSEC3: sldns_enum_rr_type = 50;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSEC3PARAM: sldns_enum_rr_type = 51;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSEC3PARAMS: sldns_enum_rr_type = 51;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TLSA: sldns_enum_rr_type = 52;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SMIMEA: sldns_enum_rr_type = 53;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_HIP: sldns_enum_rr_type = 55;
#[doc = " draft-reid-dnsext-zs"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NINFO: sldns_enum_rr_type = 56;
#[doc = " draft-reid-dnsext-rkey"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_RKEY: sldns_enum_rr_type = 57;
#[doc = " draft-ietf-dnsop-trust-history"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TALINK: sldns_enum_rr_type = 58;
#[doc = " draft-ietf-dnsop-trust-history"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CDS: sldns_enum_rr_type = 59;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CDNSKEY: sldns_enum_rr_type = 60;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_OPENPGPKEY: sldns_enum_rr_type = 61;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CSYNC: sldns_enum_rr_type = 62;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_ZONEMD: sldns_enum_rr_type = 63;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SVCB: sldns_enum_rr_type = 64;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_HTTPS: sldns_enum_rr_type = 65;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SPF: sldns_enum_rr_type = 99;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_UINFO: sldns_enum_rr_type = 100;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_UID: sldns_enum_rr_type = 101;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_GID: sldns_enum_rr_type = 102;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_UNSPEC: sldns_enum_rr_type = 103;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NID: sldns_enum_rr_type = 104;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_L32: sldns_enum_rr_type = 105;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_L64: sldns_enum_rr_type = 106;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_LP: sldns_enum_rr_type = 107;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_EUI48: sldns_enum_rr_type = 108;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_EUI64: sldns_enum_rr_type = 109;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TKEY: sldns_enum_rr_type = 249;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TSIG: sldns_enum_rr_type = 250;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_IXFR: sldns_enum_rr_type = 251;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_AXFR: sldns_enum_rr_type = 252;
#[doc = "  A request for mailbox-related records (MB, MG or MR)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MAILB: sldns_enum_rr_type = 253;
#[doc = "  A request for mail agent RRs (Obsolete - see MX)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MAILA: sldns_enum_rr_type = 254;
#[doc = "  any type (wildcard)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_ANY: sldns_enum_rr_type = 255;
#[doc = "  any type (wildcard)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_URI: sldns_enum_rr_type = 256;
#[doc = "  any type (wildcard)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CAA: sldns_enum_rr_type = 257;
#[doc = "  any type (wildcard)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_AVC: sldns_enum_rr_type = 258;
#[doc = " DNSSEC Trust Authorities"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TA: sldns_enum_rr_type = 32768;
#[doc = " DNSSEC Trust Authorities"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_DLV: sldns_enum_rr_type = 32769;
#[doc = " DNSSEC Trust Authorities"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_FIRST: sldns_enum_rr_type = 0;
#[doc = " DNSSEC Trust Authorities"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_LAST: sldns_enum_rr_type = 65535;
#[doc = " DNSSEC Trust Authorities"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_COUNT: sldns_enum_rr_type = 65536;
#[doc = " The different RR types."]
pub type sldns_enum_rr_type = ::std::os::raw::c_uint;
#[doc = " The different RR types."]
pub use self::sldns_enum_rr_type as sldns_rr_type;
#[doc = " none"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_NONE: sldns_enum_rdf_type = 0;
#[doc = " domain name"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_DNAME: sldns_enum_rdf_type = 1;
#[doc = " 8 bits"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_INT8: sldns_enum_rdf_type = 2;
#[doc = " 16 bits"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_INT16: sldns_enum_rdf_type = 3;
#[doc = " 32 bits"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_INT32: sldns_enum_rdf_type = 4;
#[doc = " A record"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_A: sldns_enum_rdf_type = 5;
#[doc = " AAAA record"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_AAAA: sldns_enum_rdf_type = 6;
#[doc = " txt string"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_STR: sldns_enum_rdf_type = 7;
#[doc = " apl data"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_APL: sldns_enum_rdf_type = 8;
#[doc = " b32 string"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_B32_EXT: sldns_enum_rdf_type = 9;
#[doc = " b64 string"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_B64: sldns_enum_rdf_type = 10;
#[doc = " hex string"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_HEX: sldns_enum_rdf_type = 11;
#[doc = " nsec type codes"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_NSEC: sldns_enum_rdf_type = 12;
#[doc = " a RR type"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_TYPE: sldns_enum_rdf_type = 13;
#[doc = " a class"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_CLASS: sldns_enum_rdf_type = 14;
#[doc = " certificate algorithm"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_CERT_ALG: sldns_enum_rdf_type = 15;
#[doc = " a key algorithm"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_ALG: sldns_enum_rdf_type = 16;
#[doc = " unknown types"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_UNKNOWN: sldns_enum_rdf_type = 17;
#[doc = " time (32 bits)"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_TIME: sldns_enum_rdf_type = 18;
#[doc = " period"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_PERIOD: sldns_enum_rdf_type = 19;
#[doc = " tsig time 48 bits"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_TSIGTIME: sldns_enum_rdf_type = 20;
#[doc = " Represents the Public Key Algorithm, HIT and Public Key fields\nfor the HIP RR types.  A HIP specific rdf type is used because of\nthe unusual layout in wireformat (see RFC 5205 Section 5)"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_HIP: sldns_enum_rdf_type = 21;
#[doc = " variable length any type rdata where the length\nis specified by the first 2 bytes"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_INT16_DATA: sldns_enum_rdf_type = 22;
#[doc = " protocol and port bitmaps"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_SERVICE: sldns_enum_rdf_type = 23;
#[doc = " location data"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_LOC: sldns_enum_rdf_type = 24;
#[doc = " well known services"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_WKS: sldns_enum_rdf_type = 25;
#[doc = " NSAP"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_NSAP: sldns_enum_rdf_type = 26;
#[doc = " ATMA"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_ATMA: sldns_enum_rdf_type = 27;
#[doc = " IPSECKEY"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_IPSECKEY: sldns_enum_rdf_type = 28;
#[doc = " nsec3 hash salt"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_NSEC3_SALT: sldns_enum_rdf_type = 29;
#[doc = " nsec3 base32 string (with length byte on wire"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_NSEC3_NEXT_OWNER: sldns_enum_rdf_type = 30;
#[doc = " 4 shorts represented as 4 * 16 bit hex numbers\n  separated by colons. For NID and L64."]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_ILNP64: sldns_enum_rdf_type = 31;
#[doc = " 6 * 8 bit hex numbers separated by dashes. For EUI48."]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_EUI48: sldns_enum_rdf_type = 32;
#[doc = " 8 * 8 bit hex numbers separated by dashes. For EUI64."]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_EUI64: sldns_enum_rdf_type = 33;
#[doc = " A non-zero sequence of US-ASCII letters and numbers in lower case.\n  For CAA."]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_TAG: sldns_enum_rdf_type = 34;
#[doc = " A <character-string> encoding of the value field as specified\n [RFC1035], Section 5.1., encoded as remaining rdata.\n For CAA, URI."]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_LONG_STR: sldns_enum_rdf_type = 35;
#[doc = " TSIG extended 16bit error value"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_TSIGERROR: sldns_enum_rdf_type = 36;
#[doc = " TSIG extended 16bit error value"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_SVCPARAM: sldns_enum_rdf_type = 37;
#[doc = " TSIG extended 16bit error value"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_BITMAP: sldns_enum_rdf_type = 12;
#[doc = " The different types of RDATA fields."]
pub type sldns_enum_rdf_type = ::std::os::raw::c_uint;
#[doc = " The different types of RDATA fields."]
pub use self::sldns_enum_rdf_type as sldns_rdf_type;
pub const sldns_enum_algorithm_LDNS_RSAMD5: sldns_enum_algorithm = 1;
pub const sldns_enum_algorithm_LDNS_DH: sldns_enum_algorithm = 2;
pub const sldns_enum_algorithm_LDNS_DSA: sldns_enum_algorithm = 3;
pub const sldns_enum_algorithm_LDNS_ECC: sldns_enum_algorithm = 4;
pub const sldns_enum_algorithm_LDNS_RSASHA1: sldns_enum_algorithm = 5;
pub const sldns_enum_algorithm_LDNS_DSA_NSEC3: sldns_enum_algorithm = 6;
pub const sldns_enum_algorithm_LDNS_RSASHA1_NSEC3: sldns_enum_algorithm = 7;
pub const sldns_enum_algorithm_LDNS_RSASHA256: sldns_enum_algorithm = 8;
pub const sldns_enum_algorithm_LDNS_RSASHA512: sldns_enum_algorithm = 10;
pub const sldns_enum_algorithm_LDNS_ECC_GOST: sldns_enum_algorithm = 12;
pub const sldns_enum_algorithm_LDNS_ECDSAP256SHA256: sldns_enum_algorithm = 13;
pub const sldns_enum_algorithm_LDNS_ECDSAP384SHA384: sldns_enum_algorithm = 14;
pub const sldns_enum_algorithm_LDNS_ED25519: sldns_enum_algorithm = 15;
pub const sldns_enum_algorithm_LDNS_ED448: sldns_enum_algorithm = 16;
pub const sldns_enum_algorithm_LDNS_INDIRECT: sldns_enum_algorithm = 252;
pub const sldns_enum_algorithm_LDNS_PRIVATEDNS: sldns_enum_algorithm = 253;
pub const sldns_enum_algorithm_LDNS_PRIVATEOID: sldns_enum_algorithm = 254;
#[doc = " Algorithms used in dns"]
pub type sldns_enum_algorithm = ::std::os::raw::c_uint;
#[doc = " Algorithms used in dns"]
pub use self::sldns_enum_algorithm as sldns_algorithm;
pub const sldns_enum_hash_LDNS_SHA1: sldns_enum_hash = 1;
pub const sldns_enum_hash_LDNS_SHA256: sldns_enum_hash = 2;
pub const sldns_enum_hash_LDNS_HASH_GOST: sldns_enum_hash = 3;
pub const sldns_enum_hash_LDNS_SHA384: sldns_enum_hash = 4;
#[doc = " Hashing algorithms used in the DS record"]
pub type sldns_enum_hash = ::std::os::raw::c_uint;
#[doc = " Hashing algorithms used in the DS record"]
pub use self::sldns_enum_hash as sldns_hash;
pub const sldns_enum_cert_algorithm_LDNS_CERT_PKIX: sldns_enum_cert_algorithm = 1;
pub const sldns_enum_cert_algorithm_LDNS_CERT_SPKI: sldns_enum_cert_algorithm = 2;
pub const sldns_enum_cert_algorithm_LDNS_CERT_PGP: sldns_enum_cert_algorithm = 3;
pub const sldns_enum_cert_algorithm_LDNS_CERT_IPKIX: sldns_enum_cert_algorithm = 4;
pub const sldns_enum_cert_algorithm_LDNS_CERT_ISPKI: sldns_enum_cert_algorithm = 5;
pub const sldns_enum_cert_algorithm_LDNS_CERT_IPGP: sldns_enum_cert_algorithm = 6;
pub const sldns_enum_cert_algorithm_LDNS_CERT_ACPKIX: sldns_enum_cert_algorithm = 7;
pub const sldns_enum_cert_algorithm_LDNS_CERT_IACPKIX: sldns_enum_cert_algorithm = 8;
pub const sldns_enum_cert_algorithm_LDNS_CERT_URI: sldns_enum_cert_algorithm = 253;
pub const sldns_enum_cert_algorithm_LDNS_CERT_OID: sldns_enum_cert_algorithm = 254;
#[doc = " algorithms used in CERT rrs"]
pub type sldns_enum_cert_algorithm = ::std::os::raw::c_uint;
#[doc = " algorithms used in CERT rrs"]
pub use self::sldns_enum_cert_algorithm as sldns_cert_algorithm;
pub const sldns_enum_edns_option_LDNS_EDNS_LLQ: sldns_enum_edns_option = 1;
pub const sldns_enum_edns_option_LDNS_EDNS_UL: sldns_enum_edns_option = 2;
pub const sldns_enum_edns_option_LDNS_EDNS_NSID: sldns_enum_edns_option = 3;
pub const sldns_enum_edns_option_LDNS_EDNS_DAU: sldns_enum_edns_option = 5;
pub const sldns_enum_edns_option_LDNS_EDNS_DHU: sldns_enum_edns_option = 6;
pub const sldns_enum_edns_option_LDNS_EDNS_N3U: sldns_enum_edns_option = 7;
pub const sldns_enum_edns_option_LDNS_EDNS_CLIENT_SUBNET: sldns_enum_edns_option = 8;
pub const sldns_enum_edns_option_LDNS_EDNS_COOKIE: sldns_enum_edns_option = 10;
pub const sldns_enum_edns_option_LDNS_EDNS_KEEPALIVE: sldns_enum_edns_option = 11;
pub const sldns_enum_edns_option_LDNS_EDNS_PADDING: sldns_enum_edns_option = 12;
pub const sldns_enum_edns_option_LDNS_EDNS_EDE: sldns_enum_edns_option = 15;
pub const sldns_enum_edns_option_LDNS_EDNS_CLIENT_TAG: sldns_enum_edns_option = 16;
pub const sldns_enum_edns_option_LDNS_EDNS_UNBOUND_CACHEDB_TESTFRAME_TEST: sldns_enum_edns_option =
    65534;
#[doc = " EDNS option codes"]
pub type sldns_enum_edns_option = ::std::os::raw::c_uint;
#[doc = " EDNS option codes"]
pub use self::sldns_enum_edns_option as sldns_edns_option;
pub const sldns_enum_ede_code_LDNS_EDE_NONE: sldns_enum_ede_code = -1;
pub const sldns_enum_ede_code_LDNS_EDE_OTHER: sldns_enum_ede_code = 0;
pub const sldns_enum_ede_code_LDNS_EDE_UNSUPPORTED_DNSKEY_ALG: sldns_enum_ede_code = 1;
pub const sldns_enum_ede_code_LDNS_EDE_UNSUPPORTED_DS_DIGEST: sldns_enum_ede_code = 2;
pub const sldns_enum_ede_code_LDNS_EDE_STALE_ANSWER: sldns_enum_ede_code = 3;
pub const sldns_enum_ede_code_LDNS_EDE_FORGED_ANSWER: sldns_enum_ede_code = 4;
pub const sldns_enum_ede_code_LDNS_EDE_DNSSEC_INDETERMINATE: sldns_enum_ede_code = 5;
pub const sldns_enum_ede_code_LDNS_EDE_DNSSEC_BOGUS: sldns_enum_ede_code = 6;
pub const sldns_enum_ede_code_LDNS_EDE_SIGNATURE_EXPIRED: sldns_enum_ede_code = 7;
pub const sldns_enum_ede_code_LDNS_EDE_SIGNATURE_NOT_YET_VALID: sldns_enum_ede_code = 8;
pub const sldns_enum_ede_code_LDNS_EDE_DNSKEY_MISSING: sldns_enum_ede_code = 9;
pub const sldns_enum_ede_code_LDNS_EDE_RRSIGS_MISSING: sldns_enum_ede_code = 10;
pub const sldns_enum_ede_code_LDNS_EDE_NO_ZONE_KEY_BIT_SET: sldns_enum_ede_code = 11;
pub const sldns_enum_ede_code_LDNS_EDE_NSEC_MISSING: sldns_enum_ede_code = 12;
pub const sldns_enum_ede_code_LDNS_EDE_CACHED_ERROR: sldns_enum_ede_code = 13;
pub const sldns_enum_ede_code_LDNS_EDE_NOT_READY: sldns_enum_ede_code = 14;
pub const sldns_enum_ede_code_LDNS_EDE_BLOCKED: sldns_enum_ede_code = 15;
pub const sldns_enum_ede_code_LDNS_EDE_CENSORED: sldns_enum_ede_code = 16;
pub const sldns_enum_ede_code_LDNS_EDE_FILTERED: sldns_enum_ede_code = 17;
pub const sldns_enum_ede_code_LDNS_EDE_PROHIBITED: sldns_enum_ede_code = 18;
pub const sldns_enum_ede_code_LDNS_EDE_STALE_NXDOMAIN_ANSWER: sldns_enum_ede_code = 19;
pub const sldns_enum_ede_code_LDNS_EDE_NOT_AUTHORITATIVE: sldns_enum_ede_code = 20;
pub const sldns_enum_ede_code_LDNS_EDE_NOT_SUPPORTED: sldns_enum_ede_code = 21;
pub const sldns_enum_ede_code_LDNS_EDE_NO_REACHABLE_AUTHORITY: sldns_enum_ede_code = 22;
pub const sldns_enum_ede_code_LDNS_EDE_NETWORK_ERROR: sldns_enum_ede_code = 23;
pub const sldns_enum_ede_code_LDNS_EDE_INVALID_DATA: sldns_enum_ede_code = 24;
pub const sldns_enum_ede_code_LDNS_EDE_SIGNATURE_EXPIRED_BEFORE_VALID: sldns_enum_ede_code = 25;
pub const sldns_enum_ede_code_LDNS_EDE_TOO_EARLY: sldns_enum_ede_code = 26;
pub const sldns_enum_ede_code_LDNS_EDE_UNSUPPORTED_NSEC3_ITERATIONS: sldns_enum_ede_code = 27;
pub const sldns_enum_ede_code_LDNS_EDE_BADPROXYPOLICY: sldns_enum_ede_code = 28;
pub const sldns_enum_ede_code_LDNS_EDE_SYNTHESIZED: sldns_enum_ede_code = 29;
pub type sldns_enum_ede_code = ::std::os::raw::c_int;
pub use self::sldns_enum_ede_code as sldns_ede_code;
#[doc = " Contains all information about resource record types.\n\n This structure contains, for all rr types, the rdata fields that are defined."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sldns_struct_rr_descriptor {
    #[doc = " Type of the RR that is described here"]
    pub _type: sldns_rr_type,
    #[doc = " Textual name of the RR type."]
    pub _name: *const ::std::os::raw::c_char,
    #[doc = " Minimum number of rdata fields in the RRs of this type."]
    pub _minimum: u8,
    #[doc = " Maximum number of rdata fields in the RRs of this type."]
    pub _maximum: u8,
    #[doc = " Wireformat specification for the rr, i.e. the types of rdata fields in their respective order."]
    pub _wireformat: *const sldns_rdf_type,
    #[doc = " Special rdf types"]
    pub _variable: sldns_rdf_type,
    #[doc = " Specifies whether compression can be used for dnames in this RR type."]
    pub _compress: sldns_rr_compress,
    #[doc = " The number of DNAMEs in the _wireformat string, for parsing."]
    pub _dname_count: u8,
}
#[doc = " Contains all information about resource record types.\n\n This structure contains, for all rr types, the rdata fields that are defined."]
pub type sldns_rr_descriptor = sldns_struct_rr_descriptor;
extern "C" {
    #[doc = " returns the resource record descriptor for the given rr type.\n\n \\param[in] type the type value of the rr type\n\\return the sldns_rr_descriptor for this type"]
    pub fn sldns_rr_descript(type_: u16) -> *const sldns_rr_descriptor;
}
extern "C" {
    #[doc = " returns the minimum number of rdata fields of the rr type this descriptor describes.\n\n \\param[in]  descriptor for an rr type\n \\return the minimum number of rdata fields"]
    pub fn sldns_rr_descriptor_minimum(descriptor: *const sldns_rr_descriptor) -> usize;
}
extern "C" {
    #[doc = " returns the maximum number of rdata fields of the rr type this descriptor describes.\n\n \\param[in]  descriptor for an rr type\n \\return the maximum number of rdata fields"]
    pub fn sldns_rr_descriptor_maximum(descriptor: *const sldns_rr_descriptor) -> usize;
}
extern "C" {
    #[doc = " returns the rdf type for the given rdata field number of the rr type for the given descriptor.\n\n \\param[in] descriptor for an rr type\n \\param[in] field the field number\n \\return the rdf type for the field"]
    pub fn sldns_rr_descriptor_field_type(
        descriptor: *const sldns_rr_descriptor,
        field: usize,
    ) -> sldns_rdf_type;
}
extern "C" {
    #[doc = " retrieves a rrtype by looking up its name.\n \\param[in] name a string with the name\n \\return the type which corresponds with the name"]
    pub fn sldns_get_rr_type_by_name(name: *const ::std::os::raw::c_char) -> sldns_rr_type;
}
extern "C" {
    #[doc = " retrieves a class by looking up its name.\n \\param[in] name string with the name\n \\return the cass which corresponds with the name"]
    pub fn sldns_get_rr_class_by_name(name: *const ::std::os::raw::c_char) -> sldns_rr_class;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comm_reply {
    _unused: [u8; 0],
}
#[doc = " Structure to store query information that makes answers to queries\n different."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct query_info {
    #[doc = " Salient data on the query: qname, in wireformat.\n can be allocated or a pointer to outside buffer.\n User has to keep track on the status of this."]
    pub qname: *mut u8,
    #[doc = " length of qname (including last 0 octet)"]
    pub qname_len: usize,
    #[doc = " qtype, host byte order"]
    pub qtype: u16,
    #[doc = " qclass, host byte order"]
    pub qclass: u16,
    #[doc = " Alias local answer(s) for the qname.  If 'qname' is an alias defined\n in a local zone, this field will be set to the corresponding local\n RRset when the alias is determined.\n In the initial implementation this can only be a single CNAME RR\n (or NULL), but it could possibly be extended to be a DNAME or a\n chain of aliases.\n Users of this structure are responsible to initialize this field\n to be NULL; otherwise other part of query handling code may be\n confused.\n Users also have to be careful about the lifetime of data.  On return\n from local zone lookup, it may point to data derived from\n configuration that may be dynamically invalidated or data allocated\n in an ephemeral regional allocator.  A deep copy of the data may\n have to be generated if it has to be kept during iterative\n resolution."]
    pub local_alias: *mut local_rrset,
}
#[doc = " Information to reference an rrset"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rrset_ref {
    #[doc = " the key with lock, and ptr to packed data."]
    pub key: *mut ub_packed_rrset_key,
    #[doc = " id needed"]
    pub id: rrset_id_type,
}
#[doc = " Structure to store DNS query and the reply packet.\n To use it, copy over the flags from reply and modify using flags from\n the query (RD,CD if not AA). prepend ID.\n\n Memory layout is:\n\to struct\n\to rrset_ref array\n\to packed_rrset_key* array.\n\n Memory layout is sometimes not packed, when the message is synthesized,\n for easy of the generation. It is allocated packed when it is copied\n from the region allocation to the malloc allocation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reply_info {
    #[doc = " the flags for the answer, host byte order."]
    pub flags: u16,
    #[doc = " This flag informs unbound the answer is authoritative and\n the AA flag should be preserved."]
    pub authoritative: u8,
    #[doc = " Number of RRs in the query section.\n If qdcount is not 0, then it is 1, and the data that appears\n in the reply is the same as the query_info.\n Host byte order."]
    pub qdcount: u8,
    #[doc = " 32 bit padding to pad struct member alignment to 64 bits."]
    pub padding: u32,
    #[doc = " TTL of the entire reply (for negative caching).\n only for use when there are 0 RRsets in this message.\n if there are RRsets, check those instead."]
    pub ttl: time_t,
    #[doc = " TTL for prefetch. After it has expired, a prefetch is suitable.\n Smaller than the TTL, otherwise the prefetch would not happen."]
    pub prefetch_ttl: time_t,
    #[doc = " Reply TTL extended with serve expired TTL, to limit time to serve\n expired message."]
    pub serve_expired_ttl: time_t,
    #[doc = " The security status from DNSSEC validation of this message."]
    pub security: sec_status,
    #[doc = " EDE (rfc8914) code with reason for DNSSEC bogus status.\n Used for caching the EDE."]
    pub reason_bogus: sldns_ede_code,
    #[doc = " EDE (rfc8914) NULL-terminated string with human-readable reason\n for DNSSEC bogus status.\n Used for caching the EDE."]
    pub reason_bogus_str: *mut ::std::os::raw::c_char,
    #[doc = " Number of RRsets in each section.\n The answer section. Add up the RRs in every RRset to calculate\n the number of RRs, and the count for the dns packet.\n The number of RRs in RRsets can change due to RRset updates."]
    pub an_numrrsets: usize,
    #[doc = " Count of authority section RRsets"]
    pub ns_numrrsets: usize,
    #[doc = " Count of additional section RRsets"]
    pub ar_numrrsets: usize,
    #[doc = " number of RRsets: an_numrrsets + ns_numrrsets + ar_numrrsets"]
    pub rrset_count: usize,
    #[doc = " List of pointers (only) to the rrsets in the order in which\n they appear in the reply message.\n Number of elements is ancount+nscount+arcount RRsets.\n This is a pointer to that array.\n Use the accessor function for access."]
    pub rrsets: *mut *mut ub_packed_rrset_key,
    #[doc = " Packed array of ids (see counts) and pointers to packed_rrset_key.\n The number equals ancount+nscount+arcount RRsets.\n These are sorted in ascending pointer, the locking order. So\n this list can be locked (and id, ttl checked), to see if\n all the data is available and recent enough.\n\n This is defined as an array of size 1, so that the compiler\n associates the identifier with this position in the structure.\n Array bound overflow on this array then gives access to the further\n elements of the array, which are allocated after the main structure.\n\n It could be more pure to define as array of size 0, ref[0].\n But ref[1] may be less confusing for compilers.\n Use the accessor function for access."]
    pub ref_: [rrset_ref; 1usize],
}
#[doc = " Region allocated message reply"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dns_msg {
    #[doc = " query info"]
    pub qinfo: query_info,
    #[doc = " reply info - ptr to packed repinfo structure"]
    pub rep: *mut reply_info,
}
#[doc = " The rbnode_type struct definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rbnode_type {
    #[doc = " parent in rbtree, RBTREE_NULL for root"]
    pub parent: *mut rbnode_type,
    #[doc = " left node (smaller items)"]
    pub left: *mut rbnode_type,
    #[doc = " right node (larger items)"]
    pub right: *mut rbnode_type,
    #[doc = " pointer to sorting key"]
    pub key: *const ::std::os::raw::c_void,
    #[doc = " colour of this node"]
    pub color: u8,
}
extern "C" {
    #[doc = " the global empty node"]
    pub static mut rbtree_null_node: rbnode_type;
}
#[doc = " definition for tree struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rbtree_type {
    #[doc = " The root of the red-black tree"]
    pub root: *mut rbnode_type,
    #[doc = " The number of the nodes in the tree"]
    pub count: usize,
    #[doc = " Key compare function. <0,0,>0 like strcmp.\n Return 0 on two NULL ptrs."]
    pub cmp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
extern "C" {
    #[doc = " Create new tree (malloced) with given key compare function.\n @param cmpf: compare function (like strcmp) takes pointers to two keys.\n @return: new tree, empty."]
    pub fn rbtree_create(
        cmpf: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut rbtree_type;
}
extern "C" {
    #[doc = " Init a new tree (malloced by caller) with given key compare function.\n @param rbtree: uninitialised memory for new tree, returned empty.\n @param cmpf: compare function (like strcmp) takes pointers to two keys."]
    pub fn rbtree_init(
        rbtree: *mut rbtree_type,
        cmpf: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " Insert data into the tree.\n @param rbtree: tree to insert to.\n @param data: element to insert.\n @return: data ptr or NULL if key already present."]
    pub fn rbtree_insert(rbtree: *mut rbtree_type, data: *mut rbnode_type) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Delete element from tree.\n @param rbtree: tree to delete from.\n @param key: key of item to delete.\n @return: node that is now unlinked from the tree. User to delete it.\n returns 0 if node not present"]
    pub fn rbtree_delete(
        rbtree: *mut rbtree_type,
        key: *const ::std::os::raw::c_void,
    ) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Find key in tree. Returns NULL if not found.\n @param rbtree: tree to find in.\n @param key: key that must match.\n @return: node that fits or NULL."]
    pub fn rbtree_search(
        rbtree: *mut rbtree_type,
        key: *const ::std::os::raw::c_void,
    ) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Find, but match does not have to be exact.\n @param rbtree: tree to find in.\n @param key: key to find position of.\n @param result: set to the exact node if present, otherwise to element that\n   precedes the position of key in the tree. NULL if no smaller element.\n @return: true if exact match in result. Else result points to <= element,\n or NULL if key is smaller than the smallest key."]
    pub fn rbtree_find_less_equal(
        rbtree: *mut rbtree_type,
        key: *const ::std::os::raw::c_void,
        result: *mut *mut rbnode_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns first (smallest) node in the tree\n @param rbtree: tree\n @return: smallest element or NULL if tree empty."]
    pub fn rbtree_first(rbtree: *mut rbtree_type) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Returns last (largest) node in the tree\n @param rbtree: tree\n @return: largest element or NULL if tree empty."]
    pub fn rbtree_last(rbtree: *mut rbtree_type) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Returns next larger node in the tree\n @param rbtree: tree\n @return: next larger element or NULL if no larger in tree."]
    pub fn rbtree_next(rbtree: *mut rbnode_type) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Returns previous smaller node in the tree\n @param rbtree: tree\n @return: previous smaller element or NULL if no previous in tree."]
    pub fn rbtree_previous(rbtree: *mut rbnode_type) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Call function for all elements in the redblack tree, such that\n leaf elements are called before parent elements. So that all\n elements can be safely free()d.\n Note that your function must not remove the nodes from the tree.\n Since that may trigger rebalances of the rbtree.\n @param tree: the tree\n @param func: function called with element and user arg.\n \tThe function must not alter the rbtree.\n @param arg: user argument."]
    pub fn traverse_postorder(
        tree: *mut rbtree_type,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut rbnode_type, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
pub const sldns_enum_pkt_section_LDNS_SECTION_QUESTION: sldns_enum_pkt_section = 0;
pub const sldns_enum_pkt_section_LDNS_SECTION_ANSWER: sldns_enum_pkt_section = 1;
pub const sldns_enum_pkt_section_LDNS_SECTION_AUTHORITY: sldns_enum_pkt_section = 2;
pub const sldns_enum_pkt_section_LDNS_SECTION_ADDITIONAL: sldns_enum_pkt_section = 3;
#[doc = " bogus section, if not interested"]
pub const sldns_enum_pkt_section_LDNS_SECTION_ANY: sldns_enum_pkt_section = 4;
#[doc = " used to get all non-question rrs from a packet"]
pub const sldns_enum_pkt_section_LDNS_SECTION_ANY_NOQUESTION: sldns_enum_pkt_section = 5;
#[doc = " The sections of a packet"]
pub type sldns_enum_pkt_section = ::std::os::raw::c_uint;
#[doc = " The sections of a packet"]
pub use self::sldns_enum_pkt_section as sldns_pkt_section;
pub const sldns_enum_pkt_opcode_LDNS_PACKET_QUERY: sldns_enum_pkt_opcode = 0;
pub const sldns_enum_pkt_opcode_LDNS_PACKET_IQUERY: sldns_enum_pkt_opcode = 1;
pub const sldns_enum_pkt_opcode_LDNS_PACKET_STATUS: sldns_enum_pkt_opcode = 2;
pub const sldns_enum_pkt_opcode_LDNS_PACKET_NOTIFY: sldns_enum_pkt_opcode = 4;
pub const sldns_enum_pkt_opcode_LDNS_PACKET_UPDATE: sldns_enum_pkt_opcode = 5;
pub type sldns_enum_pkt_opcode = ::std::os::raw::c_uint;
pub use self::sldns_enum_pkt_opcode as sldns_pkt_opcode;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NOERROR: sldns_enum_pkt_rcode = 0;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_FORMERR: sldns_enum_pkt_rcode = 1;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_SERVFAIL: sldns_enum_pkt_rcode = 2;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NXDOMAIN: sldns_enum_pkt_rcode = 3;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NOTIMPL: sldns_enum_pkt_rcode = 4;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_REFUSED: sldns_enum_pkt_rcode = 5;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_YXDOMAIN: sldns_enum_pkt_rcode = 6;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_YXRRSET: sldns_enum_pkt_rcode = 7;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NXRRSET: sldns_enum_pkt_rcode = 8;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NOTAUTH: sldns_enum_pkt_rcode = 9;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NOTZONE: sldns_enum_pkt_rcode = 10;
pub type sldns_enum_pkt_rcode = ::std::os::raw::c_uint;
pub use self::sldns_enum_pkt_rcode as sldns_pkt_rcode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_file {
    _unused: [u8; 0],
}
#[doc = " EDNS data storage\n rdata is parsed in a list (has accessor functions). allocated in a\n region."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct edns_data {
    #[doc = " Extended RCODE"]
    pub ext_rcode: u8,
    #[doc = " The EDNS version number"]
    pub edns_version: u8,
    #[doc = " the EDNS bits field from ttl (host order): Z"]
    pub bits: u16,
    #[doc = " UDP reassembly size."]
    pub udp_size: u16,
    #[doc = " rdata element list of options of an incoming packet created at\n parse time, or NULL if none"]
    pub opt_list_in: *mut edns_option,
    #[doc = " rdata element list of options to encode for outgoing packets,\n or NULL if none"]
    pub opt_list_out: *mut edns_option,
    #[doc = " rdata element list of outgoing edns options from modules\n or NULL if none"]
    pub opt_list_inplace_cb_out: *mut edns_option,
    #[doc = " block size to pad"]
    pub padding_block_size: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl edns_data {
    #[inline]
    pub fn edns_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_edns_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cookie_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cookie_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cookie_valid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cookie_valid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cookie_client(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cookie_client(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        edns_present: ::std::os::raw::c_uint,
        cookie_present: ::std::os::raw::c_uint,
        cookie_valid: ::std::os::raw::c_uint,
        cookie_client: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let edns_present: u32 = unsafe { ::std::mem::transmute(edns_present) };
            edns_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cookie_present: u32 = unsafe { ::std::mem::transmute(cookie_present) };
            cookie_present as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cookie_valid: u32 = unsafe { ::std::mem::transmute(cookie_valid) };
            cookie_valid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cookie_client: u32 = unsafe { ::std::mem::transmute(cookie_client) };
            cookie_client as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " EDNS option"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct edns_option {
    #[doc = " next item in list"]
    pub next: *mut edns_option,
    #[doc = " type of this edns option"]
    pub opt_code: u16,
    #[doc = " length of this edns option (cannot exceed uint16 in encoding)"]
    pub opt_len: usize,
    #[doc = " data of this edns option; allocated in region, or NULL if len=0"]
    pub opt_data: *mut u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rrset_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slabhash {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct worker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comm_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auth_zones {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct outside_network {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ub_randstate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mesh_area {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mesh_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct val_anchors {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct val_neg_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iter_forwards {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iter_hints {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct respip_set {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct respip_client_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct respip_addr_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_stack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct errinf_strlist {
    #[doc = " next item in list"]
    pub next: *mut errinf_strlist,
    #[doc = " config option string"]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = " EDE code companion to the error str"]
    pub reason_bogus: ::std::os::raw::c_int,
}
pub const inplace_cb_list_type_inplace_cb_reply: inplace_cb_list_type = 0;
pub const inplace_cb_list_type_inplace_cb_reply_cache: inplace_cb_list_type = 1;
pub const inplace_cb_list_type_inplace_cb_reply_local: inplace_cb_list_type = 2;
pub const inplace_cb_list_type_inplace_cb_reply_servfail: inplace_cb_list_type = 3;
pub const inplace_cb_list_type_inplace_cb_query: inplace_cb_list_type = 4;
pub const inplace_cb_list_type_inplace_cb_query_response: inplace_cb_list_type = 5;
pub const inplace_cb_list_type_inplace_cb_edns_back_parsed: inplace_cb_list_type = 6;
pub const inplace_cb_list_type_inplace_cb_types_total: inplace_cb_list_type = 7;
pub type inplace_cb_list_type = ::std::os::raw::c_uint;
#[doc = " Known edns option. Can be populated during modules' init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct edns_known_option {
    #[doc = " type of this edns option"]
    pub opt_code: u16,
    #[doc = " whether the option needs to bypass the cache stage"]
    pub bypass_cache_stage: ::std::os::raw::c_int,
    #[doc = " whether the option needs mesh aggregation"]
    pub no_aggregation: ::std::os::raw::c_int,
}
#[doc = " Inplace callback list of registered routines to be called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inplace_cb {
    #[doc = " next in list"]
    pub next: *mut inplace_cb,
    #[doc = " Inplace callback routine"]
    pub cb: *mut ::std::os::raw::c_void,
    pub cb_arg: *mut ::std::os::raw::c_void,
    #[doc = " module id"]
    pub id: ::std::os::raw::c_int,
}
#[doc = " Inplace callback function called before replying.\n Called as func(qinfo, qstate, rep, rcode, edns, opt_list_out, repinfo,\n                region, id, python_callback)\n Where:\n\tqinfo: the query info.\n\tqstate: the module state. NULL when calling before the query reaches the\n\t\tmesh states.\n\trep: reply_info. Could be NULL.\n\trcode: the return code.\n\tedns: the edns_data of the reply. When qstate is NULL, it is also used as\n\t\tthe edns input.\n\topt_list_out: the edns options list for the reply.\n\trepinfo: reply information for a communication point. NULL when calling\n\t\tduring the mesh states; the same could be found from\n\t\tqstate->mesh_info->reply_list.\n\tregion: region to store data.\n\tid: module id.\n\tpython_callback: only used for registering a python callback function."]
pub type inplace_cb_reply_func_type = ::std::option::Option<
    unsafe extern "C" fn(
        qinfo: *mut query_info,
        qstate: *mut module_qstate,
        rep: *mut reply_info,
        rcode: ::std::os::raw::c_int,
        edns: *mut edns_data,
        opt_list_out: *mut *mut edns_option,
        repinfo: *mut comm_reply,
        region: *mut regional,
        start_time: *mut timeval,
        id: ::std::os::raw::c_int,
        callback: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Inplace callback function called before sending the query to a nameserver.\n Called as func(qinfo, flags, qstate, addr, addrlen, zone, zonelen, region,\n                id, python_callback)\n Where:\n\tqinfo: query info.\n\tflags: flags of the query.\n\tqstate: query state.\n\taddr: to which server to send the query.\n\taddrlen: length of addr.\n\tzone: name of the zone of the delegation point. wireformat dname.\n\t\tThis is the delegation point name for which the server is deemed\n\t\tauthoritative.\n\tzonelen: length of zone.\n\tregion: region to store data.\n\tid: module id.\n\tpython_callback: only used for registering a python callback function."]
pub type inplace_cb_query_func_type = ::std::option::Option<
    unsafe extern "C" fn(
        qinfo: *mut query_info,
        flags: u16,
        qstate: *mut module_qstate,
        addr: *mut sockaddr_storage,
        addrlen: socklen_t,
        zone: *mut u8,
        zonelen: usize,
        region: *mut regional,
        id: ::std::os::raw::c_int,
        callback: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Inplace callback function called after parsing edns on query reply.\n Called as func(qstate, id, cb_args)\n Where:\n\tqstate: the query state.\n\tid: module id.\n\tcb_args: argument passed when registering callback."]
pub type inplace_cb_edns_back_parsed_func_type = ::std::option::Option<
    unsafe extern "C" fn(
        qstate: *mut module_qstate,
        id: ::std::os::raw::c_int,
        cb_args: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Inplace callback function called after parsing query response.\n Called as func(qstate, response, id, cb_args)\n Where:\n\tqstate: the query state.\n\tresponse: query response.\n\tid: module id.\n\tcb_args: argument passed when registering callback."]
pub type inplace_cb_query_response_func_type = ::std::option::Option<
    unsafe extern "C" fn(
        qstate: *mut module_qstate,
        response: *mut dns_msg,
        id: ::std::os::raw::c_int,
        cb_args: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Function called when looking for (expired) cached answers during the serve\n expired logic.\n Called as func(qstate, lookup_qinfo)\n Where:\n\tqstate: the query state.\n\tlookup_qinfo: the qinfo to lookup for."]
pub type serve_expired_lookup_func_type = ::std::option::Option<
    unsafe extern "C" fn(qstate: *mut module_qstate, lookup_qinfo: *mut query_info) -> *mut dns_msg,
>;
#[doc = " Module environment.\n Services and data provided to the module."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_env {
    #[doc = " config file with config options"]
    pub cfg: *mut config_file,
    #[doc = " shared message cache"]
    pub msg_cache: *mut slabhash,
    #[doc = " shared rrset cache"]
    pub rrset_cache: *mut rrset_cache,
    #[doc = " shared infrastructure cache (edns, lameness)"]
    pub infra_cache: *mut infra_cache,
    #[doc = " shared key cache"]
    pub key_cache: *mut key_cache,
    #[doc = " Send serviced DNS query to server. UDP/TCP and EDNS is handled.\n operate() should return with wait_reply. Later on a callback\n will cause operate() to be called with event timeout or reply.\n The time until a timeout is calculated from roundtrip timing,\n several UDP retries are attempted.\n @param qinfo: query info.\n @param flags: host order flags word, with opcode and CD bit.\n @param dnssec: if set, EDNS record will have bits set.\n\tIf EDNS_DO bit is set, DO bit is set in EDNS records.\n\tIf BIT_CD is set, CD bit is set in queries with EDNS records.\n @param want_dnssec: if set, the validator wants DNSSEC.  Without\n \tEDNS, the answer is likely to be useless for this domain.\n @param nocaps: do not use caps_for_id, use the qname as given.\n\t(ignored if caps_for_id is disabled).\n @param check_ratelimit: if set, will check ratelimit before sending out.\n @param addr: where to.\n @param addrlen: length of addr.\n @param zone: delegation point name.\n @param zonelen: length of zone name.\n @param tcp_upstream: use TCP for upstream queries.\n @param ssl_upstream: use SSL for upstream queries.\n @param tls_auth_name: if ssl_upstream, use this name with TLS\n \tauthentication.\n @param q: which query state to reactivate upon return.\n @param was_ratelimited: it will signal back if the query failed to pass the\n\tratelimit check.\n @return: false on failure (memory or socket related). no query was\n\tsent. Or returns an outbound entry with qsent and qstate set.\n\tThis outbound_entry will be used on later module invocations\n\tthat involve this query (timeout, error or reply)."]
    pub send_query: ::std::option::Option<
        unsafe extern "C" fn(
            qinfo: *mut query_info,
            flags: u16,
            dnssec: ::std::os::raw::c_int,
            want_dnssec: ::std::os::raw::c_int,
            nocaps: ::std::os::raw::c_int,
            check_ratelimit: ::std::os::raw::c_int,
            addr: *mut sockaddr_storage,
            addrlen: socklen_t,
            zone: *mut u8,
            zonelen: usize,
            tcp_upstream: ::std::os::raw::c_int,
            ssl_upstream: ::std::os::raw::c_int,
            tls_auth_name: *mut ::std::os::raw::c_char,
            q: *mut module_qstate,
            was_ratelimited: *mut ::std::os::raw::c_int,
        ) -> *mut outbound_entry,
    >,
    #[doc = " Detach-subqueries.\n Remove all sub-query references from this query state.\n Keeps super-references of those sub-queries correct.\n Updates stat items in mesh_area structure.\n @param qstate: used to find mesh state."]
    pub detach_subs: ::std::option::Option<unsafe extern "C" fn(qstate: *mut module_qstate)>,
    #[doc = " Attach subquery.\n Creates it if it does not exist already.\n Keeps sub and super references correct.\n Updates stat items in mesh_area structure.\n Pass if it is priming query or not.\n return:\n o if error (malloc) happened.\n o need to initialise the new state (module init; it is a new state).\n   so that the next run of the query with this module is successful.\n o no init needed, attachment successful.\n\n @param qstate: the state to find mesh state, and that wants to\n \treceive the results from the new subquery.\n @param qinfo: what to query for (copied).\n @param qflags: what flags to use (RD, CD flag or not).\n @param prime: if it is a (stub) priming query.\n @param valrec: validation lookup recursion, does not need validation\n @param newq: If the new subquery needs initialisation, it is\n \treturned, otherwise NULL is returned.\n @return: false on error, true if success (and init may be needed)."]
    pub attach_sub: ::std::option::Option<
        unsafe extern "C" fn(
            qstate: *mut module_qstate,
            qinfo: *mut query_info,
            qflags: u16,
            prime: ::std::os::raw::c_int,
            valrec: ::std::os::raw::c_int,
            newq: *mut *mut module_qstate,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Add detached query.\n Creates it if it does not exist already.\n Does not make super/sub references.\n Performs a cycle detection - for double check - and fails if there is\n \tone.\n Updates stat items in mesh_area structure.\n Pass if it is priming query or not.\n return:\n \to if error (malloc) happened.\n \to need to initialise the new state (module init; it is a new state).\n \t  so that the next run of the query with this module is successful.\n \to no init needed, attachment successful.\n \to added subquery, created if it did not exist already.\n\n @param qstate: the state to find mesh state, and that wants to receive\n \tthe results from the new subquery.\n @param qinfo: what to query for (copied).\n @param qflags: what flags to use (RD / CD flag or not).\n @param prime: if it is a (stub) priming query.\n @param valrec: if it is a validation recursion query (lookup of key, DS).\n @param newq: If the new subquery needs initialisation, it is returned,\n \totherwise NULL is returned.\n @param sub: The added mesh state, created if it did not exist already.\n @return: false on error, true if success (and init may be needed)."]
    pub add_sub: ::std::option::Option<
        unsafe extern "C" fn(
            qstate: *mut module_qstate,
            qinfo: *mut query_info,
            qflags: u16,
            prime: ::std::os::raw::c_int,
            valrec: ::std::os::raw::c_int,
            newq: *mut *mut module_qstate,
            sub: *mut *mut mesh_state,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Kill newly attached sub. If attach_sub returns newq for\n initialisation, but that fails, then this routine will cleanup and\n delete the freshly created sub.\n @param newq: the new subquery that is no longer needed.\n \tIt is removed."]
    pub kill_sub: ::std::option::Option<unsafe extern "C" fn(newq: *mut module_qstate)>,
    #[doc = " Detect if adding a dependency for qstate on name,type,class will\n create a dependency cycle.\n @param qstate: given mesh querystate.\n @param qinfo: query info for dependency.\n @param flags: query flags of dependency, RD/CD flags.\n @param prime: if dependency is a priming query or not.\n @param valrec: validation lookup recursion, does not need validation\n @return true if the name,type,class exists and the given\n \tqstate mesh exists as a dependency of that name. Thus\n \tif qstate becomes dependent on name,type,class then a\n \tcycle is created."]
    pub detect_cycle: ::std::option::Option<
        unsafe extern "C" fn(
            qstate: *mut module_qstate,
            qinfo: *mut query_info,
            flags: u16,
            prime: ::std::os::raw::c_int,
            valrec: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " region for temporary usage. May be cleared after operate() call."]
    pub scratch: *mut regional,
    #[doc = " buffer for temporary usage. May be cleared after operate() call."]
    pub scratch_buffer: *mut sldns_buffer,
    #[doc = " internal data for daemon - worker thread."]
    pub worker: *mut worker,
    #[doc = " the worker event base"]
    pub worker_base: *mut comm_base,
    #[doc = " the outside network"]
    pub outnet: *mut outside_network,
    #[doc = " mesh area with query state dependencies"]
    pub mesh: *mut mesh_area,
    #[doc = " allocation service"]
    pub alloc: *mut alloc_cache,
    #[doc = " random table to generate random numbers"]
    pub rnd: *mut ub_randstate,
    #[doc = " time in seconds, converted to integer"]
    pub now: *mut time_t,
    #[doc = " time in microseconds. Relatively recent."]
    pub now_tv: *mut timeval,
    #[doc = " is validation required for messages, controls client-facing\n validation status (AD bits) and servfails"]
    pub need_to_validate: ::std::os::raw::c_int,
    #[doc = " trusted key storage; these are the configured keys, if not NULL,\n otherwise configured by validator. These are the trust anchors,\n and are not primed and ready for validation, but on the bright\n side, they are read only memory, thus no locks and fast."]
    pub anchors: *mut val_anchors,
    #[doc = " negative cache, configured by the validator. if not NULL,\n contains NSEC record lookup trees."]
    pub neg_cache: *mut val_neg_cache,
    #[doc = " the 5011-probe timer (if any)"]
    pub probe_timer: *mut comm_timer,
    #[doc = " auth zones"]
    pub auth_zones: *mut auth_zones,
    #[doc = " Mapping of forwarding zones to targets.\n iterator forwarder information."]
    pub fwds: *mut iter_forwards,
    #[doc = " iterator stub information.\n The hints -- these aren't stored in the cache because they don't\n expire. The hints are always used to \"prime\" the cache. Note\n that both root hints and stub zone \"hints\" are stored in this\n data structure."]
    pub hints: *mut iter_hints,
    #[doc = " module specific data. indexed by module id."]
    pub modinfo: [*mut ::std::os::raw::c_void; 16usize],
    pub inplace_cb_lists: [*mut inplace_cb; 7usize],
    #[doc = " Shared array of known edns options (size MAX_KNOWN_EDNS_OPTS).\n Filled by edns literate modules during init."]
    pub edns_known_options: *mut edns_known_option,
    pub edns_known_options_num: usize,
    #[doc = " EDNS client string information"]
    pub edns_strings: *mut edns_strings,
    #[doc = " module stack"]
    pub modstack: *mut module_stack,
    #[doc = " the cachedb enabled value, copied and stored here."]
    pub cachedb_enabled: ::std::os::raw::c_int,
    pub unique_mesh: ::std::os::raw::c_int,
}
#[doc = " initial state - new query"]
pub const module_ext_state_module_state_initial: module_ext_state = 0;
#[doc = " waiting for reply to outgoing network query"]
pub const module_ext_state_module_wait_reply: module_ext_state = 1;
#[doc = " module is waiting for another module"]
pub const module_ext_state_module_wait_module: module_ext_state = 2;
#[doc = " module is waiting for another module; that other is restarted"]
pub const module_ext_state_module_restart_next: module_ext_state = 3;
#[doc = " module is waiting for sub-query"]
pub const module_ext_state_module_wait_subquery: module_ext_state = 4;
#[doc = " module could not finish the query"]
pub const module_ext_state_module_error: module_ext_state = 5;
#[doc = " module is finished with query"]
pub const module_ext_state_module_finished: module_ext_state = 6;
#[doc = " External visible states of the module state machine\n Modules may also have an internal state.\n Modules are supposed to run to completion or until blocked."]
pub type module_ext_state = ::std::os::raw::c_uint;
#[doc = " new query"]
pub const module_ev_module_event_new: module_ev = 0;
#[doc = " query passed by other module"]
pub const module_ev_module_event_pass: module_ev = 1;
#[doc = " reply inbound from server"]
pub const module_ev_module_event_reply: module_ev = 2;
#[doc = " no reply, timeout or other error"]
pub const module_ev_module_event_noreply: module_ev = 3;
#[doc = " reply is there, but capitalisation check failed"]
pub const module_ev_module_event_capsfail: module_ev = 4;
#[doc = " next module is done, and its reply is awaiting you"]
pub const module_ev_module_event_moddone: module_ev = 5;
#[doc = " error"]
pub const module_ev_module_event_error: module_ev = 6;
#[doc = " Events that happen to modules, that start or wakeup modules."]
pub type module_ev = ::std::os::raw::c_uint;
#[doc = " Linked list of sockaddrs\n May be allocated such that only 'len' bytes of addr exist for the structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_list {
    #[doc = " next in list"]
    pub next: *mut sock_list,
    #[doc = " length of addr"]
    pub len: socklen_t,
    #[doc = " sockaddr"]
    pub addr: sockaddr_storage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct respip_action_info {
    _unused: [u8; 0],
}
#[doc = " Struct to hold relevant data for serve expired"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serve_expired_data {
    pub timer: *mut comm_timer,
    pub get_cached_answer: serve_expired_lookup_func_type,
}
#[doc = " Module state, per query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_qstate {
    #[doc = " which query is being answered: name, type, class"]
    pub qinfo: query_info,
    #[doc = " flags uint16 from query"]
    pub query_flags: u16,
    #[doc = " if this is a (stub or root) priming query (with hints)"]
    pub is_priming: ::std::os::raw::c_int,
    #[doc = " if this is a validation recursion query that does not get\n validation itself"]
    pub is_valrec: ::std::os::raw::c_int,
    #[doc = " the client network address is needed for the client-subnet option\n  when prefetching, but we can't use reply_list in mesh_info, because\n  we don't want to send a reply for the internal query."]
    pub client_addr: sockaddr_storage,
    #[doc = " comm_reply contains server replies"]
    pub reply: *mut comm_reply,
    #[doc = " the reply message, with message for client and calling module"]
    pub return_msg: *mut dns_msg,
    #[doc = " the rcode, in case of error, instead of a reply message"]
    pub return_rcode: ::std::os::raw::c_int,
    #[doc = " origin of the reply (can be NULL from cache, list for cnames)"]
    pub reply_origin: *mut sock_list,
    #[doc = " IP blacklist for queries"]
    pub blacklist: *mut sock_list,
    #[doc = " region for this query. Cleared when query process finishes."]
    pub region: *mut regional,
    #[doc = " failure reason information if val-log-level is high"]
    pub errinf: *mut errinf_strlist,
    #[doc = " which module is executing"]
    pub curmod: ::std::os::raw::c_int,
    #[doc = " module states"]
    pub ext_state: [module_ext_state; 16usize],
    #[doc = " module specific data for query. indexed by module id."]
    pub minfo: [*mut ::std::os::raw::c_void; 16usize],
    #[doc = " environment for this query"]
    pub env: *mut module_env,
    #[doc = " mesh related information for this query"]
    pub mesh_info: *mut mesh_state,
    #[doc = " how many seconds before expiry is this prefetched (0 if not)"]
    pub prefetch_leeway: time_t,
    #[doc = " serve expired data"]
    pub serve_expired_data: *mut serve_expired_data,
    #[doc = " incoming edns options from the front end"]
    pub edns_opts_front_in: *mut edns_option,
    #[doc = " outgoing edns options to the back end"]
    pub edns_opts_back_out: *mut edns_option,
    #[doc = " incoming edns options from the back end"]
    pub edns_opts_back_in: *mut edns_option,
    #[doc = " outgoing edns options to the front end"]
    pub edns_opts_front_out: *mut edns_option,
    #[doc = " whether modules should answer from the cache"]
    pub no_cache_lookup: ::std::os::raw::c_int,
    #[doc = " whether modules should store answer in the cache"]
    pub no_cache_store: ::std::os::raw::c_int,
    #[doc = " whether to refetch a fresh answer on finishing this state"]
    pub need_refetch: ::std::os::raw::c_int,
    #[doc = " whether the query (or a subquery) was ratelimited"]
    pub was_ratelimited: ::std::os::raw::c_int,
    #[doc = " time when query was started. This is when the qstate is created.\n This is used so that type NS data cannot be overwritten by them\n expiring while the lookup is in progress, using data fetched from\n those servers. By comparing expiry time with qstarttime for type NS."]
    pub qstarttime: time_t,
    #[doc = " whether a message from cachedb will be used for the reply"]
    pub is_cachedb_answer: ::std::os::raw::c_int,
    #[doc = " Attributes of clients that share the qstate that may affect IP-based\n actions."]
    pub client_info: *mut respip_client_info,
    #[doc = " Extended result of response-ip action processing, mainly\n  for logging purposes."]
    pub respip_action_info: *mut respip_action_info,
    #[doc = " if the query is rpz passthru, no further rpz processing for it"]
    pub rpz_passthru: ::std::os::raw::c_int,
    pub tcp_required: ::std::os::raw::c_int,
    #[doc = " whether the reply should be dropped"]
    pub is_drop: ::std::os::raw::c_int,
}
#[doc = " Module functionality block"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_func_block {
    #[doc = " text string name of module"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Set up the module for start. This is called only once at startup.\n Privileged operations like opening device files may be done here.\n The function ptr can be NULL, if it is not used.\n @param env: module environment.\n @param id: module id number.\n return: 0 on error"]
    pub startup: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut module_env,
            id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Close down the module for stop. This is called only once before\n shutdown to free resources allocated during startup().\n Closing privileged ports or files must be done here.\n The function ptr can be NULL, if it is not used.\n @param env: module environment.\n @param id: module id number."]
    pub destartup: ::std::option::Option<
        unsafe extern "C" fn(env: *mut module_env, id: ::std::os::raw::c_int),
    >,
    #[doc = " Initialise the module. Called when restarting or reloading the\n daemon.\n This is the place to apply settings from the config file.\n @param env: module environment.\n @param id: module id number.\n return: 0 on error"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut module_env,
            id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Deinitialise the module, undo stuff done during init().\n Called before reloading the daemon.\n @param env: module environment.\n @param id: module id number."]
    pub deinit: ::std::option::Option<
        unsafe extern "C" fn(env: *mut module_env, id: ::std::os::raw::c_int),
    >,
    #[doc = " accept a new query, or work further on existing query.\n Changes the qstate->ext_state to be correct on exit.\n @param ev: event that causes the module state machine to\n\t(re-)activate.\n @param qstate: the query state.\n\tNote that this method is not allowed to change the\n\tquery state 'identity', that is query info, qflags,\n\tand priming status.\n\tAttach a subquery to get results to a different query.\n @param id: module id number that operate() is called on.\n @param outbound: if not NULL this event is due to the reply/timeout\n\tor error on this outbound query.\n @return: if at exit the ext_state is:\n\to wait_module: next module is started. (with pass event).\n\to error or finished: previous module is resumed.\n\to otherwise it waits until that event happens (assumes\n\t  the service routine to make subrequest or send message\n\t  have been called."]
    pub operate: ::std::option::Option<
        unsafe extern "C" fn(
            qstate: *mut module_qstate,
            event: module_ev,
            id: ::std::os::raw::c_int,
            outbound: *mut outbound_entry,
        ),
    >,
    #[doc = " inform super querystate about the results from this subquerystate.\n Is called when the querystate is finished.  The method invoked is\n the one from the current module active in the super querystate.\n @param qstate: the query state that is finished.\n\tExamine return_rcode and return_reply in the qstate.\n @param id: module id for this module.\n\tThis coincides with the current module for the super qstate.\n @param super: the super querystate that needs to be informed."]
    pub inform_super: ::std::option::Option<
        unsafe extern "C" fn(
            qstate: *mut module_qstate,
            id: ::std::os::raw::c_int,
            super_: *mut module_qstate,
        ),
    >,
    #[doc = " clear module specific data"]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(qstate: *mut module_qstate, id: ::std::os::raw::c_int),
    >,
    #[doc = " How much memory is the module specific data using.\n @param env: module environment.\n @param id: the module id.\n @return the number of bytes that are alloced."]
    pub get_mem: ::std::option::Option<
        unsafe extern "C" fn(env: *mut module_env, id: ::std::os::raw::c_int) -> usize,
    >,
}
extern "C" {
    #[doc = " Debug utility: module external qstate to string\n @param s: the state value.\n @return descriptive string."]
    pub fn strextstate(s: module_ext_state) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Debug utility: module event to string\n @param e: the module event value.\n @return descriptive string."]
    pub fn strmodulevent(e: module_ev) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Append text to the error info for validation.\n @param qstate: query state.\n @param str: copied into query region and appended.\n Failures to allocate are logged."]
    pub fn errinf(qstate: *mut module_qstate, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn errinf_ede(
        qstate: *mut module_qstate,
        str_: *const ::std::os::raw::c_char,
        reason_bogus: sldns_ede_code,
    );
}
extern "C" {
    #[doc = " Append text to error info:  from 1.2.3.4\n @param qstate: query state.\n @param origin: sock list with origin of trouble.\n  Every element added.\n  If NULL: nothing is added.\n  if 0len element: 'from cache' is added."]
    pub fn errinf_origin(qstate: *mut module_qstate, origin: *mut sock_list);
}
extern "C" {
    #[doc = " Append text to error info:  for RRset name type class\n @param qstate: query state.\n @param rr: rrset_key."]
    pub fn errinf_rrset(qstate: *mut module_qstate, rr: *mut ub_packed_rrset_key);
}
extern "C" {
    #[doc = " Append text to error info:  str dname\n @param qstate: query state.\n @param str: explanation string\n @param dname: the dname."]
    pub fn errinf_dname(
        qstate: *mut module_qstate,
        str_: *const ::std::os::raw::c_char,
        dname: *mut u8,
    );
}
extern "C" {
    #[doc = " Create error info in string.  For validation failures.\n @param qstate: query state.\n @param region: the region for the result or NULL for malloced result.\n @return string or NULL on malloc failure (already logged).\n    This string is malloced if region is NULL and has to be freed by caller."]
    pub fn errinf_to_str_bogus(
        qstate: *mut module_qstate,
        region: *mut regional,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Check the sldns_ede_code of the qstate->errinf.\n @param qstate: query state.\n @return the latest explicitly set sldns_ede_code or LDNS_EDE_NONE."]
    pub fn errinf_to_reason_bogus(qstate: *mut module_qstate) -> sldns_ede_code;
}
extern "C" {
    #[doc = " Create error info in string.  For other servfails.\n @param qstate: query state.\n @return string or NULL on malloc failure (already logged)."]
    pub fn errinf_to_str_servfail(qstate: *mut module_qstate) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create error info in string.  For misc failures that are not servfail.\n @param qstate: query state.\n @return string or NULL on malloc failure (already logged)."]
    pub fn errinf_to_str_misc(qstate: *mut module_qstate) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Initialize the edns known options by allocating the required space.\n @param env: the module environment.\n @return false on failure (no memory)."]
    pub fn edns_known_options_init(env: *mut module_env) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the allocated space for the known edns options.\n @param env: the module environment."]
    pub fn edns_known_options_delete(env: *mut module_env);
}
extern "C" {
    #[doc = " Register a known edns option. Overwrite the flags if it is already\n registered. Used before creating workers to register known edns options.\n @param opt_code: the edns option code.\n @param bypass_cache_stage: whether the option interacts with the cache.\n @param no_aggregation: whether the option implies more specific\n\taggregation.\n @param env: the module environment.\n @return true on success, false on failure (registering more options than\n\tallowed or trying to register after the environment is copied to the\n\tthreads.)"]
    pub fn edns_register_option(
        opt_code: u16,
        bypass_cache_stage: ::std::os::raw::c_int,
        no_aggregation: ::std::os::raw::c_int,
        env: *mut module_env,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register an inplace callback function.\n @param cb: pointer to the callback function.\n @param type: inplace callback type.\n @param cbarg: argument for the callback function, or NULL.\n @param env: the module environment.\n @param id: module id.\n @return true on success, false on failure (out of memory or trying to\n\tregister after the environment is copied to the threads.)"]
    pub fn inplace_cb_register(
        cb: *mut ::std::os::raw::c_void,
        type_: inplace_cb_list_type,
        cbarg: *mut ::std::os::raw::c_void,
        env: *mut module_env,
        id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete callback for specified type and module id.\n @param env: the module environment.\n @param type: inplace callback type.\n @param id: module id."]
    pub fn inplace_cb_delete(
        env: *mut module_env,
        type_: inplace_cb_list_type,
        id: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Delete all the inplace callback linked lists.\n @param env: the module environment."]
    pub fn inplace_cb_lists_delete(env: *mut module_env);
}
extern "C" {
    #[doc = " Check if an edns option is known.\n @param opt_code: the edns option code.\n @param env: the module environment.\n @return pointer to registered option if the edns option is known,\n\tNULL otherwise."]
    pub fn edns_option_is_known(opt_code: u16, env: *mut module_env) -> *mut edns_known_option;
}
extern "C" {
    #[doc = " Check if an edns option needs to bypass the reply from cache stage.\n @param list: the edns options.\n @param env: the module environment.\n @return true if an edns option needs to bypass the cache stage,\n\tfalse otherwise."]
    pub fn edns_bypass_cache_stage(
        list: *mut edns_option,
        env: *mut module_env,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if an unique mesh state is required. Might be triggered by EDNS option\n or set for the complete env.\n @param list: the edns options.\n @param env: the module environment.\n @return true if an edns option needs a unique mesh state,\n\tfalse otherwise."]
    pub fn unique_mesh_state(list: *mut edns_option, env: *mut module_env)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Log the known edns options.\n @param level: the desired verbosity level.\n @param env: the module environment."]
    pub fn log_edns_known_options(level: verbosity_value, env: *mut module_env);
}
extern "C" {
    #[doc = " Copy state that may have happened in the subquery and is always relevant to\n the super.\n @param qstate: query state that finished.\n @param id: module id.\n @param super: the qstate to inform."]
    pub fn copy_state_to_super(
        qstate: *mut module_qstate,
        id: ::std::os::raw::c_int,
        super_: *mut module_qstate,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_view {
    _unused: [u8; 0],
}
#[doc = " Views storage, shared."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct views {
    #[doc = " lock on the view tree"]
    pub lock: lock_rw_type,
    #[doc = " rbtree of struct view"]
    pub vtree: rbtree_type,
}
#[doc = " View. Named structure holding local authority zones."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct view {
    #[doc = " rbtree node, key is name"]
    pub node: rbnode_type,
    #[doc = " view name.\n Has to be right after rbnode_t due to pointer arithmetic in\n view_create's lock protect"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " view specific local authority zones"]
    pub local_zones: *mut local_zones,
    #[doc = " response-ip configuration data for this view"]
    pub respip_set: *mut respip_set,
    #[doc = " Fallback to global local_zones when there is no match in the view\n specific tree. 1 for yes, 0 for no"]
    pub isfirst: ::std::os::raw::c_int,
    #[doc = " lock on the data in the structure\n For the node and name you need to also hold the views_tree lock to\n change them."]
    pub lock: lock_rw_type,
}
extern "C" {
    #[doc = " Create views storage\n @return new struct or NULL on error."]
    pub fn views_create() -> *mut views;
}
extern "C" {
    #[doc = " Delete views storage\n @param v: views to delete."]
    pub fn views_delete(v: *mut views);
}
extern "C" {
    #[doc = " Apply config settings;\n Takes care of locking.\n @param v: view is set up.\n @param cfg: config data.\n @return false on error."]
    pub fn views_apply_cfg(v: *mut views, cfg: *mut config_file) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two view entries in rbtree. Sort canonical.\n @param v1: view 1\n @param v2: view 2\n @return: negative, positive or 0 comparison value."]
    pub fn view_cmp(
        v1: *const ::std::os::raw::c_void,
        v2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete one view\n @param v: view to delete."]
    pub fn view_delete(v: *mut view);
}
extern "C" {
    #[doc = " Debug helper. Print all views\n Takes care of locking.\n @param v: the views tree"]
    pub fn views_print(v: *mut views);
}
extern "C" {
    #[doc = " Find a view by name.\n @param vs: views\n @param name: name of the view we are looking for\n @param write: 1 for obtaining write lock on found view, 0 for read lock\n @return: locked view or NULL."]
    pub fn views_find_view(
        vs: *mut views,
        name: *const ::std::os::raw::c_char,
        write: ::std::os::raw::c_int,
    ) -> *mut view;
}
#[doc = " implementation of buffers to ease operations\n\n sldns_buffers can contain arbitrary information, per octet. You can write\n to the current end of a buffer, read from the current position, and\n access any data within it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sldns_buffer {
    #[doc = " The current position used for reading/writing"]
    pub _position: usize,
    #[doc = " The read/write limit"]
    pub _limit: usize,
    #[doc = " The amount of data the buffer can contain"]
    pub _capacity: usize,
    #[doc = " The data contained in the buffer"]
    pub _data: *mut u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl sldns_buffer {
    #[inline]
    pub fn _fixed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__fixed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _status_err(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__status_err(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _fixed: ::std::os::raw::c_uint,
        _status_err: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _fixed: u32 = unsafe { ::std::mem::transmute(_fixed) };
            _fixed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _status_err: u32 = unsafe { ::std::mem::transmute(_status_err) };
            _status_err as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " creates a new buffer with the specified capacity.\n\n \\param[in] capacity the size (in bytes) to allocate for the buffer\n \\return the created buffer"]
    pub fn sldns_buffer_new(capacity: usize) -> *mut sldns_buffer;
}
extern "C" {
    #[doc = " creates a buffer with the specified data.  The data IS copied\n and MEMORY allocations are done.  The buffer is not fixed and can\n be resized using buffer_reserve().\n\n \\param[in] buffer pointer to the buffer to put the data in\n \\param[in] data the data to encapsulate in the buffer\n \\param[in] size the size of the data"]
    pub fn sldns_buffer_new_frm_data(
        buffer: *mut sldns_buffer,
        data: *mut ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    #[doc = " Setup a buffer with the data pointed to. No data copied, no memory allocs.\n The buffer is fixed.\n \\param[in] buffer pointer to the buffer to put the data in\n \\param[in] data the data to encapsulate in the buffer\n \\param[in] size the size of the data"]
    pub fn sldns_buffer_init_frm_data(
        buffer: *mut sldns_buffer,
        data: *mut ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    #[doc = " changes the buffer's capacity.  The data is reallocated so any\n pointers to the data may become invalid.  The buffer's limit is set\n to the buffer's new capacity.\n \\param[in] buffer the buffer\n \\param[in] capacity the capacity to use\n \\return whether this failed or succeeded"]
    pub fn sldns_buffer_set_capacity(
        buffer: *mut sldns_buffer,
        capacity: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ensures BUFFER can contain at least AMOUNT more bytes.  The buffer's\n capacity is increased if necessary using buffer_set_capacity().\n\n The buffer's limit is always set to the (possibly increased)\n capacity.\n \\param[in] buffer the buffer\n \\param[in] amount amount to use\n \\return whether this failed or succeeded"]
    pub fn sldns_buffer_reserve(buffer: *mut sldns_buffer, amount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " prints to the buffer, increasing the capacity if required using\n buffer_reserve(). The buffer's position is set to the terminating '\\\\0'\n Returns the number of characters written (not including the\n terminating '\\\\0') or -1 on failure."]
    pub fn sldns_buffer_printf(
        buffer: *mut sldns_buffer,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " frees the buffer.\n \\param[in] *buffer the buffer to be freed"]
    pub fn sldns_buffer_free(buffer: *mut sldns_buffer);
}
extern "C" {
    #[doc = " Copy contents of the from buffer to the result buffer and then flips\n the result buffer. Data will be silently truncated if the result buffer is\n too small.\n \\param[out] *result resulting buffer which is copied to.\n \\param[in] *from what to copy to result."]
    pub fn sldns_buffer_copy(result: *mut sldns_buffer, from: *mut sldns_buffer);
}
#[doc = " Authoritative local zones storage, shared."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_zones {
    #[doc = " lock on the localzone tree"]
    pub lock: lock_rw_type,
    #[doc = " rbtree of struct local_zone"]
    pub ztree: rbtree_type,
}
#[doc = " A local data RRset"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_rrset {
    #[doc = " next in list"]
    pub next: *mut local_rrset,
    #[doc = " RRset data item"]
    pub rrset: *mut ub_packed_rrset_key,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serviced_query {
    _unused: [u8; 0],
}
#[doc = " The outbound list. This structure is part of the module specific query\n state."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct outbound_list {
    #[doc = " The linked list of outbound query entries."]
    pub first: *mut outbound_entry,
}
#[doc = " Outbound list entry. A serviced query sent by a module processing the\n query from the qstate. Double linked list to aid removal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct outbound_entry {
    #[doc = " next in list"]
    pub next: *mut outbound_entry,
    #[doc = " prev in list"]
    pub prev: *mut outbound_entry,
    #[doc = " The query that was sent out"]
    pub qsent: *mut serviced_query,
    #[doc = " the module query state that sent it"]
    pub qstate: *mut module_qstate,
}
extern "C" {
    #[doc = " Init the user allocated outbound list structure\n @param list: the list structure."]
    pub fn outbound_list_init(list: *mut outbound_list);
}
extern "C" {
    #[doc = " Clear the user owner outbound list structure.\n Deletes serviced queries.\n @param list: the list structure. It is cleared, but the list struct itself\n \tis callers responsibility to delete."]
    pub fn outbound_list_clear(list: *mut outbound_list);
}
extern "C" {
    #[doc = " Insert new entry into the list. Caller must allocate the entry with malloc.\n qstate and qsent are set by caller.\n @param list: the list to add to.\n @param e: entry to add, it is only half initialised at call start, fully\n\tinitialised at call end."]
    pub fn outbound_list_insert(list: *mut outbound_list, e: *mut outbound_entry);
}
extern "C" {
    #[doc = " Remove an entry from the list, and deletes it.\n Deletes serviced query in the entry.\n @param list: the list to remove from.\n @param e: the entry to remove."]
    pub fn outbound_list_remove(list: *mut outbound_list, e: *mut outbound_entry);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[doc = " shared infrastructure cache (edns, lameness)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct infra_cache {
    pub _address: u8,
}
#[doc = " the 5011-probe timer (if any)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comm_timer {
    pub _address: u8,
}
#[doc = " EDNS client string information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct edns_strings {
    pub _address: u8,
}

/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const CHROOT_DIR: &[u8; 13] = b"/etc/unbound\0";
pub const CLIENT_SUBNET: u32 = 1;
pub const CONFCMDLINE : & [u8 ; 914] = b"--disable-static --prefix=/nix/store/eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee-unbound-dynmod-bindings.rs --with-ssl=/nix/store/eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee-openssl-3.0.14-dev --with-libexpat=/nix/store/eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee-expat-2.6.2-dev --with-libevent=/nix/store/eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee-libevent-2.1.12-dev --localstatedir=/var --sysconfdir=/etc --sbindir=${out}/bin --with-rootkey-file=/nix/store/eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee-dns-root-data-2024-06-20/root.key --enable-pie --enable-relro-now --enable-systemd --with-pythonmodule --with-dynlibmodule --with-libnghttp2=/nix/store/eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee-nghttp2-1.62.1-dev --enable-subnet --enable-dnscrypt --with-libsodium=/nix/store/eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee-libsodium-full --enable-dnstap --enable-tfo-client --enable-tfo-server --enable-cachedb --with-libhiredis=/nix/store/eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee-hiredis-1.2.0\0" ;
pub const CONFIGFILE: &[u8; 26] = b"/etc/unbound/unbound.conf\0";
pub const DNSTAP_SOCKET_PATH: &[u8; 25] = b"/etc/unbound/dnstap.sock\0";
pub const HAVE_ACCEPT4: u32 = 1;
pub const HAVE_ARC4RANDOM: u32 = 1;
pub const HAVE_ARC4RANDOM_UNIFORM: u32 = 1;
pub const HAVE_ARPA_INET_H: u32 = 1;
pub const HAVE_ATTR_FORMAT: u32 = 1;
pub const HAVE_ATTR_NORETURN: u32 = 1;
pub const HAVE_ATTR_UNUSED: u32 = 1;
pub const HAVE_ATTR_WEAK: u32 = 1;
pub const HAVE_BE64TOH: u32 = 1;
pub const HAVE_BIO_SET_CALLBACK_EX: u32 = 1;
pub const HAVE_CHOWN: u32 = 1;
pub const HAVE_CHROOT: u32 = 1;
pub const HAVE_CTIME_R: u32 = 1;
pub const HAVE_DAEMON: u32 = 1;
pub const HAVE_DECL_EVSIGNAL_ASSIGN: u32 = 1;
pub const HAVE_DECL_INET_NTOP: u32 = 1;
pub const HAVE_DECL_INET_PTON: u32 = 1;
pub const HAVE_DECL_NGHTTP2_SESSION_SERVER_NEW: u32 = 1;
pub const HAVE_DECL_NID_ED25519: u32 = 1;
pub const HAVE_DECL_NID_ED448: u32 = 1;
pub const HAVE_DECL_NID_SECP384R1: u32 = 1;
pub const HAVE_DECL_NID_X9_62_PRIME256V1: u32 = 1;
pub const HAVE_DECL_REALLOCARRAY: u32 = 1;
pub const HAVE_DECL_REDISCONNECT: u32 = 1;
pub const HAVE_DECL_SK_SSL_COMP_POP_FREE: u32 = 1;
pub const HAVE_DECL_SSL_COMP_GET_COMPRESSION_METHODS: u32 = 1;
pub const HAVE_DECL_SSL_CTX_SET_ECDH_AUTO: u32 = 1;
pub const HAVE_DECL_XML_STOPPARSER: u32 = 1;
pub const HAVE_DLFCN_H: u32 = 1;
pub const HAVE_DSA_SIG_SET0: u32 = 1;
pub const HAVE_ENDIAN_H: u32 = 1;
pub const HAVE_ENDPROTOENT: u32 = 1;
pub const HAVE_ENDPWENT: u32 = 1;
pub const HAVE_ENDSERVENT: u32 = 1;
pub const HAVE_EVENT_ASSIGN: u32 = 1;
pub const HAVE_EVENT_BASE_FREE: u32 = 1;
pub const HAVE_EVENT_BASE_GET_METHOD: u32 = 1;
pub const HAVE_EVENT_BASE_NEW: u32 = 1;
pub const HAVE_EVENT_BASE_ONCE: u32 = 1;
pub const HAVE_EVENT_H: u32 = 1;
pub const HAVE_EVP_AES_256_CBC: u32 = 1;
pub const HAVE_EVP_DEFAULT_PROPERTIES_IS_FIPS_ENABLED: u32 = 1;
pub const HAVE_EVP_DIGESTVERIFY: u32 = 1;
pub const HAVE_EVP_ENCRYPTINIT_EX: u32 = 1;
pub const HAVE_EVP_MAC_CTX_SET_PARAMS: u32 = 1;
pub const HAVE_EVP_MD_CTX_NEW: u32 = 1;
pub const HAVE_EVP_SHA1: u32 = 1;
pub const HAVE_EVP_SHA256: u32 = 1;
pub const HAVE_EVP_SHA512: u32 = 1;
pub const HAVE_EXPAT_H: u32 = 1;
pub const HAVE_EXPLICIT_BZERO: u32 = 1;
pub const HAVE_FCNTL: u32 = 1;
pub const HAVE_FORK: u32 = 1;
pub const HAVE_FSEEKO: u32 = 1;
pub const HAVE_FSYNC: u32 = 1;
pub const HAVE_GETADDRINFO: u32 = 1;
pub const HAVE_GETIFADDRS: u32 = 1;
pub const HAVE_GETOPT_H: u32 = 1;
pub const HAVE_GETPWNAM: u32 = 1;
pub const HAVE_GETRLIMIT: u32 = 1;
pub const HAVE_GETTID: u32 = 1;
pub const HAVE_GLOB: u32 = 1;
pub const HAVE_GLOB_H: u32 = 1;
pub const HAVE_GMTIME_R: u32 = 1;
pub const HAVE_GRP_H: u32 = 1;
pub const HAVE_HIREDIS_HIREDIS_H: u32 = 1;
pub const HAVE_HMAC_INIT_EX: u32 = 1;
pub const HAVE_HTOBE64: u32 = 1;
pub const HAVE_IFADDRS_H: u32 = 1;
pub const HAVE_IF_NAMETOINDEX: u32 = 1;
pub const HAVE_INET_ATON: u32 = 1;
pub const HAVE_INET_NTOP: u32 = 1;
pub const HAVE_INET_PTON: u32 = 1;
pub const HAVE_INITGROUPS: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_ISBLANK: u32 = 1;
pub const HAVE_KILL: u32 = 1;
pub const HAVE_LINUX_NET_TSTAMP_H: u32 = 1;
pub const HAVE_LOCALTIME_R: u32 = 1;
pub const HAVE_MALLOC: u32 = 1;
pub const HAVE_MEMMOVE: u32 = 1;
pub const HAVE_NETDB_H: u32 = 1;
pub const HAVE_NETINET_IN_H: u32 = 1;
pub const HAVE_NETINET_TCP_H: u32 = 1;
pub const HAVE_NET_IF_H: u32 = 1;
pub const HAVE_NGHTTP2: u32 = 1;
pub const HAVE_NGHTTP2_NGHTTP2_H: u32 = 1;
pub const HAVE_OPENSSL_BN_H: u32 = 1;
pub const HAVE_OPENSSL_CONFIG: u32 = 1;
pub const HAVE_OPENSSL_CONF_H: u32 = 1;
pub const HAVE_OPENSSL_CORE_NAMES_H: u32 = 1;
pub const HAVE_OPENSSL_DH_H: u32 = 1;
pub const HAVE_OPENSSL_DSA_H: u32 = 1;
pub const HAVE_OPENSSL_ENGINE_H: u32 = 1;
pub const HAVE_OPENSSL_ERR_H: u32 = 1;
pub const HAVE_OPENSSL_INIT_CRYPTO: u32 = 1;
pub const HAVE_OPENSSL_INIT_SSL: u32 = 1;
pub const HAVE_OPENSSL_PARAM_BUILD_H: u32 = 1;
pub const HAVE_OPENSSL_RAND_H: u32 = 1;
pub const HAVE_OPENSSL_RSA_H: u32 = 1;
pub const HAVE_OPENSSL_SSL_H: u32 = 1;
pub const HAVE_OSSL_PARAM_BLD_NEW: u32 = 1;
pub const HAVE_POLL: u32 = 1;
pub const HAVE_POLL_H: u32 = 1;
pub const HAVE_PTHREAD: u32 = 1;
pub const HAVE_PTHREAD_PRIO_INHERIT: u32 = 1;
pub const HAVE_PTHREAD_RWLOCK_T: u32 = 1;
pub const HAVE_PTHREAD_SPINLOCK_T: u32 = 1;
pub const HAVE_PWD_H: u32 = 1;
pub const HAVE_PYTHON: u32 = 1;
pub const HAVE_RANDOM: u32 = 1;
pub const HAVE_REALLOCARRAY: u32 = 1;
pub const HAVE_RECVMSG: u32 = 1;
pub const HAVE_SENDMSG: u32 = 1;
pub const HAVE_SETRESGID: u32 = 1;
pub const HAVE_SETRESUID: u32 = 1;
pub const HAVE_SETRLIMIT: u32 = 1;
pub const HAVE_SETSID: u32 = 1;
pub const HAVE_SHMGET: u32 = 1;
pub const HAVE_SIGPROCMASK: u32 = 1;
pub const HAVE_SLEEP: u32 = 1;
pub const HAVE_SNPRINTF: u32 = 1;
pub const HAVE_SOCKETPAIR: u32 = 1;
pub const HAVE_SRANDOM: u32 = 1;
pub const HAVE_SSL_CTX_SET_ALPN_PROTOS: u32 = 1;
pub const HAVE_SSL_CTX_SET_ALPN_SELECT_CB: u32 = 1;
pub const HAVE_SSL_CTX_SET_CIPHERSUITES: u32 = 1;
pub const HAVE_SSL_CTX_SET_SECURITY_LEVEL: u32 = 1;
pub const HAVE_SSL_CTX_SET_TLSEXT_TICKET_KEY_EVP_CB: u32 = 1;
pub const HAVE_SSL_GET0_ALPN_SELECTED: u32 = 1;
pub const HAVE_SSL_GET0_PEERNAME: u32 = 1;
pub const HAVE_SSL_GET1_PEER_CERTIFICATE: u32 = 1;
pub const HAVE_SSL_SET1_HOST: u32 = 1;
pub const HAVE_STDARG_H: u32 = 1;
pub const HAVE_STDBOOL_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDIO_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRFTIME: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_STRLCAT: u32 = 1;
pub const HAVE_STRLCPY: u32 = 1;
pub const HAVE_STRPTIME: u32 = 1;
pub const HAVE_STRSEP: u32 = 1;
pub const HAVE_STRUCT_IN_PKTINFO_IPI_SPEC_DST: u32 = 1;
pub const HAVE_SWIG: u32 = 1;
pub const HAVE_SYSLOG_H: u32 = 1;
pub const HAVE_SYSTEMD: u32 = 1;
pub const HAVE_SYS_IPC_H: u32 = 1;
pub const HAVE_SYS_PARAM_H: u32 = 1;
pub const HAVE_SYS_RESOURCE_H: u32 = 1;
pub const HAVE_SYS_SELECT_H: u32 = 1;
pub const HAVE_SYS_SHM_H: u32 = 1;
pub const HAVE_SYS_SOCKET_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_SYS_UIO_H: u32 = 1;
pub const HAVE_SYS_UN_H: u32 = 1;
pub const HAVE_SYS_WAIT_H: u32 = 1;
pub const HAVE_TIME_H: u32 = 1;
pub const HAVE_TZSET: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const HAVE_USLEEP: u32 = 1;
pub const HAVE_VFORK: u32 = 1;
pub const HAVE_WCHAR_H: u32 = 1;
pub const HAVE_WORKING_FORK: u32 = 1;
pub const HAVE_WORKING_VFORK: u32 = 1;
pub const HAVE_WRITEV: u32 = 1;
pub const HAVE_X509_VERIFY_PARAM_SET1_HOST: u32 = 1;
pub const LT_OBJDIR: &[u8; 7] = b".libs/\0";
pub const MAXSYSLOGMSGLEN: u32 = 10240;
pub const OMITTED__D_GNU_SOURCE: u32 = 1;
pub const PACKAGE_BUGREPORT: &[u8; 73] =
    b"unbound-bugs@nlnetlabs.nl or https://github.com/NLnetLabs/unbound/issues\0";
pub const PACKAGE_NAME: &[u8; 8] = b"unbound\0";
pub const PACKAGE_STRING: &[u8; 15] = b"unbound 1.20.0\0";
pub const PACKAGE_TARNAME: &[u8; 8] = b"unbound\0";
pub const PACKAGE_URL: &[u8; 1] = b"\0";
pub const PACKAGE_VERSION: &[u8; 7] = b"1.20.0\0";
pub const PIDFILE: &[u8; 25] = b"/etc/unbound/unbound.pid\0";
pub const REUSEPORT_DEFAULT: u32 = 1;
pub const ROOT_ANCHOR_FILE: &[u8; 78] =
    b"/nix/store/w4lmaygwg4yw2hpjg40703s112kh92x2-dns-root-data-2024-06-20/root.key\0";
pub const ROOT_CERT_FILE: &[u8; 29] = b"/etc/unbound/icannbundle.pem\0";
pub const RUN_DIR: &[u8; 13] = b"/etc/unbound\0";
pub const SHARE_DIR: &[u8; 13] = b"/etc/unbound\0";
pub const SIZEOF_PTHREAD_T: u32 = 8;
pub const SIZEOF_SIZE_T: u32 = 8;
pub const SIZEOF_TIME_T: u32 = 8;
pub const SIZEOF_UNSIGNED_LONG: u32 = 8;
pub const SODIUM_MISUSE_HANDLER: u32 = 1;
pub const STDC_HEADERS: u32 = 1;
pub const STRPTIME_WORKS: u32 = 1;
pub const UB_USERNAME: &[u8; 8] = b"unbound\0";
pub const USE_CACHEDB: u32 = 1;
pub const USE_DNSCRYPT: u32 = 1;
pub const USE_DNSCRYPT_XCHACHA20: u32 = 1;
pub const USE_DNSTAP: u32 = 1;
pub const USE_ECDSA: u32 = 1;
pub const USE_ED25519: u32 = 1;
pub const USE_ED448: u32 = 1;
pub const USE_LIBEVENT: u32 = 1;
pub const USE_MSG_FASTOPEN: u32 = 1;
pub const USE_REDIS: u32 = 1;
pub const USE_SHA1: u32 = 1;
pub const USE_SHA2: u32 = 1;
pub const _ALL_SOURCE: u32 = 1;
pub const _DARWIN_C_SOURCE: u32 = 1;
pub const __EXTENSIONS__: u32 = 1;
pub const _GNU_SOURCE: u32 = 1;
pub const _HPUX_ALT_XOPEN_SOCKET_API: u32 = 1;
pub const _NETBSD_SOURCE: u32 = 1;
pub const _OPENBSD_SOURCE: u32 = 1;
pub const _POSIX_PTHREAD_SEMANTICS: u32 = 1;
pub const __STDC_WANT_IEC_60559_ATTRIBS_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_BFP_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_DFP_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_FUNCS_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_TYPES_EXT__: u32 = 1;
pub const __STDC_WANT_LIB_EXT2__: u32 = 1;
pub const __STDC_WANT_MATH_SPEC_FUNCS__: u32 = 1;
pub const _TANDEM_SOURCE: u32 = 1;
pub const USE_TCP_FASTOPEN: u32 = 1;
pub const WINVER: u32 = 1282;
pub const WITH_DYNLIBMODULE: u32 = 1;
pub const WITH_PYTHONMODULE: u32 = 1;
pub const USE_SLDNS: u32 = 1;
pub const LDNS_BUILD_CONFIG_HAVE_SSL: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_DYNAMIC_STACK_SIZE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 1;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _PRINTF_NAN_LEN_MAX: u32 = 4;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const CLOSE_RANGE_UNSHARE: u32 = 2;
pub const CLOSE_RANGE_CLOEXEC: u32 = 4;
pub const _ASSERT_H: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const __error_t_defined: u32 = 1;
pub const _SYS_PARAM_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const CHAR_WIDTH: u32 = 8;
pub const SCHAR_WIDTH: u32 = 8;
pub const UCHAR_WIDTH: u32 = 8;
pub const SHRT_WIDTH: u32 = 16;
pub const USHRT_WIDTH: u32 = 16;
pub const INT_WIDTH: u32 = 32;
pub const UINT_WIDTH: u32 = 32;
pub const LONG_WIDTH: u32 = 64;
pub const ULONG_WIDTH: u32 = 64;
pub const LLONG_WIDTH: u32 = 64;
pub const ULLONG_WIDTH: u32 = 64;
pub const BOOL_MAX: u32 = 1;
pub const BOOL_WIDTH: u32 = 1;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_FD_SETSIZE: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const __SC_THREAD_STACK_MIN_VALUE: u32 = 75;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const IOV_MAX: u32 = 1024;
pub const NL_ARGMAX: u32 = 4096;
pub const NL_LANGMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const WORD_BIT: u32 = 32;
pub const LONG_BIT: u32 = 64;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_ARCH_H: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const HZ: u32 = 100;
pub const EXEC_PAGESIZE: u32 = 4096;
pub const NOGROUP: i32 = -1;
pub const MAXHOSTNAMELEN: u32 = 64;
pub const MAXSYMLINKS: u32 = 20;
pub const NOFILE: u32 = 256;
pub const NCARGS: u32 = 131072;
pub const NGROUPS: u32 = 65536;
pub const CANBSIZ: u32 = 255;
pub const MAXPATHLEN: u32 = 4096;
pub const DEV_BSIZE: u32 = 512;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOL_MPTCP: u32 = 284;
pub const SOL_MCTP: u32 = 285;
pub const SOL_SMC: u32 = 286;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const __BITS_PER_LONG_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_RESERVE_MEM: u32 = 73;
pub const SO_TXREHASH: u32 = 74;
pub const SO_RCVMARK: u32 = 75;
pub const SO_PASSPIDFD: u32 = 76;
pub const SO_PEERPIDFD: u32 = 77;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const _SYS_UIO_H: u32 = 1;
pub const UIO_MAXIOV: u32 = 1024;
pub const _BITS_UIO_EXT_H: u32 = 1;
pub const RWF_HIPRI: u32 = 1;
pub const RWF_DSYNC: u32 = 2;
pub const RWF_SYNC: u32 = 4;
pub const RWF_NOWAIT: u32 = 8;
pub const RWF_APPEND: u32 = 16;
pub const _NETINET_IN_H: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_RECVERR_RFC4884: u32 = 26;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const IP_LOCAL_PORT_RANGE: u32 = 51;
pub const IP_PROTOCOL: u32 = 52;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_RECVERR_RFC4884: u32 = 31;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _NETINET_TCP_H: u32 = 1;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_MAXSEG: u32 = 2;
pub const TCP_CORK: u32 = 3;
pub const TCP_KEEPIDLE: u32 = 4;
pub const TCP_KEEPINTVL: u32 = 5;
pub const TCP_KEEPCNT: u32 = 6;
pub const TCP_SYNCNT: u32 = 7;
pub const TCP_LINGER2: u32 = 8;
pub const TCP_DEFER_ACCEPT: u32 = 9;
pub const TCP_WINDOW_CLAMP: u32 = 10;
pub const TCP_INFO: u32 = 11;
pub const TCP_QUICKACK: u32 = 12;
pub const TCP_CONGESTION: u32 = 13;
pub const TCP_MD5SIG: u32 = 14;
pub const TCP_COOKIE_TRANSACTIONS: u32 = 15;
pub const TCP_THIN_LINEAR_TIMEOUTS: u32 = 16;
pub const TCP_THIN_DUPACK: u32 = 17;
pub const TCP_USER_TIMEOUT: u32 = 18;
pub const TCP_REPAIR: u32 = 19;
pub const TCP_REPAIR_QUEUE: u32 = 20;
pub const TCP_QUEUE_SEQ: u32 = 21;
pub const TCP_REPAIR_OPTIONS: u32 = 22;
pub const TCP_FASTOPEN: u32 = 23;
pub const TCP_TIMESTAMP: u32 = 24;
pub const TCP_NOTSENT_LOWAT: u32 = 25;
pub const TCP_CC_INFO: u32 = 26;
pub const TCP_SAVE_SYN: u32 = 27;
pub const TCP_SAVED_SYN: u32 = 28;
pub const TCP_REPAIR_WINDOW: u32 = 29;
pub const TCP_FASTOPEN_CONNECT: u32 = 30;
pub const TCP_ULP: u32 = 31;
pub const TCP_MD5SIG_EXT: u32 = 32;
pub const TCP_FASTOPEN_KEY: u32 = 33;
pub const TCP_FASTOPEN_NO_COOKIE: u32 = 34;
pub const TCP_ZEROCOPY_RECEIVE: u32 = 35;
pub const TCP_INQ: u32 = 36;
pub const TCP_CM_INQ: u32 = 36;
pub const TCP_TX_DELAY: u32 = 37;
pub const TCP_REPAIR_ON: u32 = 1;
pub const TCP_REPAIR_OFF: u32 = 0;
pub const TCP_REPAIR_OFF_NO_WP: i32 = -1;
pub const TH_FIN: u32 = 1;
pub const TH_SYN: u32 = 2;
pub const TH_RST: u32 = 4;
pub const TH_PUSH: u32 = 8;
pub const TH_ACK: u32 = 16;
pub const TH_URG: u32 = 32;
pub const TCPOPT_EOL: u32 = 0;
pub const TCPOPT_NOP: u32 = 1;
pub const TCPOPT_MAXSEG: u32 = 2;
pub const TCPOLEN_MAXSEG: u32 = 4;
pub const TCPOPT_WINDOW: u32 = 3;
pub const TCPOLEN_WINDOW: u32 = 3;
pub const TCPOPT_SACK_PERMITTED: u32 = 4;
pub const TCPOLEN_SACK_PERMITTED: u32 = 2;
pub const TCPOPT_SACK: u32 = 5;
pub const TCPOPT_TIMESTAMP: u32 = 8;
pub const TCPOLEN_TIMESTAMP: u32 = 10;
pub const TCPOLEN_TSTAMP_APPA: u32 = 12;
pub const TCPOPT_TSTAMP_HDR: u32 = 16844810;
pub const TCP_MSS: u32 = 512;
pub const TCP_MAXWIN: u32 = 65535;
pub const TCP_MAX_WINSHIFT: u32 = 14;
pub const SOL_TCP: u32 = 6;
pub const TCPI_OPT_TIMESTAMPS: u32 = 1;
pub const TCPI_OPT_SACK: u32 = 2;
pub const TCPI_OPT_WSCALE: u32 = 4;
pub const TCPI_OPT_ECN: u32 = 8;
pub const TCPI_OPT_ECN_SEEN: u32 = 16;
pub const TCPI_OPT_SYN_DATA: u32 = 32;
pub const TCP_MD5SIG_MAXKEYLEN: u32 = 80;
pub const TCP_MD5SIG_FLAG_PREFIX: u32 = 1;
pub const TCP_MD5SIG_FLAG_IFINDEX: u32 = 2;
pub const TCP_COOKIE_MIN: u32 = 8;
pub const TCP_COOKIE_MAX: u32 = 16;
pub const TCP_COOKIE_PAIR_SIZE: u32 = 32;
pub const TCP_COOKIE_IN_ALWAYS: u32 = 1;
pub const TCP_COOKIE_OUT_NEVER: u32 = 2;
pub const TCP_S_DATA_IN: u32 = 4;
pub const TCP_S_DATA_OUT: u32 = 8;
pub const TCP_MSS_DEFAULT: u32 = 536;
pub const TCP_MSS_DESIRED: u32 = 1220;
pub const _ARPA_INET_H: u32 = 1;
pub const ARG_LL: &[u8; 4] = b"%ll\0";
pub const IPV6_MIN_MTU: u32 = 1280;
pub const UNBOUND_DNS_PORT: u32 = 53;
pub const UNBOUND_DNS_OVER_TLS_PORT: u32 = 853;
pub const UNBOUND_DNS_OVER_HTTPS_PORT: u32 = 443;
pub const UNBOUND_CONTROL_PORT: u32 = 8953;
pub const UNBOUND_CONTROL_VERSION: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_ISO: u32 = 4;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const CLONE_NEWTIME: u32 = 128;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const _BITS_TIMEX_H: u32 = 1;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 32769;
pub const ADJ_OFFSET_SS_READ: u32 = 40961;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_CLKB: u32 = 16384;
pub const MOD_CLKA: u32 = 32769;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const PTHREAD_ATTR_NO_SIGMASK_NP: i32 = -1;
pub const PTHREADSTACKSIZE: u32 = 2097152;
pub const HASH_DEFAULT_STARTARRAY: u32 = 1024;
pub const HASH_DEFAULT_MAXMEM: u32 = 4194304;
pub const PACKED_RRSET_NSEC_AT_APEX: u32 = 1;
pub const PACKED_RRSET_PARENT_SIDE: u32 = 2;
pub const PACKED_RRSET_SOA_NEG: u32 = 4;
pub const PACKED_RRSET_FIXEDTTL: u32 = 2147483648;
pub const PACKED_RRSET_RPZ: u32 = 8;
pub const RR_COUNT_MAX: u32 = 16777215;
pub const LDNS_MAX_LABELLEN: u32 = 63;
pub const LDNS_MAX_DOMAINLEN: u32 = 255;
pub const LDNS_MAX_POINTERS: u32 = 65535;
pub const LDNS_RR_OVERHEAD: u32 = 10;
pub const LDNS_DNSSEC_KEYPROTO: u32 = 3;
pub const LDNS_KEY_ZONE_KEY: u32 = 256;
pub const LDNS_KEY_SEP_KEY: u32 = 1;
pub const LDNS_KEY_REVOKE_KEY: u32 = 128;
pub const LDNS_RDATA_FIELD_DESCRIPTORS_COMMON: u32 = 259;
pub const LDNS_MAX_RDFLEN: u32 = 65535;
pub const LDNS_RDF_SIZE_BYTE: u32 = 1;
pub const LDNS_RDF_SIZE_WORD: u32 = 2;
pub const LDNS_RDF_SIZE_DOUBLEWORD: u32 = 4;
pub const LDNS_RDF_SIZE_6BYTES: u32 = 6;
pub const LDNS_RDF_SIZE_8BYTES: u32 = 8;
pub const LDNS_RDF_SIZE_16BYTES: u32 = 16;
pub const LDNS_NSEC3_VARS_OPTOUT_MASK: u32 = 1;
pub const LDNS_APL_IP4: u32 = 1;
pub const LDNS_APL_IP6: u32 = 2;
pub const LDNS_APL_MASK: u32 = 127;
pub const LDNS_APL_NEGATION: u32 = 128;
pub const LDNS_EDNS_MASK_DO_BIT: u32 = 32768;
pub const LDNS_TSIG_ERROR_NOERROR: u32 = 0;
pub const LDNS_TSIG_ERROR_BADSIG: u32 = 16;
pub const LDNS_TSIG_ERROR_BADKEY: u32 = 17;
pub const LDNS_TSIG_ERROR_BADTIME: u32 = 18;
pub const LDNS_TSIG_ERROR_BADMODE: u32 = 19;
pub const LDNS_TSIG_ERROR_BADNAME: u32 = 20;
pub const LDNS_TSIG_ERROR_BADALG: u32 = 21;
pub const LDNS_EXT_RCODE_BADCOOKIE: u32 = 23;
pub const DNSCACHE_STORE_ZEROTTL: u32 = 1048576;
pub const LDNS_HEADER_SIZE: u32 = 12;
pub const LDNS_RD_MASK: u32 = 1;
pub const LDNS_RD_SHIFT: u32 = 0;
pub const LDNS_TC_MASK: u32 = 2;
pub const LDNS_TC_SHIFT: u32 = 1;
pub const LDNS_AA_MASK: u32 = 4;
pub const LDNS_AA_SHIFT: u32 = 2;
pub const LDNS_OPCODE_MASK: u32 = 120;
pub const LDNS_OPCODE_SHIFT: u32 = 3;
pub const LDNS_QR_MASK: u32 = 128;
pub const LDNS_QR_SHIFT: u32 = 7;
pub const LDNS_RCODE_MASK: u32 = 15;
pub const LDNS_RCODE_SHIFT: u32 = 0;
pub const LDNS_CD_MASK: u32 = 16;
pub const LDNS_CD_SHIFT: u32 = 4;
pub const LDNS_AD_MASK: u32 = 32;
pub const LDNS_AD_SHIFT: u32 = 5;
pub const LDNS_Z_MASK: u32 = 64;
pub const LDNS_Z_SHIFT: u32 = 6;
pub const LDNS_RA_MASK: u32 = 128;
pub const LDNS_RA_SHIFT: u32 = 7;
pub const LDNS_QDCOUNT_OFF: u32 = 4;
pub const LDNS_ANCOUNT_OFF: u32 = 6;
pub const LDNS_NSCOUNT_OFF: u32 = 8;
pub const LDNS_ARCOUNT_OFF: u32 = 10;
pub const PARSE_TABLE_SIZE: u32 = 32;
pub const NORR_TTL: u32 = 5;
pub const EDNS_RCODE_BADVERS: u32 = 16;
pub const PTR_MAX_OFFSET: u32 = 16383;
pub const MAX_MODULE: u32 = 16;
pub const MAX_KNOWN_EDNS_OPTS: u32 = 256;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type fpos_t = __fpos_t;
pub type fpos64_t = __fpos64_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat2(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc23_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgets_unlocked(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fputs_unlocked(
        __s: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(
        __stream: *mut FILE,
        __off: __off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obstack_printf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obstack_vprintf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        __args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rawmemchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerrordesc_np(__err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerrorname_np(__err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sigabbrev_np(__sig: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sigdescr_np(__sig: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strverscmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfry(__string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn basename(__filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub type gid_t = __gid_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type pid_t = __pid_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn euidaccess(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eaccess(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execveat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn lseek64(
        __fd: ::std::os::raw::c_int,
        __offset: __off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pread64(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite64(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe2(
        __pipedes: *mut ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_current_dir_name() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup3(
        __fd: ::std::os::raw::c_int,
        __fd2: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvpe(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_1 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_1 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_1 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_1 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_1 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_1 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_1 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_1 = 7;
pub const _PC_VDISABLE: _bindgen_ty_1 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_1 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_1 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_1 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_1 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_1 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_1 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_1 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_1 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_1 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_1 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_1 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_1 = 20;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_2 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_2 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_2 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_2 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_2 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_2 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_2 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_2 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_2 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_2 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_2 = 10;
pub const _SC_TIMERS: _bindgen_ty_2 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_2 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_2 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_2 = 14;
pub const _SC_FSYNC: _bindgen_ty_2 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_2 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_2 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_2 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_2 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_2 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_2 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_2 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_2 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_2 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_2 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_2 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_2 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_2 = 28;
pub const _SC_VERSION: _bindgen_ty_2 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_2 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_2 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_2 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_2 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_2 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_2 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_2 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_2 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_2 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_2 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_2 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_2 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_2 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_2 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_2 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_2 = 45;
pub const _SC_2_VERSION: _bindgen_ty_2 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_2 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_2 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_2 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_2 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_2 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_2 = 52;
pub const _SC_PII: _bindgen_ty_2 = 53;
pub const _SC_PII_XTI: _bindgen_ty_2 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_2 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_2 = 56;
pub const _SC_PII_OSI: _bindgen_ty_2 = 57;
pub const _SC_POLL: _bindgen_ty_2 = 58;
pub const _SC_SELECT: _bindgen_ty_2 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_2 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_2 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_2 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_2 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_2 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_2 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_2 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_2 = 66;
pub const _SC_THREADS: _bindgen_ty_2 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_2 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_2 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_2 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_2 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_2 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_2 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_2 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_2 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_2 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_2 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_2 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_2 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_2 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_2 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_2 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_2 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_2 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_2 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_2 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_2 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_2 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_2 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_2 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_2 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_2 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_2 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_2 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_2 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_2 = 96;
pub const _SC_2_UPE: _bindgen_ty_2 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_2 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_2 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_2 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_2 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_2 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_2 = 103;
pub const _SC_INT_MAX: _bindgen_ty_2 = 104;
pub const _SC_INT_MIN: _bindgen_ty_2 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_2 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_2 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_2 = 108;
pub const _SC_NZERO: _bindgen_ty_2 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_2 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_2 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_2 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_2 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_2 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_2 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_2 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_2 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_2 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_2 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_2 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_2 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_2 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_2 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_2 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_2 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_2 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_2 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_2 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_2 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_2 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_2 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_2 = 132;
pub const _SC_BARRIERS: _bindgen_ty_2 = 133;
pub const _SC_BASE: _bindgen_ty_2 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_2 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_2 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_2 = 137;
pub const _SC_CPUTIME: _bindgen_ty_2 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_2 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_2 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_2 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_2 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_2 = 143;
pub const _SC_FIFO: _bindgen_ty_2 = 144;
pub const _SC_PIPE: _bindgen_ty_2 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_2 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_2 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_2 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_2 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_2 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_2 = 151;
pub const _SC_NETWORKING: _bindgen_ty_2 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_2 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_2 = 154;
pub const _SC_REGEXP: _bindgen_ty_2 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_2 = 156;
pub const _SC_SHELL: _bindgen_ty_2 = 157;
pub const _SC_SIGNALS: _bindgen_ty_2 = 158;
pub const _SC_SPAWN: _bindgen_ty_2 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_2 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_2 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_2 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_2 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_2 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_2 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_2 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_2 = 167;
pub const _SC_2_PBS: _bindgen_ty_2 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_2 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_2 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_2 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_2 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_2 = 173;
pub const _SC_STREAMS: _bindgen_ty_2 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_2 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_2 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_2 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_2 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_2 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_2 = 180;
pub const _SC_TRACE: _bindgen_ty_2 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_2 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_2 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_2 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_2 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_2 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_2 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_2 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_2 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_2 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_2 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_2 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_2 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_2 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_2 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_2 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_2 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_2 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_2 = 199;
pub const _SC_IPV6: _bindgen_ty_2 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_2 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_2 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_2 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_2 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_2 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_2 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_2 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_2 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_2 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_2 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_2 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_2 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_2 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_2 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_2 = 250;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_3 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_3 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_3 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_3 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_3 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_3 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_3 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_3 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_3 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_3 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_3 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_3 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_3 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_3 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_3 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_3 = 1149;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn group_member(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getresuid(
        __ruid: *mut __uid_t,
        __euid: *mut __uid_t,
        __suid: *mut __uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getresgid(
        __rgid: *mut __gid_t,
        __egid: *mut __gid_t,
        __sgid: *mut __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setresuid(__ruid: __uid_t, __euid: __uid_t, __suid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setresgid(__rgid: __gid_t, __egid: __gid_t, __sgid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Fork() -> __pid_t;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syncfs(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate64(
        __file: *const ::std::os::raw::c_char,
        __length: __off64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate64(__fd: ::std::os::raw::c_int, __length: __off64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf64(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copy_file_range(
        __infd: ::std::os::raw::c_int,
        __pinoff: *mut __off64_t,
        __outfd: ::std::os::raw::c_int,
        __poutoff: *mut __off64_t,
        __length: usize,
        __flags: ::std::os::raw::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        __from: *const ::std::os::raw::c_void,
        __to: *mut ::std::os::raw::c_void,
        __n: isize,
    );
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn close_range(
        __fd: ::std::os::raw::c_uint,
        __max_fd: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettid() -> __pid_t;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtof32(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32;
}
extern "C" {
    pub fn strtof64(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64;
}
extern "C" {
    pub fn strtof32x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32x;
}
extern "C" {
    pub fn strtof64x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64x;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_strtol"]
    pub fn strtol1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_strtoul"]
    pub fn strtoul1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_strtoll"]
    pub fn strtoq1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_strtoull"]
    pub fn strtouq1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strfromd(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfroml(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: u128,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf32(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf64(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf32x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32x,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf64x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64x,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtol_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoll_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_strtol_l"]
    pub fn strtol_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_strtoul_l"]
    pub fn strtoul_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_strtoll_l"]
    pub fn strtoll_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}__isoc23_strtoull_l"]
    pub fn strtoull_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtod_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtof_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtold_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> u128;
}
extern "C" {
    pub fn strtof32_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32;
}
extern "C" {
    pub fn strtof64_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64;
}
extern "C" {
    pub fn strtof32x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32x;
}
extern "C" {
    pub fn strtof64x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64x;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn secure_getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalize_file_name(
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_d_fn_t,
        __arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_openpt(__oflag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub static mut program_invocation_name: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut program_invocation_short_name: *mut ::std::os::raw::c_char;
}
pub type error_t = ::std::os::raw::c_int;
extern "C" {
    pub fn __sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_tid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_tid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_overrun) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_overrun)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_sigval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_sigval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_utime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_stime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lower) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._upper) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._addr_bnd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr_lsb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_lsb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bounds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_bounds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_fd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_7> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._call_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._syscall) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._arch) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._kill) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._timer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._rt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigchld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigfault) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigpoll) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigsys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sifields) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(_sifields)
        )
    );
}
pub const SI_ASYNCNL: _bindgen_ty_4 = -60;
pub const SI_DETHREAD: _bindgen_ty_4 = -7;
pub const SI_TKILL: _bindgen_ty_4 = -6;
pub const SI_SIGIO: _bindgen_ty_4 = -5;
pub const SI_ASYNCIO: _bindgen_ty_4 = -4;
pub const SI_MESGQ: _bindgen_ty_4 = -3;
pub const SI_TIMER: _bindgen_ty_4 = -2;
pub const SI_QUEUE: _bindgen_ty_4 = -1;
pub const SI_USER: _bindgen_ty_4 = 0;
pub const SI_KERNEL: _bindgen_ty_4 = 128;
pub type _bindgen_ty_4 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: _bindgen_ty_5 = 1;
pub const ILL_ILLOPN: _bindgen_ty_5 = 2;
pub const ILL_ILLADR: _bindgen_ty_5 = 3;
pub const ILL_ILLTRP: _bindgen_ty_5 = 4;
pub const ILL_PRVOPC: _bindgen_ty_5 = 5;
pub const ILL_PRVREG: _bindgen_ty_5 = 6;
pub const ILL_COPROC: _bindgen_ty_5 = 7;
pub const ILL_BADSTK: _bindgen_ty_5 = 8;
pub const ILL_BADIADDR: _bindgen_ty_5 = 9;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: _bindgen_ty_6 = 1;
pub const FPE_INTOVF: _bindgen_ty_6 = 2;
pub const FPE_FLTDIV: _bindgen_ty_6 = 3;
pub const FPE_FLTOVF: _bindgen_ty_6 = 4;
pub const FPE_FLTUND: _bindgen_ty_6 = 5;
pub const FPE_FLTRES: _bindgen_ty_6 = 6;
pub const FPE_FLTINV: _bindgen_ty_6 = 7;
pub const FPE_FLTSUB: _bindgen_ty_6 = 8;
pub const FPE_FLTUNK: _bindgen_ty_6 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_6 = 15;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_7 = 1;
pub const SEGV_ACCERR: _bindgen_ty_7 = 2;
pub const SEGV_BNDERR: _bindgen_ty_7 = 3;
pub const SEGV_PKUERR: _bindgen_ty_7 = 4;
pub const SEGV_ACCADI: _bindgen_ty_7 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_7 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_7 = 7;
pub const SEGV_MTEAERR: _bindgen_ty_7 = 8;
pub const SEGV_MTESERR: _bindgen_ty_7 = 9;
pub const SEGV_CPERR: _bindgen_ty_7 = 10;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: _bindgen_ty_8 = 1;
pub const BUS_ADRERR: _bindgen_ty_8 = 2;
pub const BUS_OBJERR: _bindgen_ty_8 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_8 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_8 = 5;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const TRAP_BRKPT: _bindgen_ty_9 = 1;
pub const TRAP_TRACE: _bindgen_ty_9 = 2;
pub const TRAP_BRANCH: _bindgen_ty_9 = 3;
pub const TRAP_HWBKPT: _bindgen_ty_9 = 4;
pub const TRAP_UNK: _bindgen_ty_9 = 5;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const CLD_EXITED: _bindgen_ty_10 = 1;
pub const CLD_KILLED: _bindgen_ty_10 = 2;
pub const CLD_DUMPED: _bindgen_ty_10 = 3;
pub const CLD_TRAPPED: _bindgen_ty_10 = 4;
pub const CLD_STOPPED: _bindgen_ty_10 = 5;
pub const CLD_CONTINUED: _bindgen_ty_10 = 6;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const POLL_IN: _bindgen_ty_11 = 1;
pub const POLL_OUT: _bindgen_ty_11 = 2;
pub const POLL_MSG: _bindgen_ty_11 = 3;
pub const POLL_ERR: _bindgen_ty_11 = 4;
pub const POLL_PRI: _bindgen_ty_11 = 5;
pub const POLL_HUP: _bindgen_ty_11 = 6;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._attribute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._tid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigev_thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigev_un) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_12 = 0;
pub const SIGEV_NONE: _bindgen_ty_12 = 1;
pub const SIGEV_THREAD: _bindgen_ty_12 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_12 = 4;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
extern "C" {
    pub fn sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}__xpg_sigpause"]
    pub fn sigpause(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sighandler_t = __sighandler_t;
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigisemptyset(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigandset(
        __set: *mut sigset_t,
        __left: *const sigset_t,
        __right: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigorset(
        __set: *mut sigset_t,
        __left: *const sigset_t,
        __right: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_restorer) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    const UNINIT: ::std::mem::MaybeUninit<_fpx_sw_bytes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extended_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xstate_bv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xstate_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    const UNINIT: ::std::mem::MaybeUninit<_fpreg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).significand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    const UNINIT: ::std::mem::MaybeUninit<_fpxreg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).significand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    const UNINIT: ::std::mem::MaybeUninit<_xmmreg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    const UNINIT: ::std::mem::MaybeUninit<_fpstate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cwd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swd) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ftw) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fop) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mxcsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mxcr_mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._st) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._xmm) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigcontext__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpstate_word) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(__fpstate_word)
        )
    );
}
#[test]
fn bindgen_test_layout_sigcontext() {
    const UNINIT: ::std::mem::MaybeUninit<sigcontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r9) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r10) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r11) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r12) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r13) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r14) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r15) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdi) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsi) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rbp) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rbx) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdx) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rax) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcx) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsp) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eflags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gs) as usize - ptr as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trapno) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oldmask) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr2) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved1) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    const UNINIT: ::std::mem::MaybeUninit<_xsave_hdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_xsave_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<_xsave_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xstate_bv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    const UNINIT: ::std::mem::MaybeUninit<_ymmh_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymmh_space) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    const UNINIT: ::std::mem::MaybeUninit<_xstate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xstate_hdr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymmh) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_stack_t() {
    const UNINIT: ::std::mem::MaybeUninit<stack_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stack_t>(),
        24usize,
        concat!("Size of: ", stringify!(stack_t))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_t>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
pub const REG_R8: _bindgen_ty_13 = 0;
pub const REG_R9: _bindgen_ty_13 = 1;
pub const REG_R10: _bindgen_ty_13 = 2;
pub const REG_R11: _bindgen_ty_13 = 3;
pub const REG_R12: _bindgen_ty_13 = 4;
pub const REG_R13: _bindgen_ty_13 = 5;
pub const REG_R14: _bindgen_ty_13 = 6;
pub const REG_R15: _bindgen_ty_13 = 7;
pub const REG_RDI: _bindgen_ty_13 = 8;
pub const REG_RSI: _bindgen_ty_13 = 9;
pub const REG_RBP: _bindgen_ty_13 = 10;
pub const REG_RBX: _bindgen_ty_13 = 11;
pub const REG_RDX: _bindgen_ty_13 = 12;
pub const REG_RAX: _bindgen_ty_13 = 13;
pub const REG_RCX: _bindgen_ty_13 = 14;
pub const REG_RSP: _bindgen_ty_13 = 15;
pub const REG_RIP: _bindgen_ty_13 = 16;
pub const REG_EFL: _bindgen_ty_13 = 17;
pub const REG_CSGSFS: _bindgen_ty_13 = 18;
pub const REG_ERR: _bindgen_ty_13 = 19;
pub const REG_TRAPNO: _bindgen_ty_13 = 20;
pub const REG_OLDMASK: _bindgen_ty_13 = 21;
pub const REG_CR2: _bindgen_ty_13 = 22;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    const UNINIT: ::std::mem::MaybeUninit<_libc_fpxreg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_libc_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).significand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    const UNINIT: ::std::mem::MaybeUninit<_libc_xmmreg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_libc_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    const UNINIT: ::std::mem::MaybeUninit<_libc_fpstate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_libc_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cwd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swd) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ftw) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fop) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mxcsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mxcr_mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._st) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._xmm) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    const UNINIT: ::std::mem::MaybeUninit<mcontext_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcontext_t>(),
        256usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mcontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gregs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpregs) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved1) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::std::os::raw::c_ulonglong; 4usize],
}
#[test]
fn bindgen_test_layout_ucontext_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucontext_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucontext_t>(),
        968usize,
        concat!("Size of: ", stringify!(ucontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpregs_mem) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__fpregs_mem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ssp) as usize - ptr as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__ssp)
        )
    );
}
extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_14 = 1;
pub const SS_DISABLE: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(__sig: ::std::os::raw::c_int, __disp: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigqueue(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
        __value: sigval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tgkill(
        __tgid: __pid_t,
        __tid: __pid_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
pub const MSG_OOB: _bindgen_ty_15 = 1;
pub const MSG_PEEK: _bindgen_ty_15 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_15 = 4;
pub const MSG_TRYHARD: _bindgen_ty_15 = 4;
pub const MSG_CTRUNC: _bindgen_ty_15 = 8;
pub const MSG_PROXY: _bindgen_ty_15 = 16;
pub const MSG_TRUNC: _bindgen_ty_15 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_15 = 64;
pub const MSG_EOR: _bindgen_ty_15 = 128;
pub const MSG_WAITALL: _bindgen_ty_15 = 256;
pub const MSG_FIN: _bindgen_ty_15 = 512;
pub const MSG_SYN: _bindgen_ty_15 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_15 = 2048;
pub const MSG_RST: _bindgen_ty_15 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_15 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_15 = 16384;
pub const MSG_MORE: _bindgen_ty_15 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_15 = 65536;
pub const MSG_BATCH: _bindgen_ty_15 = 262144;
pub const MSG_ZEROCOPY: _bindgen_ty_15 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_15 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_15 = 1073741824;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cmsg_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_16 = 1;
pub const SCM_CREDENTIALS: _bindgen_ty_16 = 2;
pub const SCM_SECURITY: _bindgen_ty_16 = 3;
pub const SCM_PIDFD: _bindgen_ty_16 = 4;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    pub pid: pid_t,
    pub uid: uid_t,
    pub gid: gid_t,
}
#[test]
fn bindgen_test_layout_ucred() {
    const UNINIT: ::std::mem::MaybeUninit<ucred> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucred>(),
        12usize,
        concat!("Size of: ", stringify!(ucred))
    );
    assert_eq!(
        ::std::mem::align_of::<ucred>(),
        4usize,
        concat!("Alignment of ", stringify!(ucred))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(gid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::std::mem::MaybeUninit<linger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<osockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub const SHUT_RD: _bindgen_ty_17 = 0;
pub const SHUT_WR: _bindgen_ty_17 = 1;
pub const SHUT_RDWR: _bindgen_ty_17 = 2;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __SOCKADDR_ARG {
    pub __sockaddr__: *mut sockaddr,
    pub __sockaddr_at__: *mut sockaddr_at,
    pub __sockaddr_ax25__: *mut sockaddr_ax25,
    pub __sockaddr_dl__: *mut sockaddr_dl,
    pub __sockaddr_eon__: *mut sockaddr_eon,
    pub __sockaddr_in__: *mut sockaddr_in,
    pub __sockaddr_in6__: *mut sockaddr_in6,
    pub __sockaddr_inarp__: *mut sockaddr_inarp,
    pub __sockaddr_ipx__: *mut sockaddr_ipx,
    pub __sockaddr_iso__: *mut sockaddr_iso,
    pub __sockaddr_ns__: *mut sockaddr_ns,
    pub __sockaddr_un__: *mut sockaddr_un,
    pub __sockaddr_x25__: *mut sockaddr_x25,
}
#[test]
fn bindgen_test_layout___SOCKADDR_ARG() {
    const UNINIT: ::std::mem::MaybeUninit<__SOCKADDR_ARG> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__SOCKADDR_ARG>(),
        8usize,
        concat!("Size of: ", stringify!(__SOCKADDR_ARG))
    );
    assert_eq!(
        ::std::mem::align_of::<__SOCKADDR_ARG>(),
        8usize,
        concat!("Alignment of ", stringify!(__SOCKADDR_ARG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_at__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_at__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_ax25__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ax25__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_dl__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_dl__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_eon__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_eon__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_in__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_in6__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in6__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_inarp__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_inarp__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_ipx__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ipx__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_iso__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_iso__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_ns__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ns__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_un__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_un__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_x25__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_x25__)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __CONST_SOCKADDR_ARG {
    pub __sockaddr__: *const sockaddr,
    pub __sockaddr_at__: *const sockaddr_at,
    pub __sockaddr_ax25__: *const sockaddr_ax25,
    pub __sockaddr_dl__: *const sockaddr_dl,
    pub __sockaddr_eon__: *const sockaddr_eon,
    pub __sockaddr_in__: *const sockaddr_in,
    pub __sockaddr_in6__: *const sockaddr_in6,
    pub __sockaddr_inarp__: *const sockaddr_inarp,
    pub __sockaddr_ipx__: *const sockaddr_ipx,
    pub __sockaddr_iso__: *const sockaddr_iso,
    pub __sockaddr_ns__: *const sockaddr_ns,
    pub __sockaddr_un__: *const sockaddr_un,
    pub __sockaddr_x25__: *const sockaddr_x25,
}
#[test]
fn bindgen_test_layout___CONST_SOCKADDR_ARG() {
    const UNINIT: ::std::mem::MaybeUninit<__CONST_SOCKADDR_ARG> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__CONST_SOCKADDR_ARG>(),
        8usize,
        concat!("Size of: ", stringify!(__CONST_SOCKADDR_ARG))
    );
    assert_eq!(
        ::std::mem::align_of::<__CONST_SOCKADDR_ARG>(),
        8usize,
        concat!("Alignment of ", stringify!(__CONST_SOCKADDR_ARG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_at__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_at__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_ax25__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ax25__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_dl__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_dl__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_eon__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_eon__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_in__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_in6__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in6__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_inarp__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_inarp__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_ipx__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ipx__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_iso__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_iso__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_ns__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ns__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_un__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_un__)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sockaddr_x25__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_x25__)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<mmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mmsghdr>(),
        64usize,
        concat!("Size of: ", stringify!(mmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<mmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(mmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_len) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_len)
        )
    );
}
extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __addr_len: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendmmsg(
        __fd: ::std::os::raw::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvmmsg(
        __fd: ::std::os::raw::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
        __tmo: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept4(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn writev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn preadv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwritev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn preadv64(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    pub fn pwritev64(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    pub fn preadv2(
        __fp: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
        ___flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn pwritev2(
        __fd: ::std::os::raw::c_int,
        __iodev: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn preadv64v2(
        __fp: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off64_t,
        ___flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn pwritev64v2(
        __fd: ::std::os::raw::c_int,
        __iodev: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off64_t,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn process_vm_readv(
        __pid: pid_t,
        __lvec: *const iovec,
        __liovcnt: ::std::os::raw::c_ulong,
        __rvec: *const iovec,
        __riovcnt: ::std::os::raw::c_ulong,
        __flags: ::std::os::raw::c_ulong,
    ) -> isize;
}
extern "C" {
    pub fn process_vm_writev(
        __pid: pid_t,
        __lvec: *const iovec,
        __liovcnt: ::std::os::raw::c_ulong,
        __rvec: *const iovec,
        __riovcnt: ::std::os::raw::c_ulong,
        __flags: ::std::os::raw::c_ulong,
    ) -> isize;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    const UNINIT: ::std::mem::MaybeUninit<ip_opts> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_opts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_spec_dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
pub const IPPROTO_IP: _bindgen_ty_18 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_18 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_18 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_18 = 4;
pub const IPPROTO_TCP: _bindgen_ty_18 = 6;
pub const IPPROTO_EGP: _bindgen_ty_18 = 8;
pub const IPPROTO_PUP: _bindgen_ty_18 = 12;
pub const IPPROTO_UDP: _bindgen_ty_18 = 17;
pub const IPPROTO_IDP: _bindgen_ty_18 = 22;
pub const IPPROTO_TP: _bindgen_ty_18 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_18 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_18 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_18 = 46;
pub const IPPROTO_GRE: _bindgen_ty_18 = 47;
pub const IPPROTO_ESP: _bindgen_ty_18 = 50;
pub const IPPROTO_AH: _bindgen_ty_18 = 51;
pub const IPPROTO_MTP: _bindgen_ty_18 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_18 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_18 = 98;
pub const IPPROTO_PIM: _bindgen_ty_18 = 103;
pub const IPPROTO_COMP: _bindgen_ty_18 = 108;
pub const IPPROTO_L2TP: _bindgen_ty_18 = 115;
pub const IPPROTO_SCTP: _bindgen_ty_18 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_18 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_18 = 137;
pub const IPPROTO_ETHERNET: _bindgen_ty_18 = 143;
pub const IPPROTO_RAW: _bindgen_ty_18 = 255;
pub const IPPROTO_MPTCP: _bindgen_ty_18 = 262;
pub const IPPROTO_MAX: _bindgen_ty_18 = 263;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const IPPROTO_HOPOPTS: _bindgen_ty_19 = 0;
pub const IPPROTO_ROUTING: _bindgen_ty_19 = 43;
pub const IPPROTO_FRAGMENT: _bindgen_ty_19 = 44;
pub const IPPROTO_ICMPV6: _bindgen_ty_19 = 58;
pub const IPPROTO_NONE: _bindgen_ty_19 = 59;
pub const IPPROTO_DSTOPTS: _bindgen_ty_19 = 60;
pub const IPPROTO_MH: _bindgen_ty_19 = 135;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_20 = 7;
pub const IPPORT_DISCARD: _bindgen_ty_20 = 9;
pub const IPPORT_SYSTAT: _bindgen_ty_20 = 11;
pub const IPPORT_DAYTIME: _bindgen_ty_20 = 13;
pub const IPPORT_NETSTAT: _bindgen_ty_20 = 15;
pub const IPPORT_FTP: _bindgen_ty_20 = 21;
pub const IPPORT_TELNET: _bindgen_ty_20 = 23;
pub const IPPORT_SMTP: _bindgen_ty_20 = 25;
pub const IPPORT_TIMESERVER: _bindgen_ty_20 = 37;
pub const IPPORT_NAMESERVER: _bindgen_ty_20 = 42;
pub const IPPORT_WHOIS: _bindgen_ty_20 = 43;
pub const IPPORT_MTP: _bindgen_ty_20 = 57;
pub const IPPORT_TFTP: _bindgen_ty_20 = 69;
pub const IPPORT_RJE: _bindgen_ty_20 = 77;
pub const IPPORT_FINGER: _bindgen_ty_20 = 79;
pub const IPPORT_TTYLINK: _bindgen_ty_20 = 87;
pub const IPPORT_SUPDUP: _bindgen_ty_20 = 95;
pub const IPPORT_EXECSERVER: _bindgen_ty_20 = 512;
pub const IPPORT_LOGINSERVER: _bindgen_ty_20 = 513;
pub const IPPORT_CMDSERVER: _bindgen_ty_20 = 514;
pub const IPPORT_EFSSERVER: _bindgen_ty_20 = 520;
pub const IPPORT_BIFFUDP: _bindgen_ty_20 = 512;
pub const IPPORT_WHOSERVER: _bindgen_ty_20 = 513;
pub const IPPORT_ROUTESERVER: _bindgen_ty_20 = 520;
pub const IPPORT_RESERVED: _bindgen_ty_20 = 1024;
pub const IPPORT_USERRESERVED: _bindgen_ty_20 = 5000;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__in6_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreqn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_ifindex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq_source> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_sourceaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ipv6_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_interface) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        136usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_source_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_source) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    const UNINIT: ::std::mem::MaybeUninit<ip_msfilter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_fmode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_numsrc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_slist) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    const UNINIT: ::std::mem::MaybeUninit<group_filter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_fmode) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_numsrc) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_slist) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in6_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_ifindex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    const UNINIT: ::std::mem::MaybeUninit<ip6_mtuinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_mtu) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
extern "C" {
    pub fn inet6_option_space(__nbytes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_init(
        __bp: *mut ::std::os::raw::c_void,
        __cmsgp: *mut *mut cmsghdr,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_append(
        __cmsg: *mut cmsghdr,
        __typep: *const u8,
        __multx: ::std::os::raw::c_int,
        __plusy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(
        __cmsg: *mut cmsghdr,
        __datalen: ::std::os::raw::c_int,
        __multx: ::std::os::raw::c_int,
        __plusy: ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn inet6_option_next(
        __cmsg: *const cmsghdr,
        __tptrp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_find(
        __cmsg: *const cmsghdr,
        __tptrp: *mut *mut u8,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_init(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_append(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
        __type: u8,
        __len: socklen_t,
        __align: u8,
        __databufp: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(
        __databuf: *mut ::std::os::raw::c_void,
        __offset: ::std::os::raw::c_int,
        __val: *mut ::std::os::raw::c_void,
        __vallen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_next(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
        __typep: *mut u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_find(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
        __type: u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(
        __databuf: *mut ::std::os::raw::c_void,
        __offset: ::std::os::raw::c_int,
        __val: *mut ::std::os::raw::c_void,
        __vallen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_space(
        __type: ::std::os::raw::c_int,
        __segments: ::std::os::raw::c_int,
    ) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(
        __bp: *mut ::std::os::raw::c_void,
        __bp_len: socklen_t,
        __type: ::std::os::raw::c_int,
        __segments: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn inet6_rth_add(
        __bp: *mut ::std::os::raw::c_void,
        __addr: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(
        __in: *const ::std::os::raw::c_void,
        __out: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(__bp: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(
        __bp: *const ::std::os::raw::c_void,
        __index: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    pub fn getipv4sourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setipv4sourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
pub type tcp_seq = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcphdr {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcphdr__bindgen_ty_1 {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: tcphdr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_1 {
    pub th_sport: u16,
    pub th_dport: u16,
    pub th_seq: tcp_seq,
    pub th_ack: tcp_seq,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub th_flags: u8,
    pub th_win: u16,
    pub th_sum: u16,
    pub th_urp: u16,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<tcphdr__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_sport) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_sport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_dport) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_dport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_seq) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_ack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_ack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_flags) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_win) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_win)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_sum) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_sum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th_urp) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_urp)
        )
    );
}
impl tcphdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn th_x2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn th_off(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(th_x2: u8, th_off: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let th_x2: u8 = unsafe { ::std::mem::transmute(th_x2) };
            th_x2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let th_off: u8 = unsafe { ::std::mem::transmute(th_off) };
            th_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_2 {
    pub source: u16,
    pub dest: u16,
    pub seq: u32,
    pub ack_seq: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub window: u16,
    pub check: u16,
    pub urg_ptr: u16,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<tcphdr__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ack_seq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ack_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).urg_ptr) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(urg_ptr)
        )
    );
}
impl tcphdr__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn doff(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psh(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: u16,
        doff: u16,
        fin: u16,
        syn: u16,
        rst: u16,
        psh: u16,
        ack: u16,
        urg: u16,
        res2: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::std::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::std::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::std::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::std::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::std::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::std::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::std::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res2: u16 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_tcphdr() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr))
    );
}
pub const TCP_ESTABLISHED: _bindgen_ty_21 = 1;
pub const TCP_SYN_SENT: _bindgen_ty_21 = 2;
pub const TCP_SYN_RECV: _bindgen_ty_21 = 3;
pub const TCP_FIN_WAIT1: _bindgen_ty_21 = 4;
pub const TCP_FIN_WAIT2: _bindgen_ty_21 = 5;
pub const TCP_TIME_WAIT: _bindgen_ty_21 = 6;
pub const TCP_CLOSE: _bindgen_ty_21 = 7;
pub const TCP_CLOSE_WAIT: _bindgen_ty_21 = 8;
pub const TCP_LAST_ACK: _bindgen_ty_21 = 9;
pub const TCP_LISTEN: _bindgen_ty_21 = 10;
pub const TCP_CLOSING: _bindgen_ty_21 = 11;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const tcp_ca_state_TCP_CA_Open: tcp_ca_state = 0;
pub const tcp_ca_state_TCP_CA_Disorder: tcp_ca_state = 1;
pub const tcp_ca_state_TCP_CA_CWR: tcp_ca_state = 2;
pub const tcp_ca_state_TCP_CA_Recovery: tcp_ca_state = 3;
pub const tcp_ca_state_TCP_CA_Loss: tcp_ca_state = 4;
pub type tcp_ca_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_info {
    pub tcpi_state: u8,
    pub tcpi_ca_state: u8,
    pub tcpi_retransmits: u8,
    pub tcpi_probes: u8,
    pub tcpi_backoff: u8,
    pub tcpi_options: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tcpi_rto: u32,
    pub tcpi_ato: u32,
    pub tcpi_snd_mss: u32,
    pub tcpi_rcv_mss: u32,
    pub tcpi_unacked: u32,
    pub tcpi_sacked: u32,
    pub tcpi_lost: u32,
    pub tcpi_retrans: u32,
    pub tcpi_fackets: u32,
    pub tcpi_last_data_sent: u32,
    pub tcpi_last_ack_sent: u32,
    pub tcpi_last_data_recv: u32,
    pub tcpi_last_ack_recv: u32,
    pub tcpi_pmtu: u32,
    pub tcpi_rcv_ssthresh: u32,
    pub tcpi_rtt: u32,
    pub tcpi_rttvar: u32,
    pub tcpi_snd_ssthresh: u32,
    pub tcpi_snd_cwnd: u32,
    pub tcpi_advmss: u32,
    pub tcpi_reordering: u32,
    pub tcpi_rcv_rtt: u32,
    pub tcpi_rcv_space: u32,
    pub tcpi_total_retrans: u32,
}
#[test]
fn bindgen_test_layout_tcp_info() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_info>(),
        104usize,
        concat!("Size of: ", stringify!(tcp_info))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_info>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_ca_state) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_ca_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_retransmits) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_retransmits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_probes) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_probes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_backoff) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_backoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_options) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rto) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rto)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_ato) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_ato)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_snd_mss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_mss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rcv_mss) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_mss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_unacked) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_unacked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_sacked) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_sacked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_lost) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_lost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_retrans) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_retrans)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_fackets) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_fackets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_last_data_sent) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_data_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_last_ack_sent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_ack_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_last_data_recv) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_data_recv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_last_ack_recv) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_ack_recv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_pmtu) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_pmtu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rcv_ssthresh) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_ssthresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rtt) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rtt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rttvar) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rttvar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_snd_ssthresh) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_ssthresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_snd_cwnd) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_cwnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_advmss) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_advmss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_reordering) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_reordering)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rcv_rtt) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_rtt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_rcv_space) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpi_total_retrans) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_total_retrans)
        )
    );
}
impl tcp_info {
    #[inline]
    pub fn tcpi_snd_wscale(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_snd_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_rcv_wscale(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_rcv_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcpi_snd_wscale: u8,
        tcpi_rcv_wscale: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let tcpi_snd_wscale: u8 = unsafe { ::std::mem::transmute(tcpi_snd_wscale) };
            tcpi_snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tcpi_rcv_wscale: u8 = unsafe { ::std::mem::transmute(tcpi_rcv_wscale) };
            tcpi_rcv_wscale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_md5sig {
    pub tcpm_addr: sockaddr_storage,
    pub tcpm_flags: u8,
    pub tcpm_prefixlen: u8,
    pub tcpm_keylen: u16,
    pub tcpm_ifindex: ::std::os::raw::c_int,
    pub tcpm_key: [u8; 80usize],
}
#[test]
fn bindgen_test_layout_tcp_md5sig() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_md5sig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_md5sig>(),
        216usize,
        concat!("Size of: ", stringify!(tcp_md5sig))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_md5sig>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_md5sig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpm_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpm_flags) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpm_prefixlen) as usize - ptr as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_prefixlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpm_keylen) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_keylen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpm_ifindex) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpm_key) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_opt {
    pub opt_code: u32,
    pub opt_val: u32,
}
#[test]
fn bindgen_test_layout_tcp_repair_opt() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_repair_opt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_repair_opt>(),
        8usize,
        concat!("Size of: ", stringify!(tcp_repair_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_repair_opt>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_repair_opt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_opt),
            "::",
            stringify!(opt_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_val) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_opt),
            "::",
            stringify!(opt_val)
        )
    );
}
pub const TCP_NO_QUEUE: _bindgen_ty_22 = 0;
pub const TCP_RECV_QUEUE: _bindgen_ty_22 = 1;
pub const TCP_SEND_QUEUE: _bindgen_ty_22 = 2;
pub const TCP_QUEUES_NR: _bindgen_ty_22 = 3;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_cookie_transactions {
    pub tcpct_flags: u16,
    pub __tcpct_pad1: u8,
    pub tcpct_cookie_desired: u8,
    pub tcpct_s_data_desired: u16,
    pub tcpct_used: u16,
    pub tcpct_value: [u8; 536usize],
}
#[test]
fn bindgen_test_layout_tcp_cookie_transactions() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_cookie_transactions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_cookie_transactions>(),
        544usize,
        concat!("Size of: ", stringify!(tcp_cookie_transactions))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_cookie_transactions>(),
        2usize,
        concat!("Alignment of ", stringify!(tcp_cookie_transactions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpct_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__tcpct_pad1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(__tcpct_pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpct_cookie_desired) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_cookie_desired)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpct_s_data_desired) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_s_data_desired)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpct_used) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcpct_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_window {
    pub snd_wl1: u32,
    pub snd_wnd: u32,
    pub max_window: u32,
    pub rcv_wnd: u32,
    pub rcv_wup: u32,
}
#[test]
fn bindgen_test_layout_tcp_repair_window() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_repair_window> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_repair_window>(),
        20usize,
        concat!("Size of: ", stringify!(tcp_repair_window))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_repair_window>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_repair_window))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).snd_wl1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(snd_wl1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).snd_wnd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(snd_wnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(max_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcv_wnd) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(rcv_wnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcv_wup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(rcv_wup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_zerocopy_receive {
    pub address: u64,
    pub length: u32,
    pub recv_skip_hint: u32,
}
#[test]
fn bindgen_test_layout_tcp_zerocopy_receive() {
    const UNINIT: ::std::mem::MaybeUninit<tcp_zerocopy_receive> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tcp_zerocopy_receive>(),
        16usize,
        concat!("Size of: ", stringify!(tcp_zerocopy_receive))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_zerocopy_receive>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_zerocopy_receive))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_skip_hint) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(recv_skip_hint)
        )
    );
}
extern "C" {
    pub fn inet_addr(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_lnaof(__in: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_makeaddr(__net: in_addr_t, __host: in_addr_t) -> in_addr;
}
extern "C" {
    pub fn inet_netof(__in: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_network(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_ntoa(__in: in_addr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_pton(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_ntop(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __len: socklen_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_aton(
        __cp: *const ::std::os::raw::c_char,
        __inp: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_neta(
        __net: in_addr_t,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_ntop(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_void,
        __bits: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_pton(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_nsap_addr(
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_uchar,
        __len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn inet_nsap_ntoa(
        __len: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_uchar,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " 0 - no verbose messages"]
pub const verbosity_value_NO_VERBOSE: verbosity_value = 0;
#[doc = " 1 - operational information"]
pub const verbosity_value_VERB_OPS: verbosity_value = 1;
#[doc = " 2 - detailed information"]
pub const verbosity_value_VERB_DETAIL: verbosity_value = 2;
#[doc = " 3 - query level information"]
pub const verbosity_value_VERB_QUERY: verbosity_value = 3;
#[doc = " 4 - algorithm level information"]
pub const verbosity_value_VERB_ALGO: verbosity_value = 4;
#[doc = " 5 - querier client information"]
pub const verbosity_value_VERB_CLIENT: verbosity_value = 5;
#[doc = " verbosity value:"]
pub type verbosity_value = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " The global verbosity setting"]
    pub static mut verbosity: verbosity_value;
}
extern "C" {
    #[doc = " log a verbose message, pass the level for this message.\n It has printf formatted arguments. No trailing newline is needed.\n @param level: verbosity level for this message, compared to global\n\tverbosity setting.\n @param format: printf-style format string. Arguments follow."]
    pub fn verbose(level: verbosity_value, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " call this to initialize logging services.\n @param filename: if NULL stderr is used.\n @param use_syslog: set to true to ignore filename and use syslog(3).\n @param chrootdir: to which directory we have been chrooted, if any."]
    pub fn log_init(
        filename: *const ::std::os::raw::c_char,
        use_syslog: ::std::os::raw::c_int,
        chrootdir: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Set logging to go to the specified file *.\n This setting does not affect the use_syslog setting.\n @param f: to that file, or pass NULL to disable logging."]
    pub fn log_file(f: *mut FILE);
}
extern "C" {
    #[doc = " Init a thread (will print this number for the thread log entries).\n Must be called from the thread itself. If not called 0 is printed.\n @param num: number to print for this thread. Owned by caller, must\n\tcontinue to exist."]
    pub fn log_thread_set(num: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the thread id from logging system.  Set after log_init is\n initialised, or log_thread_set for newly created threads.\n This initialisation happens in unbound as a daemon, in daemon\n startup code, when that spawns threads.\n @return thread number, from 0 and up.  Before initialised, returns 0."]
    pub fn log_thread_get() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set identity to print, default is 'unbound'.\n @param id: string to print. Name of executable."]
    pub fn log_ident_set(id: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set default identity to print, default is 'unbound'.\n @param id: string to print. Name of executable."]
    pub fn log_ident_set_default(id: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Revert identity to print, back to the recorded default value."]
    pub fn log_ident_revert_to_default();
}
extern "C" {
    #[doc = " Set identity to print if there is an identity, otherwise\n set the default.\n @param identity: the identity to set."]
    pub fn log_ident_set_or_default(identity: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set if the time value is printed ascii or decimal in log entries.\n @param use_asc: if true, ascii is printed, otherwise decimal.\n\tIf the conversion fails or you have no time functions,\n\tdecimal is printed."]
    pub fn log_set_time_asc(use_asc: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " get log lock"]
    pub fn log_get_lock() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Log informational message.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn log_info(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Log error message.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn log_err(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Log warning message.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn log_warn(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Log a hex-string to the log. Can be any length.\n performs mallocs to do so, slow. But debug useful.\n @param msg: string desc to accompany the hexdump.\n @param data: data to dump in hex format.\n @param length: length of data."]
    pub fn log_hex(
        msg: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    #[doc = " Log query.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn log_query(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Log reply.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn log_reply(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Easy alternative for log_hex, takes a sldns_buffer.\n @param level: verbosity level for this message, compared to global\n\tverbosity setting.\n @param msg: string desc to print\n @param buf: the buffer."]
    pub fn log_buf(
        level: verbosity_value,
        msg: *const ::std::os::raw::c_char,
        buf: *mut sldns_buffer,
    );
}
extern "C" {
    #[doc = " Log fatal error message, and exit the current process.\n Pass printf formatted arguments. No trailing newline is needed.\n @param format: printf-style format string. Arguments follow."]
    pub fn fatal_exit(format: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[doc = " va_list argument version of log_info.\n @param pri: priority type, for example 5 (INFO).\n @param type: string to designate type of message (info, error).\n @param format: the printf style format to print. no newline.\n @param args: arguments for format string."]
    pub fn log_vmsg(
        pri: ::std::os::raw::c_int,
        type_: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
extern "C" {
    pub fn clone(
        __fn: ::std::option::Option<
            unsafe extern "C" fn(__arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        __child_stack: *mut ::std::os::raw::c_void,
        __flags: ::std::os::raw::c_int,
        __arg: *mut ::std::os::raw::c_void,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unshare(__flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getcpu() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcpu(
        arg1: *mut ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setns(
        __fd: ::std::os::raw::c_int,
        __nstype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timex {
    pub modes: ::std::os::raw::c_uint,
    pub offset: __syscall_slong_t,
    pub freq: __syscall_slong_t,
    pub maxerror: __syscall_slong_t,
    pub esterror: __syscall_slong_t,
    pub status: ::std::os::raw::c_int,
    pub constant: __syscall_slong_t,
    pub precision: __syscall_slong_t,
    pub tolerance: __syscall_slong_t,
    pub time: timeval,
    pub tick: __syscall_slong_t,
    pub ppsfreq: __syscall_slong_t,
    pub jitter: __syscall_slong_t,
    pub shift: ::std::os::raw::c_int,
    pub stabil: __syscall_slong_t,
    pub jitcnt: __syscall_slong_t,
    pub calcnt: __syscall_slong_t,
    pub errcnt: __syscall_slong_t,
    pub stbcnt: __syscall_slong_t,
    pub tai: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize]>,
}
#[test]
fn bindgen_test_layout_timex() {
    const UNINIT: ::std::mem::MaybeUninit<timex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timex>(),
        208usize,
        concat!("Size of: ", stringify!(timex))
    );
    assert_eq!(
        ::std::mem::align_of::<timex>(),
        8usize,
        concat!("Alignment of ", stringify!(timex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxerror) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(maxerror)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).esterror) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(esterror)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constant) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).precision) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tolerance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tolerance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tick) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppsfreq) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(ppsfreq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitter) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(jitter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shift) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stabil) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(stabil)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitcnt) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(jitcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calcnt) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(calcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errcnt) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(errcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stbcnt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(stbcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tai) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tai)
        )
    );
}
extern "C" {
    pub fn clock_adjtime(__clock_id: __clockid_t, __utx: *mut timex) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strptime_l(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
        __loc: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_getres(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdate(__string: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn getdate_r(
        __string: *const ::std::os::raw::c_char,
        __resbufp: *mut tm,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_23 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_23 = 1;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_24 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_24 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_24 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_24 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_24 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_24 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_24 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_24 = 0;
pub const PTHREAD_MUTEX_FAST_NP: _bindgen_ty_24 = 0;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_25 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_25 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_25 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_25 = 1;
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_26 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_26 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_26 = 2;
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_27 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_27 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_27 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_27 = 0;
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_28 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_28 = 1;
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_29 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_29 = 1;
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_30 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_30 = 1;
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_31 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_31 = 1;
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_32 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_32 = 1;
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_tryjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_timedjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_clockjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setaffinity_np(
        __attr: *mut pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getaffinity_np(
        __attr: *const pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getattr_default_np(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setsigmask_np(
        __attr: *mut pthread_attr_t,
        sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getsigmask_np(
        __attr: *const pthread_attr_t,
        sigmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setattr_default_np(__attr: *const pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getattr_np(
        __th: pthread_t,
        __attr: *mut pthread_attr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        __target_thread: pthread_t,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(
        __target_thread: pthread_t,
        __name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(__level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__cancel_jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_register_cancel_defer(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel_restore(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_clocklock(
        __mutex: *mut pthread_mutex_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_clockwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __clock_id: __clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[doc = " use pthread mutex for basic lock"]
pub type lock_basic_type = pthread_mutex_t;
#[doc = " we use the pthread rwlock"]
pub type lock_rw_type = pthread_rwlock_t;
#[doc = " use pthread spinlock for the quick lock"]
pub type lock_quick_type = pthread_spinlock_t;
#[doc = " Thread creation"]
pub type ub_thread_type = pthread_t;
pub type ub_thread_key_type = pthread_key_t;
extern "C" {
    #[doc = " Block all signals for this thread.\n fatal exit on error."]
    pub fn ub_thread_blocksigs();
}
extern "C" {
    #[doc = " unblock one signal for this thread."]
    pub fn ub_thread_sig_unblock(sig: ::std::os::raw::c_int);
}
#[doc = " the type of a hash value"]
pub type hashvalue_type = u32;
#[doc = " Type of function that calculates the size of an entry.\n Result must include the size of struct lruhash_entry.\n Keys that are identical must also calculate to the same size.\n size = func(key, data)."]
pub type lruhash_sizefunc_type = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> usize,
>;
#[doc = " type of function that compares two keys. return 0 if equal."]
pub type lruhash_compfunc_type = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " old keys are deleted.\n The RRset type has to revoke its ID number, markdel() is used first.\n This function is called: func(key, userarg)"]
pub type lruhash_delkeyfunc_type = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " old data is deleted. This function is called: func(data, userarg)."]
pub type lruhash_deldatafunc_type = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " mark a key as pending to be deleted (and not to be used by anyone).\n called: func(key)"]
pub type lruhash_markdelfunc_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " Hash table that keeps LRU list of entries."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lruhash {
    #[doc = " lock for exclusive access, to the lookup array"]
    pub lock: lock_quick_type,
    #[doc = " the size function for entries in this table"]
    pub sizefunc: lruhash_sizefunc_type,
    #[doc = " the compare function for entries in this table."]
    pub compfunc: lruhash_compfunc_type,
    #[doc = " how to delete keys."]
    pub delkeyfunc: lruhash_delkeyfunc_type,
    #[doc = " how to delete data."]
    pub deldatafunc: lruhash_deldatafunc_type,
    #[doc = " how to mark a key pending deletion"]
    pub markdelfunc: lruhash_markdelfunc_type,
    #[doc = " user argument for user functions"]
    pub cb_arg: *mut ::std::os::raw::c_void,
    #[doc = " the size of the lookup array"]
    pub size: usize,
    #[doc = " size bitmask - since size is a power of 2"]
    pub size_mask: ::std::os::raw::c_int,
    #[doc = " lookup array of bins"]
    pub array: *mut lruhash_bin,
    #[doc = " the lru list, start and end, noncyclical double linked list."]
    pub lru_start: *mut lruhash_entry,
    #[doc = " lru list end item (least recently used)"]
    pub lru_end: *mut lruhash_entry,
    #[doc = " the number of entries in the hash table."]
    pub num: usize,
    #[doc = " the amount of space used, roughly the number of bytes in use."]
    pub space_used: usize,
    #[doc = " the amount of space the hash table is maximally allowed to use."]
    pub space_max: usize,
    #[doc = " the maximum collisions were detected during the lruhash_insert operations."]
    pub max_collisions: usize,
}
#[test]
fn bindgen_test_layout_lruhash() {
    const UNINIT: ::std::mem::MaybeUninit<lruhash> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lruhash>(),
        128usize,
        concat!("Size of: ", stringify!(lruhash))
    );
    assert_eq!(
        ::std::mem::align_of::<lruhash>(),
        8usize,
        concat!("Alignment of ", stringify!(lruhash))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizefunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(sizefunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compfunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(compfunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delkeyfunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(delkeyfunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deldatafunc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(deldatafunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).markdelfunc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(markdelfunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_arg) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(cb_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_mask) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(size_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lru_start) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(lru_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lru_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(lru_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).space_used) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(space_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).space_max) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(space_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_collisions) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash),
            "::",
            stringify!(max_collisions)
        )
    );
}
#[doc = " A single bin with a linked list of entries in it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lruhash_bin {
    #[doc = " Lock for exclusive access to the linked list\n This lock makes deletion of items safe in this overflow list."]
    pub lock: lock_quick_type,
    #[doc = " linked list of overflow entries"]
    pub overflow_list: *mut lruhash_entry,
}
#[test]
fn bindgen_test_layout_lruhash_bin() {
    const UNINIT: ::std::mem::MaybeUninit<lruhash_bin> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lruhash_bin>(),
        16usize,
        concat!("Size of: ", stringify!(lruhash_bin))
    );
    assert_eq!(
        ::std::mem::align_of::<lruhash_bin>(),
        8usize,
        concat!("Alignment of ", stringify!(lruhash_bin))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash_bin),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash_bin),
            "::",
            stringify!(overflow_list)
        )
    );
}
#[doc = " An entry into the hash table.\n To change overflow_next you need to hold the bin lock.\n To change the lru items you need to hold the hashtable lock.\n This structure is designed as part of key struct. And key pointer helps\n to get the surrounding structure. Data should be allocated on its own."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruhash_entry {
    #[doc = " rwlock for access to the contents of the entry\n Note that it does _not_ cover the lru_ and overflow_ ptrs.\n Even with a writelock, you cannot change hash and key.\n You need to delete it to change hash or key."]
    pub lock: lock_rw_type,
    #[doc = " next entry in overflow chain. Covered by hashlock and binlock."]
    pub overflow_next: *mut lruhash_entry,
    #[doc = " next entry in lru chain. covered by hashlock."]
    pub lru_next: *mut lruhash_entry,
    #[doc = " prev entry in lru chain. covered by hashlock."]
    pub lru_prev: *mut lruhash_entry,
    #[doc = " hash value of the key. It may not change, until entry deleted."]
    pub hash: hashvalue_type,
    #[doc = " key"]
    pub key: *mut ::std::os::raw::c_void,
    #[doc = " data"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lruhash_entry() {
    const UNINIT: ::std::mem::MaybeUninit<lruhash_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lruhash_entry>(),
        104usize,
        concat!("Size of: ", stringify!(lruhash_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<lruhash_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(lruhash_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash_entry),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_next) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash_entry),
            "::",
            stringify!(overflow_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lru_next) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash_entry),
            "::",
            stringify!(lru_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lru_prev) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash_entry),
            "::",
            stringify!(lru_prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash_entry),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash_entry),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lruhash_entry),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Create new hash table.\n @param start_size: size of hashtable array at start, must be power of 2.\n @param maxmem: maximum amount of memory this table is allowed to use.\n @param sizefunc: calculates memory usage of entries.\n @param compfunc: compares entries, 0 on equality.\n @param delkeyfunc: deletes key.\n   Calling both delkey and deldata will also free the struct lruhash_entry.\n   Make it part of the key structure and delete it in delkeyfunc.\n @param deldatafunc: deletes data.\n @param arg: user argument that is passed to user function calls.\n @return: new hash table or NULL on malloc failure."]
    pub fn lruhash_create(
        start_size: usize,
        maxmem: usize,
        sizefunc: lruhash_sizefunc_type,
        compfunc: lruhash_compfunc_type,
        delkeyfunc: lruhash_delkeyfunc_type,
        deldatafunc: lruhash_deldatafunc_type,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut lruhash;
}
extern "C" {
    #[doc = " Delete hash table. Entries are all deleted.\n @param table: to delete."]
    pub fn lruhash_delete(table: *mut lruhash);
}
extern "C" {
    #[doc = " Clear hash table. Entries are all deleted, while locking them before\n doing so. At end the table is empty.\n @param table: to make empty."]
    pub fn lruhash_clear(table: *mut lruhash);
}
extern "C" {
    #[doc = " Insert a new element into the hashtable.\n If key is already present data pointer in that entry is updated.\n The space calculation function is called with the key, data.\n If necessary the least recently used entries are deleted to make space.\n If necessary the hash array is grown up.\n\n @param table: hash table.\n @param hash: hash value. User calculates the hash.\n @param entry: identifies the entry.\n \tIf key already present, this entry->key is deleted immediately.\n\tBut entry->data is set to NULL before deletion, and put into\n \tthe existing entry. The data is then freed.\n @param data: the data.\n @param cb_override: if not null overrides the cb_arg for the deletefunc."]
    pub fn lruhash_insert(
        table: *mut lruhash,
        hash: hashvalue_type,
        entry: *mut lruhash_entry,
        data: *mut ::std::os::raw::c_void,
        cb_override: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Lookup an entry in the hashtable.\n At the end of the function you hold a (read/write)lock on the entry.\n The LRU is updated for the entry (if found).\n @param table: hash table.\n @param hash: hash of key.\n @param key: what to look for, compared against entries in overflow chain.\n    the hash value must be set, and must work with compare function.\n @param wr: set to true if you desire a writelock on the entry.\n    with a writelock you can update the data part.\n @return: pointer to the entry or NULL. The entry is locked.\n    The user must unlock the entry when done."]
    pub fn lruhash_lookup(
        table: *mut lruhash,
        hash: hashvalue_type,
        key: *mut ::std::os::raw::c_void,
        wr: ::std::os::raw::c_int,
    ) -> *mut lruhash_entry;
}
extern "C" {
    #[doc = " Touch entry, so it becomes the most recently used in the LRU list.\n Caller must hold hash table lock. The entry must be inserted already.\n @param table: hash table.\n @param entry: entry to make first in LRU."]
    pub fn lru_touch(table: *mut lruhash, entry: *mut lruhash_entry);
}
extern "C" {
    #[doc = " Set the markdelfunction (or NULL)"]
    pub fn lruhash_setmarkdel(table: *mut lruhash, md: lruhash_markdelfunc_type);
}
extern "C" {
    #[doc = " Update the size of an element in the hashtable.\n\n @param table: hash table.\n @param cb_override: if not NULL overrides the cb_arg for deletefunc.\n @param diff_size: difference in size to the hash table storage.\n \tThis is newsize - oldsize, a positive number uses more space."]
    pub fn lruhash_update_space_used(
        table: *mut lruhash,
        cb_override: *mut ::std::os::raw::c_void,
        diff_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Demote entry, so it becomes the least recently used in the LRU list.\n Caller must hold hash table lock. The entry must be inserted already.\n @param table: hash table.\n @param entry: entry to make last in LRU."]
    pub fn lru_demote(table: *mut lruhash, entry: *mut lruhash_entry);
}
extern "C" {
    #[doc = " Insert a new element into the hashtable, or retrieve the corresponding\n element of it exits.\n\n If key is already present data pointer in that entry is kept.\n If it is not present, a new entry is created. In that case,\n the space calculation function is called with the key, data.\n If necessary the least recently used entries are deleted to make space.\n If necessary the hash array is grown up.\n\n @param table: hash table.\n @param hash: hash value. User calculates the hash.\n @param entry: identifies the entry.\n @param data: the data.\n @param cb_arg: if not null overrides the cb_arg for the deletefunc.\n @return: pointer to the existing entry if the key was already present,\n     or to the entry argument if it was not."]
    pub fn lruhash_insert_or_retrieve(
        table: *mut lruhash,
        hash: hashvalue_type,
        entry: *mut lruhash_entry,
        data: *mut ::std::os::raw::c_void,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut lruhash_entry;
}
extern "C" {
    #[doc = " Remove entry from hashtable. Does nothing if not found in hashtable.\n Delfunc is called for the entry.\n @param table: hash table.\n @param hash: hash of key.\n @param key: what to look for."]
    pub fn lruhash_remove(
        table: *mut lruhash,
        hash: hashvalue_type,
        key: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " init the hash bins for the table"]
    pub fn bin_init(array: *mut lruhash_bin, size: usize);
}
extern "C" {
    #[doc = " delete the hash bin and entries inside it"]
    pub fn bin_delete(table: *mut lruhash, bin: *mut lruhash_bin);
}
extern "C" {
    #[doc = " Find entry in hash bin. You must have locked the bin.\n @param table: hash table with function pointers.\n @param bin: hash bin to look into.\n @param hash: hash value to look for.\n @param key: key to look for.\n @param collisions: how many collisions were found during the search.\n @return: the entry or NULL if not found."]
    pub fn bin_find_entry(
        table: *mut lruhash,
        bin: *mut lruhash_bin,
        hash: hashvalue_type,
        key: *mut ::std::os::raw::c_void,
        collisions: *mut usize,
    ) -> *mut lruhash_entry;
}
extern "C" {
    #[doc = " Remove entry from bin overflow chain.\n You must have locked the bin.\n @param bin: hash bin to look into.\n @param entry: entry ptr that needs removal."]
    pub fn bin_overflow_remove(bin: *mut lruhash_bin, entry: *mut lruhash_entry);
}
extern "C" {
    #[doc = " Split hash bin into two new ones. Based on increased size_mask.\n Caller must hold hash table lock.\n At the end the routine acquires all hashbin locks (in the old array).\n This makes it wait for other threads to finish with the bins.\n So the bins are ready to be deleted after this function.\n @param table: hash table with function pointers.\n @param newa: new increased array.\n @param newmask: new lookup mask."]
    pub fn bin_split(table: *mut lruhash, newa: *mut lruhash_bin, newmask: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Try to make space available by deleting old entries.\n Assumes that the lock on the hashtable is being held by caller.\n Caller must not hold bin locks.\n @param table: hash table.\n @param list: list of entries that are to be deleted later.\n\tEntries have been removed from the hash table and writelock is held."]
    pub fn reclaim_space(table: *mut lruhash, list: *mut *mut lruhash_entry);
}
extern "C" {
    #[doc = " Grow the table lookup array. Becomes twice as large.\n Caller must hold the hash table lock. Must not hold any bin locks.\n Tries to grow, on malloc failure, nothing happened.\n @param table: hash table."]
    pub fn table_grow(table: *mut lruhash);
}
extern "C" {
    #[doc = " Put entry at front of lru. entry must be unlinked from lru.\n Caller must hold hash table lock.\n @param table: hash table with lru head and tail.\n @param entry: entry to make most recently used."]
    pub fn lru_front(table: *mut lruhash, entry: *mut lruhash_entry);
}
extern "C" {
    #[doc = " Remove entry from lru list.\n Caller must hold hash table lock.\n @param table: hash table with lru head and tail.\n @param entry: entry to remove from lru."]
    pub fn lru_remove(table: *mut lruhash, entry: *mut lruhash_entry);
}
extern "C" {
    #[doc = " Output debug info to the log as to state of the hash table.\n @param table: hash table.\n @param id: string printed with table to identify the hash table.\n @param extended: set to true to print statistics on overflow bin lengths."]
    pub fn lruhash_status(
        table: *mut lruhash,
        id: *const ::std::os::raw::c_char,
        extended: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get memory in use now by the lruhash table.\n @param table: hash table. Will be locked before use. And unlocked after.\n @return size in bytes."]
    pub fn lruhash_get_mem(table: *mut lruhash) -> usize;
}
extern "C" {
    #[doc = " Traverse a lruhash. Call back for every element in the table.\n @param h: hash table.  Locked before use.\n @param wr: if true writelock is obtained on element, otherwise readlock.\n @param func: function for every element. Do not lock or unlock elements.\n @param arg: user argument to func."]
    pub fn lruhash_traverse(
        h: *mut lruhash,
        wr: ::std::os::raw::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut lruhash_entry, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alloc_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regional {
    _unused: [u8; 0],
}
#[doc = " type used to uniquely identify rrsets. Cannot be reused without\n clearing the cache."]
pub type rrset_id_type = u64;
#[doc = " The identifying information for an RRset."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packed_rrset_key {
    #[doc = " The domain name. If not null (for id=0) it is allocated, and\n contains the wireformat domain name.\n This dname is not canonicalized."]
    pub dname: *mut u8,
    #[doc = " Length of the domain name, including last 0 root octet."]
    pub dname_len: usize,
    #[doc = " Flags. 32bit to be easy for hashing:\n \to PACKED_RRSET_NSEC_AT_APEX\n \to PACKED_RRSET_PARENT_SIDE\n \to PACKED_RRSET_SOA_NEG\n \to PACKED_RRSET_FIXEDTTL (not supposed to be cached)\n \to PACKED_RRSET_RPZ"]
    pub flags: u32,
    #[doc = " the rrset type in network format"]
    pub type_: u16,
    #[doc = " the rrset class in network format"]
    pub rrset_class: u16,
}
#[test]
fn bindgen_test_layout_packed_rrset_key() {
    const UNINIT: ::std::mem::MaybeUninit<packed_rrset_key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<packed_rrset_key>(),
        24usize,
        concat!("Size of: ", stringify!(packed_rrset_key))
    );
    assert_eq!(
        ::std::mem::align_of::<packed_rrset_key>(),
        8usize,
        concat!("Alignment of ", stringify!(packed_rrset_key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dname) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_key),
            "::",
            stringify!(dname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dname_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_key),
            "::",
            stringify!(dname_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_key),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_key),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrset_class) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_key),
            "::",
            stringify!(rrset_class)
        )
    );
}
#[doc = " This structure contains an RRset. A set of resource records that\n share the same domain name, type and class.\n\n Due to memory management and threading, the key structure cannot be\n deleted, although the data can be. The id can be set to 0 to store and the\n structure can be recycled with a new id."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ub_packed_rrset_key {
    #[doc = " entry into hashtable. Note the lock is never destroyed,\n  even when this key is retired to the cache.\n the data pointer (if not null) points to a struct packed_rrset."]
    pub entry: lruhash_entry,
    #[doc = " the ID of this rrset. unique, based on threadid + sequenceno.\n ids are not reused, except after flushing the cache.\n zero is an unused entry, and never a valid id.\n Check this value after getting entry.lock.\n The other values in this struct may only be altered after changing\n the id (which needs a writelock on entry.lock)."]
    pub id: rrset_id_type,
    #[doc = " key data: dname, type and class"]
    pub rk: packed_rrset_key,
}
#[test]
fn bindgen_test_layout_ub_packed_rrset_key() {
    const UNINIT: ::std::mem::MaybeUninit<ub_packed_rrset_key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ub_packed_rrset_key>(),
        136usize,
        concat!("Size of: ", stringify!(ub_packed_rrset_key))
    );
    assert_eq!(
        ::std::mem::align_of::<ub_packed_rrset_key>(),
        8usize,
        concat!("Alignment of ", stringify!(ub_packed_rrset_key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ub_packed_rrset_key),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ub_packed_rrset_key),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rk) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ub_packed_rrset_key),
            "::",
            stringify!(rk)
        )
    );
}
#[doc = " initial value for trust"]
pub const rrset_trust_rrset_trust_none: rrset_trust = 0;
#[doc = " Additional information from non-authoritative answers"]
pub const rrset_trust_rrset_trust_add_noAA: rrset_trust = 1;
#[doc = " Data from the authority section of a non-authoritative answer"]
pub const rrset_trust_rrset_trust_auth_noAA: rrset_trust = 2;
#[doc = " Additional information from an authoritative answer"]
pub const rrset_trust_rrset_trust_add_AA: rrset_trust = 3;
#[doc = " non-authoritative data from the answer section of authoritative\n answers"]
pub const rrset_trust_rrset_trust_nonauth_ans_AA: rrset_trust = 4;
#[doc = " Data from the answer section of a non-authoritative answer"]
pub const rrset_trust_rrset_trust_ans_noAA: rrset_trust = 5;
#[doc = " Glue from a primary zone, or glue from a zone transfer"]
pub const rrset_trust_rrset_trust_glue: rrset_trust = 6;
#[doc = " Data from the authority section of an authoritative answer"]
pub const rrset_trust_rrset_trust_auth_AA: rrset_trust = 7;
#[doc = " The authoritative data included in the answer section of an\n  authoritative reply"]
pub const rrset_trust_rrset_trust_ans_AA: rrset_trust = 8;
#[doc = " Data from a zone transfer, other than glue"]
pub const rrset_trust_rrset_trust_sec_noglue: rrset_trust = 9;
#[doc = " Data from a primary zone file, other than glue data"]
pub const rrset_trust_rrset_trust_prim_noglue: rrset_trust = 10;
#[doc = " DNSSEC(rfc4034) validated with trusted keys"]
pub const rrset_trust_rrset_trust_validated: rrset_trust = 11;
#[doc = " ultimately trusted, no more trust is possible;\n trusted keys from the unbound configuration setup."]
pub const rrset_trust_rrset_trust_ultimate: rrset_trust = 12;
#[doc = " RRset trustworthiness. Bigger value is more trust. RFC 2181.\n The rrset_trust_add_noAA, rrset_trust_auth_noAA, rrset_trust_add_AA,\n are mentioned as the same trustworthiness in 2181, but split up here\n for ease of processing.\n\n rrset_trust_nonauth_ans_AA, rrset_trust_ans_noAA\n are also mentioned as the same trustworthiness in 2181, but split up here\n for ease of processing.\n\n Added trust_none for a sane initial value, smaller than anything else.\n Added validated and ultimate trust for keys and rrsig validated content."]
pub type rrset_trust = ::std::os::raw::c_uint;
#[doc = " UNCHECKED means that object has yet to be validated."]
pub const sec_status_sec_status_unchecked: sec_status = 0;
#[doc = " BOGUS means that the object (RRset or message) failed to validate\n  (according to local policy), but should have validated."]
pub const sec_status_sec_status_bogus: sec_status = 1;
#[doc = " INDETERMINATE means that the object is insecure, but not\n authoritatively so. Generally this means that the RRset is not\n below a configured trust anchor."]
pub const sec_status_sec_status_indeterminate: sec_status = 2;
#[doc = " INSECURE means that the object is authoritatively known to be\n insecure. Generally this means that this RRset is below a trust\n anchor, but also below a verified, insecure delegation."]
pub const sec_status_sec_status_insecure: sec_status = 3;
#[doc = " SECURE_SENTINEL_FAIL means that the object (RRset or message)\n validated according to local policy but did not succeed in the root\n KSK sentinel test (draft-ietf-dnsop-kskroll-sentinel)."]
pub const sec_status_sec_status_secure_sentinel_fail: sec_status = 4;
#[doc = " SECURE means that the object (RRset or message) validated\n according to local policy."]
pub const sec_status_sec_status_secure: sec_status = 5;
#[doc = " Security status from validation for data.\n The order is significant; more secure, more proven later."]
pub type sec_status = ::std::os::raw::c_uint;
#[doc = " RRset data.\n\n The data is packed, stored contiguously in memory.\n\n It is not always stored contiguously, in that case, an unpacked-packed\n rrset has the arrays separate.  A bunch of routines work on that, but\n the packed rrset that is contiguous is for the rrset-cache and the\n cache-response routines in daemon/worker.c.\n\n memory layout:\n\to base struct\n\to rr_len size_t array\n\to rr_data uint8_t* array\n\to rr_ttl time_t array (after size_t and ptrs because those may be\n\t\t64bit and this array before those would make them unaligned).\n\t\tSince the stuff before is 32/64bit, rr_ttl is 32 bit aligned.\n\to rr_data rdata wireformats\n\to rrsig_data rdata wireformat(s)\n\n Rdata is stored in wireformat. The dname is stored in wireformat.\n TTLs are stored as absolute values (and could be expired).\n\n RRSIGs are stored in the arrays after the regular rrs.\n\n You need the packed_rrset_key to know dname, type, class of the\n resource records in this RRset. (if signed the rrsig gives the type too).\n\n On the wire an RR is:\n\tname, type, class, ttl, rdlength, rdata.\n So we need to send the following per RR:\n\tkey.dname, ttl, rr_data[i].\n\tsince key.dname ends with type and class.\n\tand rr_data starts with the rdlength.\n\tthe ttl value to send changes due to time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packed_rrset_data {
    #[doc = " Timestamp added to TTLs in the packed data.\n Needed to support serving original TTLs."]
    pub ttl_add: time_t,
    #[doc = " TTL (in seconds like time()) of the rrset.\n Same for all RRs see rfc2181(5.2)."]
    pub ttl: time_t,
    #[doc = " number of rrs."]
    pub count: usize,
    #[doc = " number of rrsigs, if 0 no rrsigs"]
    pub rrsig_count: usize,
    #[doc = " the trustworthiness of the rrset data"]
    pub trust: rrset_trust,
    #[doc = " security status of the rrset data"]
    pub security: sec_status,
    #[doc = " length of every rr's rdata, rr_len[i] is size of rr_data[i]."]
    pub rr_len: *mut usize,
    #[doc = " ttl of every rr. rr_ttl[i] ttl of rr i."]
    pub rr_ttl: *mut time_t,
    #[doc = " Array of pointers to every rr's rdata.\n The rr_data[i] rdata is stored in uncompressed wireformat.\n The first uint16_t of rr_data[i] is network format rdlength.\n\n rr_data[count] to rr_data[count+rrsig_count] contain the rrsig data."]
    pub rr_data: *mut *mut u8,
}
#[test]
fn bindgen_test_layout_packed_rrset_data() {
    const UNINIT: ::std::mem::MaybeUninit<packed_rrset_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<packed_rrset_data>(),
        64usize,
        concat!("Size of: ", stringify!(packed_rrset_data))
    );
    assert_eq!(
        ::std::mem::align_of::<packed_rrset_data>(),
        8usize,
        concat!("Alignment of ", stringify!(packed_rrset_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl_add) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_data),
            "::",
            stringify!(ttl_add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_data),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrsig_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_data),
            "::",
            stringify!(rrsig_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trust) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_data),
            "::",
            stringify!(trust)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).security) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_data),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rr_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_data),
            "::",
            stringify!(rr_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rr_ttl) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_data),
            "::",
            stringify!(rr_ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rr_data) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_data),
            "::",
            stringify!(rr_data)
        )
    );
}
#[doc = " An RRset can be represented using both key and data together.\n Split into key and data structures to simplify implementation of\n caching schemes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packed_rrset {
    #[doc = " domain name, type and class"]
    pub k: *mut packed_rrset_key,
    #[doc = " ttl, count and rdatas (and rrsig)"]
    pub d: *mut packed_rrset_data,
}
#[test]
fn bindgen_test_layout_packed_rrset() {
    const UNINIT: ::std::mem::MaybeUninit<packed_rrset> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<packed_rrset>(),
        16usize,
        concat!("Size of: ", stringify!(packed_rrset))
    );
    assert_eq!(
        ::std::mem::align_of::<packed_rrset>(),
        8usize,
        concat!("Alignment of ", stringify!(packed_rrset))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset),
            "::",
            stringify!(d)
        )
    );
}
#[doc = " list of packed rrsets"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packed_rrset_list {
    #[doc = " next in list"]
    pub next: *mut packed_rrset_list,
    #[doc = " rrset key and data"]
    pub rrset: packed_rrset,
}
#[test]
fn bindgen_test_layout_packed_rrset_list() {
    const UNINIT: ::std::mem::MaybeUninit<packed_rrset_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<packed_rrset_list>(),
        24usize,
        concat!("Size of: ", stringify!(packed_rrset_list))
    );
    assert_eq!(
        ::std::mem::align_of::<packed_rrset_list>(),
        8usize,
        concat!("Alignment of ", stringify!(packed_rrset_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_list),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(packed_rrset_list),
            "::",
            stringify!(rrset)
        )
    );
}
extern "C" {
    #[doc = " Delete packed rrset key and data, not entered in hashtables yet.\n Used during parsing.\n @param pkey: rrset key structure with locks, key and data pointers.\n @param alloc: where to return the unfree-able key structure."]
    pub fn ub_packed_rrset_parsedelete(pkey: *mut ub_packed_rrset_key, alloc: *mut alloc_cache);
}
extern "C" {
    #[doc = " Memory size of rrset data. RRset data must be filled in correctly.\n @param data: data to examine.\n @return size in bytes."]
    pub fn packed_rrset_sizeof(data: *mut packed_rrset_data) -> usize;
}
extern "C" {
    #[doc = " Get TTL of rrset. RRset data must be filled in correctly.\n @param key: rrset key, with data to examine.\n @return ttl value."]
    pub fn ub_packed_rrset_ttl(key: *mut ub_packed_rrset_key) -> time_t;
}
extern "C" {
    #[doc = " Calculate memory size of rrset entry. For hash table usage.\n @param key: struct ub_packed_rrset_key*.\n @param data: struct packed_rrset_data*.\n @return size in bytes."]
    pub fn ub_rrset_sizefunc(
        key: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " compares two rrset keys.\n @param k1: struct ub_packed_rrset_key*.\n @param k2: struct ub_packed_rrset_key*.\n @return 0 if equal."]
    pub fn ub_rrset_compare(
        k1: *mut ::std::os::raw::c_void,
        k2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compare two rrset data structures.\n Compared rdata and rrsigdata, not the trust or ttl value.\n @param d1: data to compare.\n @param d2: data to compare.\n @return 1 if equal."]
    pub fn rrsetdata_equal(
        d1: *mut packed_rrset_data,
        d2: *mut packed_rrset_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Old key to be deleted. RRset keys are recycled via alloc.\n The id is set to 0. So that other threads, after acquiring a lock always\n get the correct value, in this case the 0 deleted-special value.\n @param key: struct ub_packed_rrset_key*.\n @param userdata: alloc structure to use for recycling."]
    pub fn ub_rrset_key_delete(
        key: *mut ::std::os::raw::c_void,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Old data to be deleted.\n @param data: what to delete.\n @param userdata: user data ptr."]
    pub fn rrset_data_delete(
        data: *mut ::std::os::raw::c_void,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Calculate hash value for a packed rrset key.\n @param key: the rrset key with name, type, class, flags.\n @return hash value."]
    pub fn rrset_key_hash(key: *mut packed_rrset_key) -> hashvalue_type;
}
extern "C" {
    #[doc = " Fixup pointers in fixed data packed_rrset_data blob.\n After a memcpy of the data for example. Will set internal pointers right.\n @param data: rrset data structure. Otherwise correctly filled in."]
    pub fn packed_rrset_ptr_fixup(data: *mut packed_rrset_data);
}
extern "C" {
    #[doc = " Fixup TTLs in fixed data packed_rrset_data blob.\n @param data: rrset data structure. Otherwise correctly filled in.\n @param add: how many seconds to add, pass time(0) for example."]
    pub fn packed_rrset_ttl_add(data: *mut packed_rrset_data, add: time_t);
}
extern "C" {
    #[doc = " Utility procedure to extract CNAME target name from its rdata.\n Failsafes; it will change passed dname to a valid dname or do nothing.\n @param rrset: the rrset structure. Must be a CNAME.\n\tOnly first RR is used (multiple RRs are technically illegal anyway).\n \tAlso works on type DNAME. Returns target name.\n @param dname: this pointer is updated to point into the cname rdata.\n\tIf a failsafe fails, nothing happens to the pointer (such as the\n\trdata was not a valid dname, not a CNAME, ...).\n @param dname_len: length of dname is returned."]
    pub fn get_cname_target(
        rrset: *mut ub_packed_rrset_key,
        dname: *mut *mut u8,
        dname_len: *mut usize,
    );
}
extern "C" {
    #[doc = " Get a printable string for a rrset trust value\n @param s: rrset trust value\n @return printable string."]
    pub fn rrset_trust_to_string(s: rrset_trust) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a printable string for a security status value\n @param s: security status\n @return printable string."]
    pub fn sec_status_to_string(s: sec_status) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Print string with neat domain name, type, class from rrset.\n @param v: at what verbosity level to print this.\n @param str: string of message.\n @param rrset: structure with name, type and class."]
    pub fn log_rrset_key(
        v: verbosity_value,
        str_: *const ::std::os::raw::c_char,
        rrset: *mut ub_packed_rrset_key,
    );
}
extern "C" {
    #[doc = " Convert RR from RRset to string.\n @param rrset: structure with data.\n @param i: index of rr or RRSIG.\n @param now: time that is subtracted from ttl before printout. Can be 0.\n @param dest: destination string buffer. Must be nonNULL.\n @param dest_len: length of dest buffer (>0).\n @return false on failure."]
    pub fn packed_rr_to_string(
        rrset: *mut ub_packed_rrset_key,
        i: usize,
        now: time_t,
        dest: *mut ::std::os::raw::c_char,
        dest_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Print the string with prefix, one rr per line.\n @param v: at what verbosity level to print this.\n @param str: string of message.\n @param rrset: with name, and rdata, and rrsigs."]
    pub fn log_packed_rrset(
        v: verbosity_value,
        str_: *const ::std::os::raw::c_char,
        rrset: *mut ub_packed_rrset_key,
    );
}
extern "C" {
    #[doc = " Allocate rrset in region - no more locks needed\n @param key: a (just from rrset cache looked up) rrset key + valid,\n \tpacked data record.\n @param region: where to alloc the copy\n @param now: adjust the TTLs to be relative (subtract from all TTLs).\n @return new region-alloced rrset key or NULL on alloc failure."]
    pub fn packed_rrset_copy_region(
        key: *mut ub_packed_rrset_key,
        region: *mut regional,
        now: time_t,
    ) -> *mut ub_packed_rrset_key;
}
extern "C" {
    #[doc = " Allocate rrset with malloc (from region or you are holding the lock).\n @param key: key with data entry.\n @param alloc: alloc_cache to create rrset_keys\n @param now: adjust the TTLs to be absolute (add to all TTLs).\n @return new region-alloced rrset key or NULL on alloc failure."]
    pub fn packed_rrset_copy_alloc(
        key: *mut ub_packed_rrset_key,
        alloc: *mut alloc_cache,
        now: time_t,
    ) -> *mut ub_packed_rrset_key;
}
extern "C" {
    #[doc = " Find RR index in packed rrset\n Raw comparison, does not canonicalize RDATA\n @param d: packed rrset\n @param rdata: RDATA of RR to find\n @param len: length of rdata\n @param index: pointer to int to store index of found RR\n @return 1 if RR found, 0 otherwise"]
    pub fn packed_rrset_find_rr(
        d: *mut packed_rrset_data,
        rdata: *mut u8,
        len: usize,
        index: *mut usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sldns_struct_lookup_table {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " lookuptable for rr classes"]
    pub static mut sldns_rr_classes: *mut sldns_struct_lookup_table;
}
#[doc = " the Internet"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_IN: sldns_enum_rr_class = 1;
#[doc = " Chaos class"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_CH: sldns_enum_rr_class = 3;
#[doc = " Hesiod (Dyer 87)"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_HS: sldns_enum_rr_class = 4;
#[doc = " None class, dynamic update"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_NONE: sldns_enum_rr_class = 254;
#[doc = " Any class"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_ANY: sldns_enum_rr_class = 255;
#[doc = " Any class"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_FIRST: sldns_enum_rr_class = 0;
#[doc = " Any class"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_LAST: sldns_enum_rr_class = 65535;
#[doc = " Any class"]
pub const sldns_enum_rr_class_LDNS_RR_CLASS_COUNT: sldns_enum_rr_class = 65536;
#[doc = "  The different RR classes."]
pub type sldns_enum_rr_class = ::std::os::raw::c_uint;
#[doc = "  The different RR classes."]
pub use self::sldns_enum_rr_class as sldns_rr_class;
#[doc = " compression is allowed"]
pub const sldns_enum_rr_compress_LDNS_RR_COMPRESS: sldns_enum_rr_compress = 0;
#[doc = " compression is allowed"]
pub const sldns_enum_rr_compress_LDNS_RR_NO_COMPRESS: sldns_enum_rr_compress = 1;
#[doc = "  Used to specify whether compression is allowed."]
pub type sldns_enum_rr_compress = ::std::os::raw::c_uint;
#[doc = "  Used to specify whether compression is allowed."]
pub use self::sldns_enum_rr_compress as sldns_rr_compress;
#[doc = "  a host address"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_A: sldns_enum_rr_type = 1;
#[doc = "  an authoritative name server"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NS: sldns_enum_rr_type = 2;
#[doc = "  a mail destination (Obsolete - use MX)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MD: sldns_enum_rr_type = 3;
#[doc = "  a mail forwarder (Obsolete - use MX)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MF: sldns_enum_rr_type = 4;
#[doc = "  the canonical name for an alias"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CNAME: sldns_enum_rr_type = 5;
#[doc = "  marks the start of a zone of authority"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SOA: sldns_enum_rr_type = 6;
#[doc = "  a mailbox domain name (EXPERIMENTAL)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MB: sldns_enum_rr_type = 7;
#[doc = "  a mail group member (EXPERIMENTAL)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MG: sldns_enum_rr_type = 8;
#[doc = "  a mail rename domain name (EXPERIMENTAL)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MR: sldns_enum_rr_type = 9;
#[doc = "  a null RR (EXPERIMENTAL)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NULL: sldns_enum_rr_type = 10;
#[doc = "  a well known service description"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_WKS: sldns_enum_rr_type = 11;
#[doc = "  a domain name pointer"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_PTR: sldns_enum_rr_type = 12;
#[doc = "  host information"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_HINFO: sldns_enum_rr_type = 13;
#[doc = "  mailbox or mail list information"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MINFO: sldns_enum_rr_type = 14;
#[doc = "  mail exchange"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MX: sldns_enum_rr_type = 15;
#[doc = "  text strings"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TXT: sldns_enum_rr_type = 16;
#[doc = "  RFC1183"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_RP: sldns_enum_rr_type = 17;
#[doc = "  RFC1183"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_AFSDB: sldns_enum_rr_type = 18;
#[doc = "  RFC1183"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_X25: sldns_enum_rr_type = 19;
#[doc = "  RFC1183"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_ISDN: sldns_enum_rr_type = 20;
#[doc = "  RFC1183"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_RT: sldns_enum_rr_type = 21;
#[doc = "  RFC1706"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSAP: sldns_enum_rr_type = 22;
#[doc = "  RFC1348"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSAP_PTR: sldns_enum_rr_type = 23;
#[doc = "  2535typecode"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SIG: sldns_enum_rr_type = 24;
#[doc = "  2535typecode"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_KEY: sldns_enum_rr_type = 25;
#[doc = "  RFC2163"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_PX: sldns_enum_rr_type = 26;
#[doc = "  RFC1712"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_GPOS: sldns_enum_rr_type = 27;
#[doc = "  ipv6 address"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_AAAA: sldns_enum_rr_type = 28;
#[doc = "  LOC record  RFC1876"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_LOC: sldns_enum_rr_type = 29;
#[doc = "  2535typecode"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NXT: sldns_enum_rr_type = 30;
#[doc = "  draft-ietf-nimrod-dns-01.txt"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_EID: sldns_enum_rr_type = 31;
#[doc = "  draft-ietf-nimrod-dns-01.txt"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NIMLOC: sldns_enum_rr_type = 32;
#[doc = "  SRV record RFC2782"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SRV: sldns_enum_rr_type = 33;
#[doc = "  http://www.jhsoft.com/rfc/af-saa-0069.000.rtf"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_ATMA: sldns_enum_rr_type = 34;
#[doc = "  RFC2915"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NAPTR: sldns_enum_rr_type = 35;
#[doc = "  RFC2230"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_KX: sldns_enum_rr_type = 36;
#[doc = "  RFC2538"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CERT: sldns_enum_rr_type = 37;
#[doc = "  RFC2874"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_A6: sldns_enum_rr_type = 38;
#[doc = "  RFC2672"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_DNAME: sldns_enum_rr_type = 39;
#[doc = "  dnsind-kitchen-sink-02.txt"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SINK: sldns_enum_rr_type = 40;
#[doc = "  Pseudo OPT record..."]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_OPT: sldns_enum_rr_type = 41;
#[doc = "  RFC3123"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_APL: sldns_enum_rr_type = 42;
#[doc = "  RFC4034, RFC3658"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_DS: sldns_enum_rr_type = 43;
#[doc = "  SSH Key Fingerprint"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SSHFP: sldns_enum_rr_type = 44;
#[doc = "  IPsec Key"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_IPSECKEY: sldns_enum_rr_type = 45;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_RRSIG: sldns_enum_rr_type = 46;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSEC: sldns_enum_rr_type = 47;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_DNSKEY: sldns_enum_rr_type = 48;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_DHCID: sldns_enum_rr_type = 49;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSEC3: sldns_enum_rr_type = 50;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSEC3PARAM: sldns_enum_rr_type = 51;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NSEC3PARAMS: sldns_enum_rr_type = 51;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TLSA: sldns_enum_rr_type = 52;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SMIMEA: sldns_enum_rr_type = 53;
#[doc = "  DNSSEC"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_HIP: sldns_enum_rr_type = 55;
#[doc = " draft-reid-dnsext-zs"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NINFO: sldns_enum_rr_type = 56;
#[doc = " draft-reid-dnsext-rkey"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_RKEY: sldns_enum_rr_type = 57;
#[doc = " draft-ietf-dnsop-trust-history"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TALINK: sldns_enum_rr_type = 58;
#[doc = " draft-ietf-dnsop-trust-history"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CDS: sldns_enum_rr_type = 59;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CDNSKEY: sldns_enum_rr_type = 60;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_OPENPGPKEY: sldns_enum_rr_type = 61;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CSYNC: sldns_enum_rr_type = 62;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_ZONEMD: sldns_enum_rr_type = 63;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SVCB: sldns_enum_rr_type = 64;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_HTTPS: sldns_enum_rr_type = 65;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_SPF: sldns_enum_rr_type = 99;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_UINFO: sldns_enum_rr_type = 100;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_UID: sldns_enum_rr_type = 101;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_GID: sldns_enum_rr_type = 102;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_UNSPEC: sldns_enum_rr_type = 103;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_NID: sldns_enum_rr_type = 104;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_L32: sldns_enum_rr_type = 105;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_L64: sldns_enum_rr_type = 106;
#[doc = " RFC 7344"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_LP: sldns_enum_rr_type = 107;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_EUI48: sldns_enum_rr_type = 108;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_EUI64: sldns_enum_rr_type = 109;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TKEY: sldns_enum_rr_type = 249;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TSIG: sldns_enum_rr_type = 250;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_IXFR: sldns_enum_rr_type = 251;
#[doc = " draft-jabley-dnsext-eui48-eui64-rrtypes"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_AXFR: sldns_enum_rr_type = 252;
#[doc = "  A request for mailbox-related records (MB, MG or MR)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MAILB: sldns_enum_rr_type = 253;
#[doc = "  A request for mail agent RRs (Obsolete - see MX)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_MAILA: sldns_enum_rr_type = 254;
#[doc = "  any type (wildcard)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_ANY: sldns_enum_rr_type = 255;
#[doc = "  any type (wildcard)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_URI: sldns_enum_rr_type = 256;
#[doc = "  any type (wildcard)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_CAA: sldns_enum_rr_type = 257;
#[doc = "  any type (wildcard)"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_AVC: sldns_enum_rr_type = 258;
#[doc = " DNSSEC Trust Authorities"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_TA: sldns_enum_rr_type = 32768;
#[doc = " DNSSEC Trust Authorities"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_DLV: sldns_enum_rr_type = 32769;
#[doc = " DNSSEC Trust Authorities"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_FIRST: sldns_enum_rr_type = 0;
#[doc = " DNSSEC Trust Authorities"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_LAST: sldns_enum_rr_type = 65535;
#[doc = " DNSSEC Trust Authorities"]
pub const sldns_enum_rr_type_LDNS_RR_TYPE_COUNT: sldns_enum_rr_type = 65536;
#[doc = " The different RR types."]
pub type sldns_enum_rr_type = ::std::os::raw::c_uint;
#[doc = " The different RR types."]
pub use self::sldns_enum_rr_type as sldns_rr_type;
#[doc = " none"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_NONE: sldns_enum_rdf_type = 0;
#[doc = " domain name"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_DNAME: sldns_enum_rdf_type = 1;
#[doc = " 8 bits"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_INT8: sldns_enum_rdf_type = 2;
#[doc = " 16 bits"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_INT16: sldns_enum_rdf_type = 3;
#[doc = " 32 bits"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_INT32: sldns_enum_rdf_type = 4;
#[doc = " A record"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_A: sldns_enum_rdf_type = 5;
#[doc = " AAAA record"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_AAAA: sldns_enum_rdf_type = 6;
#[doc = " txt string"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_STR: sldns_enum_rdf_type = 7;
#[doc = " apl data"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_APL: sldns_enum_rdf_type = 8;
#[doc = " b32 string"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_B32_EXT: sldns_enum_rdf_type = 9;
#[doc = " b64 string"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_B64: sldns_enum_rdf_type = 10;
#[doc = " hex string"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_HEX: sldns_enum_rdf_type = 11;
#[doc = " nsec type codes"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_NSEC: sldns_enum_rdf_type = 12;
#[doc = " a RR type"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_TYPE: sldns_enum_rdf_type = 13;
#[doc = " a class"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_CLASS: sldns_enum_rdf_type = 14;
#[doc = " certificate algorithm"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_CERT_ALG: sldns_enum_rdf_type = 15;
#[doc = " a key algorithm"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_ALG: sldns_enum_rdf_type = 16;
#[doc = " unknown types"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_UNKNOWN: sldns_enum_rdf_type = 17;
#[doc = " time (32 bits)"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_TIME: sldns_enum_rdf_type = 18;
#[doc = " period"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_PERIOD: sldns_enum_rdf_type = 19;
#[doc = " tsig time 48 bits"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_TSIGTIME: sldns_enum_rdf_type = 20;
#[doc = " Represents the Public Key Algorithm, HIT and Public Key fields\nfor the HIP RR types.  A HIP specific rdf type is used because of\nthe unusual layout in wireformat (see RFC 5205 Section 5)"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_HIP: sldns_enum_rdf_type = 21;
#[doc = " variable length any type rdata where the length\nis specified by the first 2 bytes"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_INT16_DATA: sldns_enum_rdf_type = 22;
#[doc = " protocol and port bitmaps"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_SERVICE: sldns_enum_rdf_type = 23;
#[doc = " location data"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_LOC: sldns_enum_rdf_type = 24;
#[doc = " well known services"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_WKS: sldns_enum_rdf_type = 25;
#[doc = " NSAP"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_NSAP: sldns_enum_rdf_type = 26;
#[doc = " ATMA"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_ATMA: sldns_enum_rdf_type = 27;
#[doc = " IPSECKEY"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_IPSECKEY: sldns_enum_rdf_type = 28;
#[doc = " nsec3 hash salt"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_NSEC3_SALT: sldns_enum_rdf_type = 29;
#[doc = " nsec3 base32 string (with length byte on wire"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_NSEC3_NEXT_OWNER: sldns_enum_rdf_type = 30;
#[doc = " 4 shorts represented as 4 * 16 bit hex numbers\n  separated by colons. For NID and L64."]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_ILNP64: sldns_enum_rdf_type = 31;
#[doc = " 6 * 8 bit hex numbers separated by dashes. For EUI48."]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_EUI48: sldns_enum_rdf_type = 32;
#[doc = " 8 * 8 bit hex numbers separated by dashes. For EUI64."]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_EUI64: sldns_enum_rdf_type = 33;
#[doc = " A non-zero sequence of US-ASCII letters and numbers in lower case.\n  For CAA."]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_TAG: sldns_enum_rdf_type = 34;
#[doc = " A <character-string> encoding of the value field as specified\n [RFC1035], Section 5.1., encoded as remaining rdata.\n For CAA, URI."]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_LONG_STR: sldns_enum_rdf_type = 35;
#[doc = " TSIG extended 16bit error value"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_TSIGERROR: sldns_enum_rdf_type = 36;
#[doc = " TSIG extended 16bit error value"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_SVCPARAM: sldns_enum_rdf_type = 37;
#[doc = " TSIG extended 16bit error value"]
pub const sldns_enum_rdf_type_LDNS_RDF_TYPE_BITMAP: sldns_enum_rdf_type = 12;
#[doc = " The different types of RDATA fields."]
pub type sldns_enum_rdf_type = ::std::os::raw::c_uint;
#[doc = " The different types of RDATA fields."]
pub use self::sldns_enum_rdf_type as sldns_rdf_type;
pub const sldns_enum_algorithm_LDNS_RSAMD5: sldns_enum_algorithm = 1;
pub const sldns_enum_algorithm_LDNS_DH: sldns_enum_algorithm = 2;
pub const sldns_enum_algorithm_LDNS_DSA: sldns_enum_algorithm = 3;
pub const sldns_enum_algorithm_LDNS_ECC: sldns_enum_algorithm = 4;
pub const sldns_enum_algorithm_LDNS_RSASHA1: sldns_enum_algorithm = 5;
pub const sldns_enum_algorithm_LDNS_DSA_NSEC3: sldns_enum_algorithm = 6;
pub const sldns_enum_algorithm_LDNS_RSASHA1_NSEC3: sldns_enum_algorithm = 7;
pub const sldns_enum_algorithm_LDNS_RSASHA256: sldns_enum_algorithm = 8;
pub const sldns_enum_algorithm_LDNS_RSASHA512: sldns_enum_algorithm = 10;
pub const sldns_enum_algorithm_LDNS_ECC_GOST: sldns_enum_algorithm = 12;
pub const sldns_enum_algorithm_LDNS_ECDSAP256SHA256: sldns_enum_algorithm = 13;
pub const sldns_enum_algorithm_LDNS_ECDSAP384SHA384: sldns_enum_algorithm = 14;
pub const sldns_enum_algorithm_LDNS_ED25519: sldns_enum_algorithm = 15;
pub const sldns_enum_algorithm_LDNS_ED448: sldns_enum_algorithm = 16;
pub const sldns_enum_algorithm_LDNS_INDIRECT: sldns_enum_algorithm = 252;
pub const sldns_enum_algorithm_LDNS_PRIVATEDNS: sldns_enum_algorithm = 253;
pub const sldns_enum_algorithm_LDNS_PRIVATEOID: sldns_enum_algorithm = 254;
#[doc = " Algorithms used in dns"]
pub type sldns_enum_algorithm = ::std::os::raw::c_uint;
#[doc = " Algorithms used in dns"]
pub use self::sldns_enum_algorithm as sldns_algorithm;
pub const sldns_enum_hash_LDNS_SHA1: sldns_enum_hash = 1;
pub const sldns_enum_hash_LDNS_SHA256: sldns_enum_hash = 2;
pub const sldns_enum_hash_LDNS_HASH_GOST: sldns_enum_hash = 3;
pub const sldns_enum_hash_LDNS_SHA384: sldns_enum_hash = 4;
#[doc = " Hashing algorithms used in the DS record"]
pub type sldns_enum_hash = ::std::os::raw::c_uint;
#[doc = " Hashing algorithms used in the DS record"]
pub use self::sldns_enum_hash as sldns_hash;
pub const sldns_enum_cert_algorithm_LDNS_CERT_PKIX: sldns_enum_cert_algorithm = 1;
pub const sldns_enum_cert_algorithm_LDNS_CERT_SPKI: sldns_enum_cert_algorithm = 2;
pub const sldns_enum_cert_algorithm_LDNS_CERT_PGP: sldns_enum_cert_algorithm = 3;
pub const sldns_enum_cert_algorithm_LDNS_CERT_IPKIX: sldns_enum_cert_algorithm = 4;
pub const sldns_enum_cert_algorithm_LDNS_CERT_ISPKI: sldns_enum_cert_algorithm = 5;
pub const sldns_enum_cert_algorithm_LDNS_CERT_IPGP: sldns_enum_cert_algorithm = 6;
pub const sldns_enum_cert_algorithm_LDNS_CERT_ACPKIX: sldns_enum_cert_algorithm = 7;
pub const sldns_enum_cert_algorithm_LDNS_CERT_IACPKIX: sldns_enum_cert_algorithm = 8;
pub const sldns_enum_cert_algorithm_LDNS_CERT_URI: sldns_enum_cert_algorithm = 253;
pub const sldns_enum_cert_algorithm_LDNS_CERT_OID: sldns_enum_cert_algorithm = 254;
#[doc = " algorithms used in CERT rrs"]
pub type sldns_enum_cert_algorithm = ::std::os::raw::c_uint;
#[doc = " algorithms used in CERT rrs"]
pub use self::sldns_enum_cert_algorithm as sldns_cert_algorithm;
pub const sldns_enum_edns_option_LDNS_EDNS_LLQ: sldns_enum_edns_option = 1;
pub const sldns_enum_edns_option_LDNS_EDNS_UL: sldns_enum_edns_option = 2;
pub const sldns_enum_edns_option_LDNS_EDNS_NSID: sldns_enum_edns_option = 3;
pub const sldns_enum_edns_option_LDNS_EDNS_DAU: sldns_enum_edns_option = 5;
pub const sldns_enum_edns_option_LDNS_EDNS_DHU: sldns_enum_edns_option = 6;
pub const sldns_enum_edns_option_LDNS_EDNS_N3U: sldns_enum_edns_option = 7;
pub const sldns_enum_edns_option_LDNS_EDNS_CLIENT_SUBNET: sldns_enum_edns_option = 8;
pub const sldns_enum_edns_option_LDNS_EDNS_COOKIE: sldns_enum_edns_option = 10;
pub const sldns_enum_edns_option_LDNS_EDNS_KEEPALIVE: sldns_enum_edns_option = 11;
pub const sldns_enum_edns_option_LDNS_EDNS_PADDING: sldns_enum_edns_option = 12;
pub const sldns_enum_edns_option_LDNS_EDNS_EDE: sldns_enum_edns_option = 15;
pub const sldns_enum_edns_option_LDNS_EDNS_CLIENT_TAG: sldns_enum_edns_option = 16;
pub const sldns_enum_edns_option_LDNS_EDNS_UNBOUND_CACHEDB_TESTFRAME_TEST: sldns_enum_edns_option =
    65534;
#[doc = " EDNS option codes"]
pub type sldns_enum_edns_option = ::std::os::raw::c_uint;
#[doc = " EDNS option codes"]
pub use self::sldns_enum_edns_option as sldns_edns_option;
pub const sldns_enum_ede_code_LDNS_EDE_NONE: sldns_enum_ede_code = -1;
pub const sldns_enum_ede_code_LDNS_EDE_OTHER: sldns_enum_ede_code = 0;
pub const sldns_enum_ede_code_LDNS_EDE_UNSUPPORTED_DNSKEY_ALG: sldns_enum_ede_code = 1;
pub const sldns_enum_ede_code_LDNS_EDE_UNSUPPORTED_DS_DIGEST: sldns_enum_ede_code = 2;
pub const sldns_enum_ede_code_LDNS_EDE_STALE_ANSWER: sldns_enum_ede_code = 3;
pub const sldns_enum_ede_code_LDNS_EDE_FORGED_ANSWER: sldns_enum_ede_code = 4;
pub const sldns_enum_ede_code_LDNS_EDE_DNSSEC_INDETERMINATE: sldns_enum_ede_code = 5;
pub const sldns_enum_ede_code_LDNS_EDE_DNSSEC_BOGUS: sldns_enum_ede_code = 6;
pub const sldns_enum_ede_code_LDNS_EDE_SIGNATURE_EXPIRED: sldns_enum_ede_code = 7;
pub const sldns_enum_ede_code_LDNS_EDE_SIGNATURE_NOT_YET_VALID: sldns_enum_ede_code = 8;
pub const sldns_enum_ede_code_LDNS_EDE_DNSKEY_MISSING: sldns_enum_ede_code = 9;
pub const sldns_enum_ede_code_LDNS_EDE_RRSIGS_MISSING: sldns_enum_ede_code = 10;
pub const sldns_enum_ede_code_LDNS_EDE_NO_ZONE_KEY_BIT_SET: sldns_enum_ede_code = 11;
pub const sldns_enum_ede_code_LDNS_EDE_NSEC_MISSING: sldns_enum_ede_code = 12;
pub const sldns_enum_ede_code_LDNS_EDE_CACHED_ERROR: sldns_enum_ede_code = 13;
pub const sldns_enum_ede_code_LDNS_EDE_NOT_READY: sldns_enum_ede_code = 14;
pub const sldns_enum_ede_code_LDNS_EDE_BLOCKED: sldns_enum_ede_code = 15;
pub const sldns_enum_ede_code_LDNS_EDE_CENSORED: sldns_enum_ede_code = 16;
pub const sldns_enum_ede_code_LDNS_EDE_FILTERED: sldns_enum_ede_code = 17;
pub const sldns_enum_ede_code_LDNS_EDE_PROHIBITED: sldns_enum_ede_code = 18;
pub const sldns_enum_ede_code_LDNS_EDE_STALE_NXDOMAIN_ANSWER: sldns_enum_ede_code = 19;
pub const sldns_enum_ede_code_LDNS_EDE_NOT_AUTHORITATIVE: sldns_enum_ede_code = 20;
pub const sldns_enum_ede_code_LDNS_EDE_NOT_SUPPORTED: sldns_enum_ede_code = 21;
pub const sldns_enum_ede_code_LDNS_EDE_NO_REACHABLE_AUTHORITY: sldns_enum_ede_code = 22;
pub const sldns_enum_ede_code_LDNS_EDE_NETWORK_ERROR: sldns_enum_ede_code = 23;
pub const sldns_enum_ede_code_LDNS_EDE_INVALID_DATA: sldns_enum_ede_code = 24;
pub type sldns_enum_ede_code = ::std::os::raw::c_int;
pub use self::sldns_enum_ede_code as sldns_ede_code;
#[doc = " Contains all information about resource record types.\n\n This structure contains, for all rr types, the rdata fields that are defined."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sldns_struct_rr_descriptor {
    #[doc = " Type of the RR that is described here"]
    pub _type: sldns_rr_type,
    #[doc = " Textual name of the RR type."]
    pub _name: *const ::std::os::raw::c_char,
    #[doc = " Minimum number of rdata fields in the RRs of this type."]
    pub _minimum: u8,
    #[doc = " Maximum number of rdata fields in the RRs of this type."]
    pub _maximum: u8,
    #[doc = " Wireformat specification for the rr, i.e. the types of rdata fields in their respective order."]
    pub _wireformat: *const sldns_rdf_type,
    #[doc = " Special rdf types"]
    pub _variable: sldns_rdf_type,
    #[doc = " Specifies whether compression can be used for dnames in this RR type."]
    pub _compress: sldns_rr_compress,
    #[doc = " The number of DNAMEs in the _wireformat string, for parsing."]
    pub _dname_count: u8,
}
#[test]
fn bindgen_test_layout_sldns_struct_rr_descriptor() {
    const UNINIT: ::std::mem::MaybeUninit<sldns_struct_rr_descriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sldns_struct_rr_descriptor>(),
        48usize,
        concat!("Size of: ", stringify!(sldns_struct_rr_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<sldns_struct_rr_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(sldns_struct_rr_descriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_struct_rr_descriptor),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_struct_rr_descriptor),
            "::",
            stringify!(_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._minimum) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_struct_rr_descriptor),
            "::",
            stringify!(_minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._maximum) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_struct_rr_descriptor),
            "::",
            stringify!(_maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wireformat) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_struct_rr_descriptor),
            "::",
            stringify!(_wireformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._variable) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_struct_rr_descriptor),
            "::",
            stringify!(_variable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._compress) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_struct_rr_descriptor),
            "::",
            stringify!(_compress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dname_count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_struct_rr_descriptor),
            "::",
            stringify!(_dname_count)
        )
    );
}
#[doc = " Contains all information about resource record types.\n\n This structure contains, for all rr types, the rdata fields that are defined."]
pub type sldns_rr_descriptor = sldns_struct_rr_descriptor;
extern "C" {
    #[doc = " returns the resource record descriptor for the given rr type.\n\n \\param[in] type the type value of the rr type\n\\return the sldns_rr_descriptor for this type"]
    pub fn sldns_rr_descript(type_: u16) -> *const sldns_rr_descriptor;
}
extern "C" {
    #[doc = " returns the minimum number of rdata fields of the rr type this descriptor describes.\n\n \\param[in]  descriptor for an rr type\n \\return the minimum number of rdata fields"]
    pub fn sldns_rr_descriptor_minimum(descriptor: *const sldns_rr_descriptor) -> usize;
}
extern "C" {
    #[doc = " returns the maximum number of rdata fields of the rr type this descriptor describes.\n\n \\param[in]  descriptor for an rr type\n \\return the maximum number of rdata fields"]
    pub fn sldns_rr_descriptor_maximum(descriptor: *const sldns_rr_descriptor) -> usize;
}
extern "C" {
    #[doc = " returns the rdf type for the given rdata field number of the rr type for the given descriptor.\n\n \\param[in] descriptor for an rr type\n \\param[in] field the field number\n \\return the rdf type for the field"]
    pub fn sldns_rr_descriptor_field_type(
        descriptor: *const sldns_rr_descriptor,
        field: usize,
    ) -> sldns_rdf_type;
}
extern "C" {
    #[doc = " retrieves a rrtype by looking up its name.\n \\param[in] name a string with the name\n \\return the type which corresponds with the name"]
    pub fn sldns_get_rr_type_by_name(name: *const ::std::os::raw::c_char) -> sldns_rr_type;
}
extern "C" {
    #[doc = " retrieves a class by looking up its name.\n \\param[in] name string with the name\n \\return the cass which corresponds with the name"]
    pub fn sldns_get_rr_class_by_name(name: *const ::std::os::raw::c_char) -> sldns_rr_class;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comm_reply {
    _unused: [u8; 0],
}
pub type comm_point_type = i32;
#[doc = " Structure to store query information that makes answers to queries\n different."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct query_info {
    #[doc = " Salient data on the query: qname, in wireformat.\n can be allocated or a pointer to outside buffer.\n User has to keep track on the status of this."]
    pub qname: *mut u8,
    #[doc = " length of qname (including last 0 octet)"]
    pub qname_len: usize,
    #[doc = " qtype, host byte order"]
    pub qtype: u16,
    #[doc = " qclass, host byte order"]
    pub qclass: u16,
    #[doc = " Alias local answer(s) for the qname.  If 'qname' is an alias defined\n in a local zone, this field will be set to the corresponding local\n RRset when the alias is determined.\n In the initial implementation this can only be a single CNAME RR\n (or NULL), but it could possibly be extended to be a DNAME or a\n chain of aliases.\n Users of this structure are responsible to initialize this field\n to be NULL; otherwise other part of query handling code may be\n confused.\n Users also have to be careful about the lifetime of data.  On return\n from local zone lookup, it may point to data derived from\n configuration that may be dynamically invalidated or data allocated\n in an ephemeral regional allocator.  A deep copy of the data may\n have to be generated if it has to be kept during iterative\n resolution."]
    pub local_alias: *mut local_rrset,
}
#[test]
fn bindgen_test_layout_query_info() {
    const UNINIT: ::std::mem::MaybeUninit<query_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<query_info>(),
        32usize,
        concat!("Size of: ", stringify!(query_info))
    );
    assert_eq!(
        ::std::mem::align_of::<query_info>(),
        8usize,
        concat!("Alignment of ", stringify!(query_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qname) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(query_info),
            "::",
            stringify!(qname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qname_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(query_info),
            "::",
            stringify!(qname_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qtype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(query_info),
            "::",
            stringify!(qtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qclass) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(query_info),
            "::",
            stringify!(qclass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_alias) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(query_info),
            "::",
            stringify!(local_alias)
        )
    );
}
#[doc = " Information to reference an rrset"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rrset_ref {
    #[doc = " the key with lock, and ptr to packed data."]
    pub key: *mut ub_packed_rrset_key,
    #[doc = " id needed"]
    pub id: rrset_id_type,
}
#[test]
fn bindgen_test_layout_rrset_ref() {
    const UNINIT: ::std::mem::MaybeUninit<rrset_ref> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rrset_ref>(),
        16usize,
        concat!("Size of: ", stringify!(rrset_ref))
    );
    assert_eq!(
        ::std::mem::align_of::<rrset_ref>(),
        8usize,
        concat!("Alignment of ", stringify!(rrset_ref))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_ref),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_ref),
            "::",
            stringify!(id)
        )
    );
}
#[doc = " Structure to store DNS query and the reply packet.\n To use it, copy over the flags from reply and modify using flags from\n the query (RD,CD if not AA). prepend ID.\n\n Memory layout is:\n\to struct\n\to rrset_ref array\n\to packed_rrset_key* array.\n\n Memory layout is sometimes not packed, when the message is synthesized,\n for easy of the generation. It is allocated packed when it is copied\n from the region allocation to the malloc allocation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reply_info {
    #[doc = " the flags for the answer, host byte order."]
    pub flags: u16,
    #[doc = " This flag informs unbound the answer is authoritative and\n the AA flag should be preserved."]
    pub authoritative: u8,
    #[doc = " Number of RRs in the query section.\n If qdcount is not 0, then it is 1, and the data that appears\n in the reply is the same as the query_info.\n Host byte order."]
    pub qdcount: u8,
    #[doc = " 32 bit padding to pad struct member alignment to 64 bits."]
    pub padding: u32,
    #[doc = " TTL of the entire reply (for negative caching).\n only for use when there are 0 RRsets in this message.\n if there are RRsets, check those instead."]
    pub ttl: time_t,
    #[doc = " TTL for prefetch. After it has expired, a prefetch is suitable.\n Smaller than the TTL, otherwise the prefetch would not happen."]
    pub prefetch_ttl: time_t,
    #[doc = " Reply TTL extended with serve expired TTL, to limit time to serve\n expired message."]
    pub serve_expired_ttl: time_t,
    #[doc = " The security status from DNSSEC validation of this message."]
    pub security: sec_status,
    #[doc = " EDE (rfc8914) code with reason for DNSSEC bogus status.\n Used for caching the EDE."]
    pub reason_bogus: sldns_ede_code,
    #[doc = " EDE (rfc8914) NULL-terminated string with human-readable reason\n for DNSSEC bogus status.\n Used for caching the EDE."]
    pub reason_bogus_str: *mut ::std::os::raw::c_char,
    #[doc = " Number of RRsets in each section.\n The answer section. Add up the RRs in every RRset to calculate\n the number of RRs, and the count for the dns packet.\n The number of RRs in RRsets can change due to RRset updates."]
    pub an_numrrsets: usize,
    #[doc = " Count of authority section RRsets"]
    pub ns_numrrsets: usize,
    #[doc = " Count of additional section RRsets"]
    pub ar_numrrsets: usize,
    #[doc = " number of RRsets: an_numrrsets + ns_numrrsets + ar_numrrsets"]
    pub rrset_count: usize,
    #[doc = " List of pointers (only) to the rrsets in the order in which\n they appear in the reply message.\n Number of elements is ancount+nscount+arcount RRsets.\n This is a pointer to that array.\n Use the accessor function for access."]
    pub rrsets: *mut *mut ub_packed_rrset_key,
    #[doc = " Packed array of ids (see counts) and pointers to packed_rrset_key.\n The number equals ancount+nscount+arcount RRsets.\n These are sorted in ascending pointer, the locking order. So\n this list can be locked (and id, ttl checked), to see if\n all the data is available and recent enough.\n\n This is defined as an array of size 1, so that the compiler\n associates the identifier with this position in the structure.\n Array bound overflow on this array then gives access to the further\n elements of the array, which are allocated after the main structure.\n\n It could be more pure to define as array of size 0, ref[0].\n But ref[1] may be less confusing for compilers.\n Use the accessor function for access."]
    pub ref_: [rrset_ref; 1usize],
}
#[test]
fn bindgen_test_layout_reply_info() {
    const UNINIT: ::std::mem::MaybeUninit<reply_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<reply_info>(),
        104usize,
        concat!("Size of: ", stringify!(reply_info))
    );
    assert_eq!(
        ::std::mem::align_of::<reply_info>(),
        8usize,
        concat!("Alignment of ", stringify!(reply_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authoritative) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(authoritative)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qdcount) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(qdcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefetch_ttl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(prefetch_ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serve_expired_ttl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(serve_expired_ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).security) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason_bogus) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(reason_bogus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason_bogus_str) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(reason_bogus_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).an_numrrsets) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(an_numrrsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns_numrrsets) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(ns_numrrsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_numrrsets) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(ar_numrrsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrset_count) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(rrset_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrsets) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(rrsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(reply_info),
            "::",
            stringify!(ref_)
        )
    );
}
#[doc = " Structure to keep hash table entry for message replies."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msgreply_entry {
    #[doc = " the hash table key"]
    pub key: query_info,
    #[doc = " the hash table entry, data is struct reply_info*"]
    pub entry: lruhash_entry,
}
#[test]
fn bindgen_test_layout_msgreply_entry() {
    const UNINIT: ::std::mem::MaybeUninit<msgreply_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msgreply_entry>(),
        136usize,
        concat!("Size of: ", stringify!(msgreply_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<msgreply_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(msgreply_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msgreply_entry),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msgreply_entry),
            "::",
            stringify!(entry)
        )
    );
}
extern "C" {
    #[doc = " Constructor for replyinfo.\n @param region: where to allocate the results, pass NULL to use malloc.\n @param flags: flags for the replyinfo.\n @param qd: qd count\n @param ttl: TTL of replyinfo\n @param prettl: prefetch ttl\n @param expttl: serve expired ttl\n @param an: an count\n @param ns: ns count\n @param ar: ar count\n @param total: total rrset count (presumably an+ns+ar).\n @param sec: security status of the reply info.\n @param reason_bogus: the Extended DNS Error for DNSSEC bogus status\n @return the reply_info base struct with the array for putting the rrsets\n in.  The array has been zeroed.  Returns NULL on malloc failure."]
    pub fn construct_reply_info_base(
        region: *mut regional,
        flags: u16,
        qd: usize,
        ttl: time_t,
        prettl: time_t,
        expttl: time_t,
        an: usize,
        ns: usize,
        ar: usize,
        total: usize,
        sec: sec_status,
        reason_bogus: sldns_ede_code,
    ) -> *mut reply_info;
}
extern "C" {
    #[doc = " Parse wire query into a queryinfo structure, return 0 on parse error.\n initialises the (prealloced) queryinfo structure as well.\n This query structure contains a pointer back info the buffer!\n This pointer avoids memory allocation. allocqname does memory allocation.\n @param m: the prealloced queryinfo structure to put query into.\n    must be unused, or _clear()ed.\n @param query: the wireformat packet query. starts with ID.\n @return: 0 on format error."]
    pub fn query_info_parse(m: *mut query_info, query: *mut sldns_buffer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse query reply.\n Fills in preallocated query_info structure (with ptr into buffer).\n Allocates reply_info and packed_rrsets. These are not yet added to any\n caches or anything, this is only parsing. Returns formerror on qdcount > 1.\n @param pkt: the packet buffer. Must be positioned after the query section.\n @param alloc: creates packed rrset key structures.\n @param rep: allocated reply_info is returned (only on no error).\n @param qinf: query_info is returned (only on no error).\n @param region: where to store temporary data (for parsing).\n @param edns: where to store edns information, does not need to be inited.\n @return: zero is OK, or DNS error code in case of error\n\to FORMERR for parse errors.\n\to SERVFAIL for memory allocation errors."]
    pub fn reply_info_parse(
        pkt: *mut sldns_buffer,
        alloc: *mut alloc_cache,
        qinf: *mut query_info,
        rep: *mut *mut reply_info,
        region: *mut regional,
        edns: *mut edns_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and decompress parsed message and rrsets.\n @param pkt: for name decompression.\n @param msg: parsed message in scratch region.\n @param alloc: alloc cache for special rrset key structures.\n\tNot used if region!=NULL, it can be NULL in that case.\n @param qinf: where to store query info.\n\tqinf itself is allocated by the caller.\n @param rep: reply info is allocated and returned.\n @param region: if this parameter is NULL then malloc and the alloc is used.\n\totherwise, everything is allocated in this region.\n\tIn a region, no special rrset key structures are needed (not shared),\n\tand no rrset_ref array in the reply is built up.\n @return 0 if allocation failed."]
    pub fn parse_create_msg(
        pkt: *mut sldns_buffer,
        msg: *mut msg_parse,
        alloc: *mut alloc_cache,
        qinf: *mut query_info,
        rep: *mut *mut reply_info,
        region: *mut regional,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get msg reply struct (in temp region)"]
    pub fn parse_reply_in_temp_region(
        pkt: *mut sldns_buffer,
        region: *mut regional,
        qi: *mut query_info,
    ) -> *mut reply_info;
}
extern "C" {
    #[doc = " Sorts the ref array.\n @param rep: reply info. rrsets must be filled in."]
    pub fn reply_info_sortref(rep: *mut reply_info);
}
extern "C" {
    #[doc = " Set TTLs inside the replyinfo to absolute values.\n @param rep: reply info. rrsets must be filled in.\n\tAlso refs must be filled in.\n @param timenow: the current time."]
    pub fn reply_info_set_ttls(rep: *mut reply_info, timenow: time_t);
}
extern "C" {
    #[doc = " Delete reply_info and packed_rrsets (while they are not yet added to the\n hashtables.). Returns rrsets to the alloc cache.\n @param rep: reply_info to delete.\n @param alloc: where to return rrset structures to."]
    pub fn reply_info_parsedelete(rep: *mut reply_info, alloc: *mut alloc_cache);
}
extern "C" {
    #[doc = " Compare two queryinfo structures, on query and type, class.\n It is _not_ sorted in canonical ordering.\n @param m1: struct query_info* , void* here to ease use as function pointer.\n @param m2: struct query_info* , void* here to ease use as function pointer.\n @return: 0 = same, -1 m1 is smaller, +1 m1 is larger."]
    pub fn query_info_compare(
        m1: *mut ::std::os::raw::c_void,
        m2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " clear out query info structure"]
    pub fn query_info_clear(m: *mut query_info);
}
extern "C" {
    #[doc = " calculate size of struct query_info + reply_info"]
    pub fn msgreply_sizefunc(
        k: *mut ::std::os::raw::c_void,
        d: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " delete msgreply_entry key structure"]
    pub fn query_entry_delete(q: *mut ::std::os::raw::c_void, arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " delete reply_info data structure"]
    pub fn reply_info_delete(d: *mut ::std::os::raw::c_void, arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " calculate hash value of query_info, lowercases the qname,\n uses CD flag for AAAA qtype"]
    pub fn query_info_hash(q: *mut query_info, flags: u16) -> hashvalue_type;
}
extern "C" {
    #[doc = " Setup query info entry\n @param q: query info to copy. Emptied as if clear is called.\n @param r: reply to init data.\n @param h: hash value.\n @return: newly allocated message reply cache item."]
    pub fn query_info_entrysetup(
        q: *mut query_info,
        r: *mut reply_info,
        h: hashvalue_type,
    ) -> *mut msgreply_entry;
}
extern "C" {
    #[doc = " Copy reply_info and all rrsets in it and allocate.\n @param rep: what to copy, probably inside region, no ref[] array in it.\n @param alloc: how to allocate rrset keys.\n\tNot used if region!=NULL, it can be NULL in that case.\n @param region: if this parameter is NULL then malloc and the alloc is used.\n\totherwise, everything is allocated in this region.\n\tIn a region, no special rrset key structures are needed (not shared),\n\tand no rrset_ref array in the reply is built up.\n @return new reply info or NULL on memory error."]
    pub fn reply_info_copy(
        rep: *mut reply_info,
        alloc: *mut alloc_cache,
        region: *mut regional,
    ) -> *mut reply_info;
}
extern "C" {
    #[doc = " Allocate (special) rrset keys.\n @param rep: reply info in which the rrset keys to be allocated, rrset[]\n\tarray should have bee allocated with NULL pointers.\n @param alloc: how to allocate rrset keys.\n\tNot used if region!=NULL, it can be NULL in that case.\n @param region: if this parameter is NULL then the alloc is used.\n\totherwise, rrset keys are allocated in this region.\n\tIn a region, no special rrset key structures are needed (not shared).\n\tand no rrset_ref array in the reply needs to be built up.\n @return 1 on success, 0 on error"]
    pub fn reply_info_alloc_rrset_keys(
        rep: *mut reply_info,
        alloc: *mut alloc_cache,
        region: *mut regional,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn make_new_reply_info(
        rep: *const reply_info,
        region: *mut regional,
        an_numrrsets: usize,
        copy_rrsets: usize,
    ) -> *mut reply_info;
}
extern "C" {
    #[doc = " Copy a parsed rrset into given key, decompressing and allocating rdata.\n @param pkt: packet for decompression\n @param msg: the parser message (for flags for trust).\n @param pset: the parsed rrset to copy.\n @param region: if NULL - malloc, else data is allocated in this region.\n @param pk: a freshly obtained rrsetkey structure. No dname is set yet,\n\twill be set on return.\n\tNote that TTL will still be relative on return.\n @return false on alloc failure."]
    pub fn parse_copy_decompress_rrset(
        pkt: *mut sldns_buffer,
        msg: *mut msg_parse,
        pset: *mut rrset_parse,
        region: *mut regional,
        pk: *mut ub_packed_rrset_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find final cname target in reply, the one matching qinfo. Follows CNAMEs.\n @param qinfo: what to start with.\n @param rep: looks in answer section of this message.\n @return: pointer dname, or NULL if not found."]
    pub fn reply_find_final_cname_target(qinfo: *mut query_info, rep: *mut reply_info) -> *mut u8;
}
extern "C" {
    #[doc = " Check if cname chain in cached reply is still valid.\n @param qinfo: query info with query name.\n @param rep: reply to check.\n @return: true if valid, false if invalid."]
    pub fn reply_check_cname_chain(
        qinfo: *mut query_info,
        rep: *mut reply_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check security status of all RRs in the message.\n @param rep: reply to check\n @return: true if all RRs are secure. False if not.\n    True if there are zero RRs."]
    pub fn reply_all_rrsets_secure(rep: *mut reply_info) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find answer rrset in reply, the one matching qinfo. Follows CNAMEs, so the\n result may have a different owner name.\n @param qinfo: what to look for.\n @param rep: looks in answer section of this message.\n @return: pointer to rrset, or NULL if not found."]
    pub fn reply_find_answer_rrset(
        qinfo: *mut query_info,
        rep: *mut reply_info,
    ) -> *mut ub_packed_rrset_key;
}
extern "C" {
    #[doc = " Find rrset in reply, inside the answer section. Does not follow CNAMEs.\n @param rep: looks in answer section of this message.\n @param name: what to look for.\n @param namelen: length of name.\n @param type: looks for (host order).\n @param dclass: looks for (host order).\n @return: pointer to rrset, or NULL if not found."]
    pub fn reply_find_rrset_section_an(
        rep: *mut reply_info,
        name: *mut u8,
        namelen: usize,
        type_: u16,
        dclass: u16,
    ) -> *mut ub_packed_rrset_key;
}
extern "C" {
    #[doc = " Find rrset in reply, inside the authority section. Does not follow CNAMEs.\n @param rep: looks in authority section of this message.\n @param name: what to look for.\n @param namelen: length of name.\n @param type: looks for (host order).\n @param dclass: looks for (host order).\n @return: pointer to rrset, or NULL if not found."]
    pub fn reply_find_rrset_section_ns(
        rep: *mut reply_info,
        name: *mut u8,
        namelen: usize,
        type_: u16,
        dclass: u16,
    ) -> *mut ub_packed_rrset_key;
}
extern "C" {
    #[doc = " Find rrset in reply, inside any section. Does not follow CNAMEs.\n @param rep: looks in answer,authority and additional section of this message.\n @param name: what to look for.\n @param namelen: length of name.\n @param type: looks for (host order).\n @param dclass: looks for (host order).\n @return: pointer to rrset, or NULL if not found."]
    pub fn reply_find_rrset(
        rep: *mut reply_info,
        name: *mut u8,
        namelen: usize,
        type_: u16,
        dclass: u16,
    ) -> *mut ub_packed_rrset_key;
}
extern "C" {
    #[doc = " Debug send the query info and reply info to the log in readable form.\n @param str: descriptive string printed with packet content.\n @param qinfo: query section.\n @param rep: rest of message."]
    pub fn log_dns_msg(
        str_: *const ::std::os::raw::c_char,
        qinfo: *mut query_info,
        rep: *mut reply_info,
    );
}
extern "C" {
    #[doc = " Print string with neat domain name, type, class,\n status code from, and size of a query response.\n\n @param v: at what verbosity level to print this.\n @param qinf: query section.\n @param addr: address of the client.\n @param addrlen: length of the client address.\n @param dur: how long it took to complete the query.\n @param cached: whether or not the reply is coming from\n                    the cache, or an outside network.\n @param rmsg: sldns buffer packet.\n @param daddr: if not NULL, the destination address and port are logged.\n @param tp: type of the comm point for logging destination connection type."]
    pub fn log_reply_info(
        v: verbosity_value,
        qinf: *mut query_info,
        addr: *mut sockaddr_storage,
        addrlen: socklen_t,
        dur: timeval,
        cached: ::std::os::raw::c_int,
        rmsg: *mut sldns_buffer,
        daddr: *mut sockaddr_storage,
        tp: comm_point_type,
    );
}
extern "C" {
    #[doc = " Print string with neat domain name, type, class from query info.\n @param v: at what verbosity level to print this.\n @param str: string of message.\n @param qinf: query info structure with name, type and class."]
    pub fn log_query_info(
        v: verbosity_value,
        str_: *const ::std::os::raw::c_char,
        qinf: *mut query_info,
    );
}
extern "C" {
    #[doc = " Append edns option to edns option list\n @param list: the edns option list to append the edns option to.\n @param code: the edns option's code.\n @param len: the edns option's length.\n @param data: the edns option's data.\n @param region: region to allocate the new edns option.\n @return false on failure."]
    pub fn edns_opt_list_append(
        list: *mut *mut edns_option,
        code: u16,
        len: usize,
        data: *mut u8,
        region: *mut regional,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append edns EDE option to edns options list\n @param list: the edns option list to append the edns option to.\n @param region: region to allocate the new edns option.\n @param code: the EDE code.\n @param txt: Additional text for the option\n @return false on failure."]
    pub fn edns_opt_list_append_ede(
        list: *mut *mut edns_option,
        region: *mut regional,
        code: sldns_ede_code,
        txt: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append edns keep alive option to edns options list\n @param list: the edns option list to append the edns option to.\n @param msec: the duration in msecs for the keep alive.\n @param region: region to allocate the new edns option.\n @return false on failure."]
    pub fn edns_opt_list_append_keepalive(
        list: *mut *mut edns_option,
        msec: ::std::os::raw::c_int,
        region: *mut regional,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove any option found on the edns option list that matches the code.\n @param list: the list of edns options.\n @param code: the opt code to remove.\n @return true when at least one edns option was removed, false otherwise."]
    pub fn edns_opt_list_remove(list: *mut *mut edns_option, code: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find edns option in edns list\n @param list: list of edns options (eg. edns.opt_list)\n @param code: opt code to find.\n @return NULL or the edns_option element."]
    pub fn edns_opt_list_find(list: *mut edns_option, code: u16) -> *mut edns_option;
}
extern "C" {
    #[doc = " Call the registered functions in the inplace_cb_reply linked list.\n This function is going to get called while answering with a resolved query.\n @param env: module environment.\n @param qinfo: query info.\n @param qstate: module qstate.\n @param rep: Reply info. Could be NULL.\n @param rcode: return code.\n @param edns: edns data of the reply.\n @param repinfo: comm_reply. Reply information for a communication point.\n @param region: region to store data.\n @param start_time: the start time of recursion, when the packet arrived,\n \tor the current time for cache responses.\n @return false on failure (a callback function returned an error)."]
    pub fn inplace_cb_reply_call(
        env: *mut module_env,
        qinfo: *mut query_info,
        qstate: *mut module_qstate,
        rep: *mut reply_info,
        rcode: ::std::os::raw::c_int,
        edns: *mut edns_data,
        repinfo: *mut comm_reply,
        region: *mut regional,
        start_time: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call the registered functions in the inplace_cb_reply_cache linked list.\n This function is going to get called while answering from cache.\n @param env: module environment.\n @param qinfo: query info.\n @param qstate: module qstate. NULL when replying from cache.\n @param rep: Reply info.\n @param rcode: return code.\n @param edns: edns data of the reply. Edns input can be found here.\n @param repinfo: comm_reply. Reply information for a communication point.\n @param region: region to store data.\n @param start_time: the start time of recursion, when the packet arrived,\n \tor the current time for cache responses.\n @return false on failure (a callback function returned an error)."]
    pub fn inplace_cb_reply_cache_call(
        env: *mut module_env,
        qinfo: *mut query_info,
        qstate: *mut module_qstate,
        rep: *mut reply_info,
        rcode: ::std::os::raw::c_int,
        edns: *mut edns_data,
        repinfo: *mut comm_reply,
        region: *mut regional,
        start_time: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call the registered functions in the inplace_cb_reply_local linked list.\n This function is going to get called while answering with local data.\n @param env: module environment.\n @param qinfo: query info.\n @param qstate: module qstate. NULL when replying from cache.\n @param rep: Reply info.\n @param rcode: return code.\n @param edns: edns data of the reply. Edns input can be found here.\n @param repinfo: comm_reply. Reply information for a communication point.\n @param region: region to store data.\n @param start_time: the start time of recursion, when the packet arrived,\n \tor the current time for cache responses.\n @return false on failure (a callback function returned an error)."]
    pub fn inplace_cb_reply_local_call(
        env: *mut module_env,
        qinfo: *mut query_info,
        qstate: *mut module_qstate,
        rep: *mut reply_info,
        rcode: ::std::os::raw::c_int,
        edns: *mut edns_data,
        repinfo: *mut comm_reply,
        region: *mut regional,
        start_time: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call the registered functions in the inplace_cb_reply linked list.\n This function is going to get called while answering with a servfail.\n @param env: module environment.\n @param qinfo: query info.\n @param qstate: module qstate. Contains the edns option lists. Could be NULL.\n @param rep: Reply info. NULL when servfail.\n @param rcode: return code. LDNS_RCODE_SERVFAIL.\n @param edns: edns data of the reply. Edns input can be found here if qstate\n\tis NULL.\n @param repinfo: comm_reply. Reply information for a communication point.\n @param region: region to store data.\n @param start_time: the start time of recursion, when the packet arrived,\n \tor the current time for cache responses.\n @return false on failure (a callback function returned an error)."]
    pub fn inplace_cb_reply_servfail_call(
        env: *mut module_env,
        qinfo: *mut query_info,
        qstate: *mut module_qstate,
        rep: *mut reply_info,
        rcode: ::std::os::raw::c_int,
        edns: *mut edns_data,
        repinfo: *mut comm_reply,
        region: *mut regional,
        start_time: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call the registered functions in the inplace_cb_query linked list.\n This function is going to get called just before sending a query to a\n nameserver.\n @param env: module environment.\n @param qinfo: query info.\n @param flags: flags of the query.\n @param addr: to which server to send the query.\n @param addrlen: length of addr.\n @param zone: name of the zone of the delegation point. wireformat dname.\n\tThis is the delegation point name for which the server is deemed\n\tauthoritative.\n @param zonelen: length of zone.\n @param qstate: module qstate.\n @param region: region to store data.\n @return false on failure (a callback function returned an error)."]
    pub fn inplace_cb_query_call(
        env: *mut module_env,
        qinfo: *mut query_info,
        flags: u16,
        addr: *mut sockaddr_storage,
        addrlen: socklen_t,
        zone: *mut u8,
        zonelen: usize,
        qstate: *mut module_qstate,
        region: *mut regional,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call the registered functions in the inplace_cb_edns_back_parsed linked list.\n This function is going to get called after parsing the EDNS data on the\n reply from a nameserver.\n @param env: module environment.\n @param qstate: module qstate.\n @return false on failure (a callback function returned an error)."]
    pub fn inplace_cb_edns_back_parsed_call(
        env: *mut module_env,
        qstate: *mut module_qstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call the registered functions in the inplace_cb_query_response linked list.\n This function is going to get called after receiving a reply from a\n nameserver.\n @param env: module environment.\n @param qstate: module qstate.\n @param response: received response\n @return false on failure (a callback function returned an error)."]
    pub fn inplace_cb_query_response_call(
        env: *mut module_env,
        qstate: *mut module_qstate,
        response: *mut dns_msg,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy edns option list allocated to the new region"]
    pub fn edns_opt_copy_region(list: *mut edns_option, region: *mut regional) -> *mut edns_option;
}
extern "C" {
    #[doc = " Copy a filtered edns option list allocated to the new region"]
    pub fn edns_opt_copy_filter_region(
        list: *mut edns_option,
        filter_list: *mut u16,
        filter_list_len: usize,
        region: *mut regional,
    ) -> *mut edns_option;
}
extern "C" {
    #[doc = " Copy edns option list allocated with malloc"]
    pub fn edns_opt_copy_alloc(list: *mut edns_option) -> *mut edns_option;
}
extern "C" {
    #[doc = " Free edns option list allocated with malloc"]
    pub fn edns_opt_list_free(list: *mut edns_option);
}
extern "C" {
    #[doc = " Compare an edns option. (not entire list).  Also compares contents."]
    pub fn edns_opt_compare(p: *mut edns_option, q: *mut edns_option) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare edns option lists, also the order and contents of edns-options."]
    pub fn edns_opt_list_compare(p: *mut edns_option, q: *mut edns_option)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delegpt {
    _unused: [u8; 0],
}
#[doc = " Region allocated message reply"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dns_msg {
    #[doc = " query info"]
    pub qinfo: query_info,
    #[doc = " reply info - ptr to packed repinfo structure"]
    pub rep: *mut reply_info,
}
#[test]
fn bindgen_test_layout_dns_msg() {
    const UNINIT: ::std::mem::MaybeUninit<dns_msg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dns_msg>(),
        40usize,
        concat!("Size of: ", stringify!(dns_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<dns_msg>(),
        8usize,
        concat!("Alignment of ", stringify!(dns_msg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dns_msg),
            "::",
            stringify!(qinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dns_msg),
            "::",
            stringify!(rep)
        )
    );
}
extern "C" {
    #[doc = " Allocate a dns_msg with malloc/alloc structure and store in dns cache.\n\n @param env: environment, with alloc structure and dns cache.\n @param qinf: query info, the query for which answer is stored.\n \tthis is allocated in a region, and will be copied to malloc area\n \tbefore insertion.\n @param rep: reply in dns_msg from dns_alloc_msg for example.\n \tthis is allocated in a region, and will be copied to malloc area\n \tbefore insertion.\n @param is_referral: If true, then the given message to be stored is a\n      referral. The cache implementation may use this as a hint.\n      It will store only the RRsets, not the message.\n @param leeway: TTL value, if not 0, other rrsets are considered expired\n\tthat many seconds before actual TTL expiry.\n @param pside: if true, information came from a server which was fetched\n \tfrom the parentside of the zonecut.  This means that the type NS\n \tcan be updated to full TTL even in prefetch situations.\n @param region: region to allocate better entries from cache into.\n   (used when is_referral is false).\n @param flags: flags with BIT_CD for AAAA queries in dns64 translation.\n   The higher 16 bits are used internally to customize the cache policy.\n   (See DNSCACHE_STORE_xxx flags).\n @param qstarttime: time when the query was started, and thus when the\n \tdelegations were looked up.\n @return 0 on alloc error (out of memory)."]
    pub fn dns_cache_store(
        env: *mut module_env,
        qinf: *mut query_info,
        rep: *mut reply_info,
        is_referral: ::std::os::raw::c_int,
        leeway: time_t,
        pside: ::std::os::raw::c_int,
        region: *mut regional,
        flags: u32,
        qstarttime: time_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Store message in the cache. Stores in message cache and rrset cache.\n Both qinfo and rep should be malloced and are put in the cache.\n They should not be used after this call, as they are then in shared cache.\n Does not return errors, they are logged and only lead to less cache.\n\n @param env: module environment with the DNS cache.\n @param qinfo: query info\n @param hash: hash over qinfo.\n @param rep: reply info, together with qinfo makes up the message.\n\tAdjusts the reply info TTLs to absolute time.\n @param leeway: TTL value, if not 0, other rrsets are considered expired\n\tthat many seconds before actual TTL expiry.\n @param pside: if true, information came from a server which was fetched\n \tfrom the parentside of the zonecut.  This means that the type NS\n \tcan be updated to full TTL even in prefetch situations.\n @param qrep: message that can be altered with better rrs from cache.\n @param flags: customization flags for the cache policy.\n @param qstarttime: time when the query was started, and thus when the\n \tdelegations were looked up.\n @param region: to allocate into for qmsg."]
    pub fn dns_cache_store_msg(
        env: *mut module_env,
        qinfo: *mut query_info,
        hash: hashvalue_type,
        rep: *mut reply_info,
        leeway: time_t,
        pside: ::std::os::raw::c_int,
        qrep: *mut reply_info,
        flags: u32,
        region: *mut regional,
        qstarttime: time_t,
    );
}
extern "C" {
    #[doc = " Find a delegation from the cache.\n @param env: module environment with the DNS cache.\n @param qname: query name.\n @param qnamelen: length of qname.\n @param qtype: query type.\n @param qclass: query class.\n @param region: where to allocate result delegation.\n @param msg: if not NULL, delegation message is returned here, synthesized\n\tfrom the cache.\n @param timenow: the time now, for checking if TTL on cache entries is OK.\n @param noexpiredabove: if set, no expired NS rrsets above the one found\n \tare tolerated. It only returns delegations where the delegations above\n \tit are valid.\n @param expiretop: if not NULL, name where check for expiry ends for\n \tnoexpiredabove.\n @param expiretoplen: length of expiretop dname.\n @return new delegation or NULL on error or if not found in cache."]
    pub fn dns_cache_find_delegation(
        env: *mut module_env,
        qname: *mut u8,
        qnamelen: usize,
        qtype: u16,
        qclass: u16,
        region: *mut regional,
        msg: *mut *mut dns_msg,
        timenow: time_t,
        noexpiredabove: ::std::os::raw::c_int,
        expiretop: *mut u8,
        expiretoplen: usize,
    ) -> *mut delegpt;
}
extern "C" {
    #[doc = " generate dns_msg from cached message\n @param env: module environment with the DNS cache. NULL if the LRU from cache\n \tdoes not need to be touched.\n @param q: query info, contains qname that will make up the dns message.\n @param r: reply info that, together with qname, will make up the dns message.\n @param region: where to allocate dns message.\n @param now: the time now, for check if TTL on cache entry is ok.\n @param allow_expired: if true and serve-expired is enabled, it will allow\n\tfor expired dns_msg to be generated based on the configured serve-expired\n\tlogic.\n @param scratch: where to allocate temporary data."]
    pub fn tomsg(
        env: *mut module_env,
        q: *mut query_info,
        r: *mut reply_info,
        region: *mut regional,
        now: time_t,
        allow_expired: ::std::os::raw::c_int,
        scratch: *mut regional,
    ) -> *mut dns_msg;
}
extern "C" {
    #[doc = " Deep copy a dns_msg to a region.\n @param origin: the dns_msg to copy.\n @param region: the region to copy all the data to.\n @return the new dns_msg or NULL on malloc error."]
    pub fn dns_msg_deepcopy_region(origin: *mut dns_msg, region: *mut regional) -> *mut dns_msg;
}
extern "C" {
    #[doc = " Find cached message\n @param env: module environment with the DNS cache.\n @param qname: query name.\n @param qnamelen: length of qname.\n @param qtype: query type.\n @param qclass: query class.\n @param flags: flags with BIT_CD for AAAA queries in dns64 translation.\n @param region: where to allocate result.\n @param scratch: where to allocate temporary data.\n @param no_partial: if true, only complete messages and not a partial\n\tone (with only the start of the CNAME chain and not the rest).\n @param dpname: if not NULL, do not return NXDOMAIN above this name.\n @param dpnamelen: length of dpname.\n @return new response message (alloced in region, rrsets do not have IDs).\n \tor NULL on error or if not found in cache.\n\tTTLs are made relative to the current time."]
    pub fn dns_cache_lookup(
        env: *mut module_env,
        qname: *mut u8,
        qnamelen: usize,
        qtype: u16,
        qclass: u16,
        flags: u16,
        region: *mut regional,
        scratch: *mut regional,
        no_partial: ::std::os::raw::c_int,
        dpname: *mut u8,
        dpnamelen: usize,
    ) -> *mut dns_msg;
}
extern "C" {
    #[doc = " find and add A and AAAA records for missing nameservers in delegpt\n @param env: module environment with rrset cache\n @param qclass: which class to look in.\n @param region: where to store new dp info.\n @param dp: delegation point to fill missing entries.\n @return false on alloc failure."]
    pub fn cache_fill_missing(
        env: *mut module_env,
        qclass: u16,
        region: *mut regional,
        dp: *mut delegpt,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Utility, create new, unpacked data structure for cache response.\n QR bit set, no AA. Query set as indicated. Space for number of rrsets.\n @param qname: query section name\n @param qnamelen: len of qname\n @param qtype: query section type\n @param qclass: query section class\n @param region: where to alloc.\n @param capacity: number of rrsets space to create in the array.\n @return new dns_msg struct or NULL on mem fail."]
    pub fn dns_msg_create(
        qname: *mut u8,
        qnamelen: usize,
        qtype: u16,
        qclass: u16,
        region: *mut regional,
        capacity: usize,
    ) -> *mut dns_msg;
}
extern "C" {
    #[doc = " Add rrset to authority section in unpacked dns_msg message. Must have enough\n space left, does not grow the array.\n @param msg: msg to put it in.\n @param region: region to alloc in\n @param rrset: to add in authority section\n @param now: now.\n @return true if worked, false on fail"]
    pub fn dns_msg_authadd(
        msg: *mut dns_msg,
        region: *mut regional,
        rrset: *mut ub_packed_rrset_key,
        now: time_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add rrset to authority section in unpacked dns_msg message. Must have enough\n space left, does not grow the array.\n @param msg: msg to put it in.\n @param region: region to alloc in\n @param rrset: to add in authority section\n @param now: now.\n @return true if worked, false on fail"]
    pub fn dns_msg_ansadd(
        msg: *mut dns_msg,
        region: *mut regional,
        rrset: *mut ub_packed_rrset_key,
        now: time_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adjust the prefetch_ttl for a cached message.  This adds a value to the\n prefetch ttl - postponing the time when it will be prefetched for future\n incoming queries.\n @param env: module environment with caches and time.\n @param qinfo: query info for the query that needs adjustment.\n @param adjust: time in seconds to add to the prefetch_leeway.\n @param flags: flags with BIT_CD for AAAA queries in dns64 translation.\n @return false if not in cache. true if added."]
    pub fn dns_cache_prefetch_adjust(
        env: *mut module_env,
        qinfo: *mut query_info,
        adjust: time_t,
        flags: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lookup message in message cache\n the returned nonNULL entry is locked and has to be unlocked by the caller"]
    pub fn msg_cache_lookup(
        env: *mut module_env,
        qname: *mut u8,
        qnamelen: usize,
        qtype: u16,
        qclass: u16,
        flags: u16,
        now: time_t,
        wr: ::std::os::raw::c_int,
    ) -> *mut msgreply_entry;
}
extern "C" {
    #[doc = " Remove entry from the message cache.  For unwanted entries.\n @param env: with message cache.\n @param qname: query name, in wireformat\n @param qnamelen: length of qname, including terminating 0.\n @param qtype: query type, host order.\n @param qclass: query class, host order.\n @param flags: flags"]
    pub fn msg_cache_remove(
        env: *mut module_env,
        qname: *mut u8,
        qnamelen: usize,
        qtype: u16,
        qclass: u16,
        flags: u16,
    );
}
#[doc = " The rbnode_type struct definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rbnode_type {
    #[doc = " parent in rbtree, RBTREE_NULL for root"]
    pub parent: *mut rbnode_type,
    #[doc = " left node (smaller items)"]
    pub left: *mut rbnode_type,
    #[doc = " right node (larger items)"]
    pub right: *mut rbnode_type,
    #[doc = " pointer to sorting key"]
    pub key: *const ::std::os::raw::c_void,
    #[doc = " colour of this node"]
    pub color: u8,
}
#[test]
fn bindgen_test_layout_rbnode_type() {
    const UNINIT: ::std::mem::MaybeUninit<rbnode_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rbnode_type>(),
        40usize,
        concat!("Size of: ", stringify!(rbnode_type))
    );
    assert_eq!(
        ::std::mem::align_of::<rbnode_type>(),
        8usize,
        concat!("Alignment of ", stringify!(rbnode_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rbnode_type),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rbnode_type),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rbnode_type),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rbnode_type),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rbnode_type),
            "::",
            stringify!(color)
        )
    );
}
extern "C" {
    #[doc = " the global empty node"]
    pub static mut rbtree_null_node: rbnode_type;
}
#[doc = " definition for tree struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rbtree_type {
    #[doc = " The root of the red-black tree"]
    pub root: *mut rbnode_type,
    #[doc = " The number of the nodes in the tree"]
    pub count: usize,
    #[doc = " Key compare function. <0,0,>0 like strcmp.\n Return 0 on two NULL ptrs."]
    pub cmp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_rbtree_type() {
    const UNINIT: ::std::mem::MaybeUninit<rbtree_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rbtree_type>(),
        24usize,
        concat!("Size of: ", stringify!(rbtree_type))
    );
    assert_eq!(
        ::std::mem::align_of::<rbtree_type>(),
        8usize,
        concat!("Alignment of ", stringify!(rbtree_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rbtree_type),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rbtree_type),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rbtree_type),
            "::",
            stringify!(cmp)
        )
    );
}
extern "C" {
    #[doc = " Create new tree (malloced) with given key compare function.\n @param cmpf: compare function (like strcmp) takes pointers to two keys.\n @return: new tree, empty."]
    pub fn rbtree_create(
        cmpf: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut rbtree_type;
}
extern "C" {
    #[doc = " Init a new tree (malloced by caller) with given key compare function.\n @param rbtree: uninitialised memory for new tree, returned empty.\n @param cmpf: compare function (like strcmp) takes pointers to two keys."]
    pub fn rbtree_init(
        rbtree: *mut rbtree_type,
        cmpf: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " Insert data into the tree.\n @param rbtree: tree to insert to.\n @param data: element to insert.\n @return: data ptr or NULL if key already present."]
    pub fn rbtree_insert(rbtree: *mut rbtree_type, data: *mut rbnode_type) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Delete element from tree.\n @param rbtree: tree to delete from.\n @param key: key of item to delete.\n @return: node that is now unlinked from the tree. User to delete it.\n returns 0 if node not present"]
    pub fn rbtree_delete(
        rbtree: *mut rbtree_type,
        key: *const ::std::os::raw::c_void,
    ) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Find key in tree. Returns NULL if not found.\n @param rbtree: tree to find in.\n @param key: key that must match.\n @return: node that fits or NULL."]
    pub fn rbtree_search(
        rbtree: *mut rbtree_type,
        key: *const ::std::os::raw::c_void,
    ) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Find, but match does not have to be exact.\n @param rbtree: tree to find in.\n @param key: key to find position of.\n @param result: set to the exact node if present, otherwise to element that\n   precedes the position of key in the tree. NULL if no smaller element.\n @return: true if exact match in result. Else result points to <= element,\n or NULL if key is smaller than the smallest key."]
    pub fn rbtree_find_less_equal(
        rbtree: *mut rbtree_type,
        key: *const ::std::os::raw::c_void,
        result: *mut *mut rbnode_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns first (smallest) node in the tree\n @param rbtree: tree\n @return: smallest element or NULL if tree empty."]
    pub fn rbtree_first(rbtree: *mut rbtree_type) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Returns last (largest) node in the tree\n @param rbtree: tree\n @return: largest element or NULL if tree empty."]
    pub fn rbtree_last(rbtree: *mut rbtree_type) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Returns next larger node in the tree\n @param rbtree: tree\n @return: next larger element or NULL if no larger in tree."]
    pub fn rbtree_next(rbtree: *mut rbnode_type) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Returns previous smaller node in the tree\n @param rbtree: tree\n @return: previous smaller element or NULL if no previous in tree."]
    pub fn rbtree_previous(rbtree: *mut rbnode_type) -> *mut rbnode_type;
}
extern "C" {
    #[doc = " Call function for all elements in the redblack tree, such that\n leaf elements are called before parent elements. So that all\n elements can be safely free()d.\n Note that your function must not remove the nodes from the tree.\n Since that may trigger rebalances of the rbtree.\n @param tree: the tree\n @param func: function called with element and user arg.\n \tThe function must not alter the rbtree.\n @param arg: user argument."]
    pub fn traverse_postorder(
        tree: *mut rbtree_type,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut rbnode_type, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
#[doc = " Tree of domain names.  Sorted first by class then by name.\n This is not sorted canonically, but fast.\n This can be looked up to obtain a closest encloser parent name.\n\n The tree itself is a rbtree_type.\n This is the element node put as first entry in the client structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct name_tree_node {
    #[doc = " rbtree node, key is this struct : dclass and name"]
    pub node: rbnode_type,
    #[doc = " parent in tree"]
    pub parent: *mut name_tree_node,
    #[doc = " name in uncompressed wireformat"]
    pub name: *mut u8,
    #[doc = " length of name"]
    pub len: usize,
    #[doc = " labels in name"]
    pub labs: ::std::os::raw::c_int,
    #[doc = " the class of the name (host order)"]
    pub dclass: u16,
}
#[test]
fn bindgen_test_layout_name_tree_node() {
    const UNINIT: ::std::mem::MaybeUninit<name_tree_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<name_tree_node>(),
        72usize,
        concat!("Size of: ", stringify!(name_tree_node))
    );
    assert_eq!(
        ::std::mem::align_of::<name_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(name_tree_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(name_tree_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(name_tree_node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(name_tree_node),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(name_tree_node),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).labs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(name_tree_node),
            "::",
            stringify!(labs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dclass) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(name_tree_node),
            "::",
            stringify!(dclass)
        )
    );
}
#[doc = " Tree of IP addresses.  Sorted first by protocol, then by bits.\n This can be looked up to obtain the enclosing subnet.\n\n The tree itself is a rbtree_type.\n This is the element node put as first entry in the client structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addr_tree_node {
    #[doc = " rbtree node, key is this struct : proto and subnet"]
    pub node: rbnode_type,
    #[doc = " parent in tree"]
    pub parent: *mut addr_tree_node,
    #[doc = " address"]
    pub addr: sockaddr_storage,
    #[doc = " length of addr"]
    pub addrlen: socklen_t,
    #[doc = " netblock size"]
    pub net: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_addr_tree_node() {
    const UNINIT: ::std::mem::MaybeUninit<addr_tree_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<addr_tree_node>(),
        184usize,
        concat!("Size of: ", stringify!(addr_tree_node))
    );
    assert_eq!(
        ::std::mem::align_of::<addr_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(addr_tree_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addr_tree_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addr_tree_node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(addr_tree_node),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addrlen) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(addr_tree_node),
            "::",
            stringify!(addrlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).net) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(addr_tree_node),
            "::",
            stringify!(net)
        )
    );
}
extern "C" {
    #[doc = " Init a name tree to be empty\n @param tree: to init."]
    pub fn name_tree_init(tree: *mut rbtree_type);
}
extern "C" {
    #[doc = " insert element into name tree.\n @param tree: name tree\n @param node: node element (at start of a structure that caller\n\thas allocated).\n @param name: name to insert (wireformat)\n\tthis node has been allocated by the caller and it itself inserted.\n @param len: length of name\n @param labs: labels in name\n @param dclass: class of name\n @return false on error (duplicate element)."]
    pub fn name_tree_insert(
        tree: *mut rbtree_type,
        node: *mut name_tree_node,
        name: *mut u8,
        len: usize,
        labs: ::std::os::raw::c_int,
        dclass: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize parent pointers in name tree.\n Should be performed after insertions are done, before lookups\n @param tree: name tree"]
    pub fn name_tree_init_parents(tree: *mut rbtree_type);
}
extern "C" {
    #[doc = " Lookup exact match in name tree\n @param tree: name tree\n @param name: wireformat name\n @param len: length of name\n @param labs: labels in name\n @param dclass: class of name\n @return node or NULL if not found."]
    pub fn name_tree_find(
        tree: *mut rbtree_type,
        name: *mut u8,
        len: usize,
        labs: ::std::os::raw::c_int,
        dclass: u16,
    ) -> *mut name_tree_node;
}
extern "C" {
    #[doc = " Lookup closest encloser in name tree.\n @param tree: name tree\n @param name: wireformat name\n @param len: length of name\n @param labs: labels in name\n @param dclass: class of name\n @return closest enclosing node (could be equal) or NULL if not found."]
    pub fn name_tree_lookup(
        tree: *mut rbtree_type,
        name: *mut u8,
        len: usize,
        labs: ::std::os::raw::c_int,
        dclass: u16,
    ) -> *mut name_tree_node;
}
extern "C" {
    #[doc = " Find next root item in name tree.\n @param tree: the nametree.\n @param dclass: the class to look for next (or higher).\n @return false if no classes found, true means class put into c."]
    pub fn name_tree_next_root(tree: *mut rbtree_type, dclass: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Init addr tree to be empty.\n @param tree: to init."]
    pub fn addr_tree_init(tree: *mut rbtree_type);
}
extern "C" {
    #[doc = " Init addr tree to be empty.\n The comparison function to be used is addr_tree_addrport_compare.\n @param tree: to init."]
    pub fn addr_tree_addrport_init(tree: *mut rbtree_type);
}
extern "C" {
    #[doc = " insert element into addr tree.\n @param tree: addr tree\n @param node: node element (at start of a structure that caller\n\thas allocated).\n @param addr: to insert (copied).\n @param addrlen: length of addr\n @param net: size of subnet.\n @return false on error (duplicate element)."]
    pub fn addr_tree_insert(
        tree: *mut rbtree_type,
        node: *mut addr_tree_node,
        addr: *mut sockaddr_storage,
        addrlen: socklen_t,
        net: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize parent pointers in addr tree.\n Should be performed after insertions are done, before lookups\n @param tree: addr tree"]
    pub fn addr_tree_init_parents(tree: *mut rbtree_type);
}
extern "C" {
    #[doc = " Initialize parent pointers in partial addr tree.\n Reinitialize pointer for part of tree, used after node deletion\n @param node: node to start parent pointer initialization for."]
    pub fn addr_tree_init_parents_node(node: *mut addr_tree_node);
}
extern "C" {
    #[doc = " Lookup closest encloser in addr tree.\n @param tree: addr tree\n @param addr: to lookup.\n @param addrlen: length of addr\n @return closest enclosing node (could be equal) or NULL if not found."]
    pub fn addr_tree_lookup(
        tree: *mut rbtree_type,
        addr: *mut sockaddr_storage,
        addrlen: socklen_t,
    ) -> *mut addr_tree_node;
}
extern "C" {
    #[doc = " Find element in addr tree.  (search a netblock, not a match for an address)\n @param tree: addr tree\n @param addr: netblock to lookup.\n @param addrlen: length of addr\n @param net: size of subnet\n @return addr tree element, or NULL if not found."]
    pub fn addr_tree_find(
        tree: *mut rbtree_type,
        addr: *mut sockaddr_storage,
        addrlen: socklen_t,
        net: ::std::os::raw::c_int,
    ) -> *mut addr_tree_node;
}
extern "C" {
    #[doc = " compare name tree nodes"]
    pub fn name_tree_compare(
        k1: *const ::std::os::raw::c_void,
        k2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compare addr tree nodes"]
    pub fn addr_tree_compare(
        k1: *const ::std::os::raw::c_void,
        k2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compare addr tree nodes (address and port only)"]
    pub fn addr_tree_addrport_compare(
        k1: *const ::std::os::raw::c_void,
        k2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const sldns_enum_pkt_section_LDNS_SECTION_QUESTION: sldns_enum_pkt_section = 0;
pub const sldns_enum_pkt_section_LDNS_SECTION_ANSWER: sldns_enum_pkt_section = 1;
pub const sldns_enum_pkt_section_LDNS_SECTION_AUTHORITY: sldns_enum_pkt_section = 2;
pub const sldns_enum_pkt_section_LDNS_SECTION_ADDITIONAL: sldns_enum_pkt_section = 3;
#[doc = " bogus section, if not interested"]
pub const sldns_enum_pkt_section_LDNS_SECTION_ANY: sldns_enum_pkt_section = 4;
#[doc = " used to get all non-question rrs from a packet"]
pub const sldns_enum_pkt_section_LDNS_SECTION_ANY_NOQUESTION: sldns_enum_pkt_section = 5;
#[doc = " The sections of a packet"]
pub type sldns_enum_pkt_section = ::std::os::raw::c_uint;
#[doc = " The sections of a packet"]
pub use self::sldns_enum_pkt_section as sldns_pkt_section;
pub const sldns_enum_pkt_opcode_LDNS_PACKET_QUERY: sldns_enum_pkt_opcode = 0;
pub const sldns_enum_pkt_opcode_LDNS_PACKET_IQUERY: sldns_enum_pkt_opcode = 1;
pub const sldns_enum_pkt_opcode_LDNS_PACKET_STATUS: sldns_enum_pkt_opcode = 2;
pub const sldns_enum_pkt_opcode_LDNS_PACKET_NOTIFY: sldns_enum_pkt_opcode = 4;
pub const sldns_enum_pkt_opcode_LDNS_PACKET_UPDATE: sldns_enum_pkt_opcode = 5;
pub type sldns_enum_pkt_opcode = ::std::os::raw::c_uint;
pub use self::sldns_enum_pkt_opcode as sldns_pkt_opcode;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NOERROR: sldns_enum_pkt_rcode = 0;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_FORMERR: sldns_enum_pkt_rcode = 1;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_SERVFAIL: sldns_enum_pkt_rcode = 2;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NXDOMAIN: sldns_enum_pkt_rcode = 3;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NOTIMPL: sldns_enum_pkt_rcode = 4;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_REFUSED: sldns_enum_pkt_rcode = 5;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_YXDOMAIN: sldns_enum_pkt_rcode = 6;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_YXRRSET: sldns_enum_pkt_rcode = 7;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NXRRSET: sldns_enum_pkt_rcode = 8;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NOTAUTH: sldns_enum_pkt_rcode = 9;
pub const sldns_enum_pkt_rcode_LDNS_RCODE_NOTZONE: sldns_enum_pkt_rcode = 10;
pub type sldns_enum_pkt_rcode = ::std::os::raw::c_uint;
pub use self::sldns_enum_pkt_rcode as sldns_pkt_rcode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comm_point {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Maximum TTL that is allowed."]
    pub static mut MAX_TTL: time_t;
}
extern "C" {
    #[doc = " Minimum TTL that is allowed."]
    pub static mut MIN_TTL: time_t;
}
extern "C" {
    #[doc = " Maximum Negative TTL that is allowed"]
    pub static mut MAX_NEG_TTL: time_t;
}
extern "C" {
    #[doc = " Minimum Negative TTL that is allowed"]
    pub static mut MIN_NEG_TTL: time_t;
}
extern "C" {
    #[doc = " If we serve expired entries and prefetch them"]
    pub static mut SERVE_EXPIRED: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Time to serve records after expiration"]
    pub static mut SERVE_EXPIRED_TTL: time_t;
}
extern "C" {
    #[doc = " TTL to use for expired records"]
    pub static mut SERVE_EXPIRED_REPLY_TTL: time_t;
}
extern "C" {
    #[doc = " If we serve the original TTL or decrementing TTLs"]
    pub static mut SERVE_ORIGINAL_TTL: ::std::os::raw::c_int;
}
#[doc = " Data stored in scratch pad memory during parsing.\n Stores the data that will enter into the msgreply and packet result."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msg_parse {
    #[doc = " id from message, network format."]
    pub id: u16,
    #[doc = " flags from message, host format."]
    pub flags: u16,
    #[doc = " count of RRs, host format"]
    pub qdcount: u16,
    #[doc = " count of RRs, host format"]
    pub ancount: u16,
    #[doc = " count of RRs, host format"]
    pub nscount: u16,
    #[doc = " count of RRs, host format"]
    pub arcount: u16,
    #[doc = " count of RRsets per section."]
    pub an_rrsets: usize,
    #[doc = " count of RRsets per section."]
    pub ns_rrsets: usize,
    #[doc = " count of RRsets per section."]
    pub ar_rrsets: usize,
    #[doc = " total number of rrsets found."]
    pub rrset_count: usize,
    #[doc = " query dname (pointer to start location in packet, NULL if none"]
    pub qname: *mut u8,
    #[doc = " length of query dname in octets, 0 if none"]
    pub qname_len: usize,
    #[doc = " query type, host order. 0 if qdcount=0"]
    pub qtype: u16,
    #[doc = " query class, host order. 0 if qdcount=0"]
    pub qclass: u16,
    #[doc = " Hash table array used during parsing to lookup rrset types.\n Based on name, type, class.  Same hash value as in rrset cache."]
    pub hashtable: [*mut rrset_parse; 32usize],
    #[doc = " linked list of rrsets that have been found (in order)."]
    pub rrset_first: *mut rrset_parse,
    #[doc = " last element of rrset list."]
    pub rrset_last: *mut rrset_parse,
}
#[test]
fn bindgen_test_layout_msg_parse() {
    const UNINIT: ::std::mem::MaybeUninit<msg_parse> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msg_parse>(),
        344usize,
        concat!("Size of: ", stringify!(msg_parse))
    );
    assert_eq!(
        ::std::mem::align_of::<msg_parse>(),
        8usize,
        concat!("Alignment of ", stringify!(msg_parse))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qdcount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(qdcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ancount) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(ancount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nscount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(nscount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arcount) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(arcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).an_rrsets) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(an_rrsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns_rrsets) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(ns_rrsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_rrsets) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(ar_rrsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrset_count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(rrset_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qname) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(qname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qname_len) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(qname_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qtype) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(qtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qclass) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(qclass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashtable) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(hashtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrset_first) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(rrset_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrset_last) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_parse),
            "::",
            stringify!(rrset_last)
        )
    );
}
#[doc = " Data stored for an rrset during parsing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rrset_parse {
    #[doc = " next in hash bucket"]
    pub rrset_bucket_next: *mut rrset_parse,
    #[doc = " next in list of all rrsets"]
    pub rrset_all_next: *mut rrset_parse,
    #[doc = " hash value of rrset"]
    pub hash: hashvalue_type,
    #[doc = " which section was it found in: one of\n LDNS_SECTION_ANSWER, LDNS_SECTION_AUTHORITY, LDNS_SECTION_ADDITIONAL"]
    pub section: sldns_pkt_section,
    #[doc = " start of (possibly compressed) dname in packet"]
    pub dname: *mut u8,
    #[doc = " length of the dname uncompressed wireformat"]
    pub dname_len: usize,
    #[doc = " type, host order."]
    pub type_: u16,
    #[doc = " class, network order. var name so that it is not a c++ keyword."]
    pub rrset_class: u16,
    #[doc = " the flags for the rrset, like for packedrrset"]
    pub flags: u32,
    #[doc = " number of RRs in the rr list"]
    pub rr_count: usize,
    #[doc = " sum of RR rdata sizes"]
    pub size: usize,
    #[doc = " linked list of RRs in this rrset."]
    pub rr_first: *mut rr_parse,
    #[doc = " last in list of RRs in this rrset."]
    pub rr_last: *mut rr_parse,
    #[doc = " number of RRSIGs over this rrset."]
    pub rrsig_count: usize,
    #[doc = " linked list of RRsig RRs over this rrset."]
    pub rrsig_first: *mut rr_parse,
    #[doc = " last in list of RRSIG RRs over this rrset."]
    pub rrsig_last: *mut rr_parse,
}
#[test]
fn bindgen_test_layout_rrset_parse() {
    const UNINIT: ::std::mem::MaybeUninit<rrset_parse> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rrset_parse>(),
        104usize,
        concat!("Size of: ", stringify!(rrset_parse))
    );
    assert_eq!(
        ::std::mem::align_of::<rrset_parse>(),
        8usize,
        concat!("Alignment of ", stringify!(rrset_parse))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrset_bucket_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(rrset_bucket_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrset_all_next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(rrset_all_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).section) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dname) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(dname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dname_len) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(dname_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrset_class) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(rrset_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rr_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(rr_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rr_first) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(rr_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rr_last) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(rr_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrsig_count) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(rrsig_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrsig_first) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(rrsig_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrsig_last) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rrset_parse),
            "::",
            stringify!(rrsig_last)
        )
    );
}
#[doc = " Data stored for an RR during parsing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rr_parse {
    #[doc = " Pointer to the RR. Points to start of TTL value in the packet.\n Rdata length and rdata follow it.\n its dname, type and class are the same and stored for the rrset."]
    pub ttl_data: *mut u8,
    #[doc = " true if ttl_data is not part of the packet, but elsewhere in mem.\n Set for generated CNAMEs for DNAMEs."]
    pub outside_packet: ::std::os::raw::c_int,
    #[doc = " the length of the rdata if allocated (with no dname compression)"]
    pub size: usize,
    #[doc = " next in list of RRs."]
    pub next: *mut rr_parse,
}
#[test]
fn bindgen_test_layout_rr_parse() {
    const UNINIT: ::std::mem::MaybeUninit<rr_parse> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rr_parse>(),
        32usize,
        concat!("Size of: ", stringify!(rr_parse))
    );
    assert_eq!(
        ::std::mem::align_of::<rr_parse>(),
        8usize,
        concat!("Alignment of ", stringify!(rr_parse))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rr_parse),
            "::",
            stringify!(ttl_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outside_packet) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rr_parse),
            "::",
            stringify!(outside_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rr_parse),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rr_parse),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " EDNS data storage\n rdata is parsed in a list (has accessor functions). allocated in a\n region."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct edns_data {
    #[doc = " Extended RCODE"]
    pub ext_rcode: u8,
    #[doc = " The EDNS version number"]
    pub edns_version: u8,
    #[doc = " the EDNS bits field from ttl (host order): Z"]
    pub bits: u16,
    #[doc = " UDP reassembly size."]
    pub udp_size: u16,
    #[doc = " rdata element list of options of an incoming packet created at\n parse time, or NULL if none"]
    pub opt_list_in: *mut edns_option,
    #[doc = " rdata element list of options to encode for outgoing packets,\n or NULL if none"]
    pub opt_list_out: *mut edns_option,
    #[doc = " rdata element list of outgoing edns options from modules\n or NULL if none"]
    pub opt_list_inplace_cb_out: *mut edns_option,
    #[doc = " block size to pad"]
    pub padding_block_size: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_edns_data() {
    const UNINIT: ::std::mem::MaybeUninit<edns_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<edns_data>(),
        40usize,
        concat!("Size of: ", stringify!(edns_data))
    );
    assert_eq!(
        ::std::mem::align_of::<edns_data>(),
        8usize,
        concat!("Alignment of ", stringify!(edns_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ext_rcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_data),
            "::",
            stringify!(ext_rcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edns_version) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_data),
            "::",
            stringify!(edns_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_data),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udp_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_data),
            "::",
            stringify!(udp_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_list_in) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_data),
            "::",
            stringify!(opt_list_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_list_out) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_data),
            "::",
            stringify!(opt_list_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_list_inplace_cb_out) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_data),
            "::",
            stringify!(opt_list_inplace_cb_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_block_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_data),
            "::",
            stringify!(padding_block_size)
        )
    );
}
impl edns_data {
    #[inline]
    pub fn edns_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_edns_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cookie_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cookie_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cookie_valid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cookie_valid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cookie_client(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cookie_client(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        edns_present: ::std::os::raw::c_uint,
        cookie_present: ::std::os::raw::c_uint,
        cookie_valid: ::std::os::raw::c_uint,
        cookie_client: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let edns_present: u32 = unsafe { ::std::mem::transmute(edns_present) };
            edns_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cookie_present: u32 = unsafe { ::std::mem::transmute(cookie_present) };
            cookie_present as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cookie_valid: u32 = unsafe { ::std::mem::transmute(cookie_valid) };
            cookie_valid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cookie_client: u32 = unsafe { ::std::mem::transmute(cookie_client) };
            cookie_client as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " EDNS option"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct edns_option {
    #[doc = " next item in list"]
    pub next: *mut edns_option,
    #[doc = " type of this edns option"]
    pub opt_code: u16,
    #[doc = " length of this edns option (cannot exceed uint16 in encoding)"]
    pub opt_len: usize,
    #[doc = " data of this edns option; allocated in region, or NULL if len=0"]
    pub opt_data: *mut u8,
}
#[test]
fn bindgen_test_layout_edns_option() {
    const UNINIT: ::std::mem::MaybeUninit<edns_option> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<edns_option>(),
        32usize,
        concat!("Size of: ", stringify!(edns_option))
    );
    assert_eq!(
        ::std::mem::align_of::<edns_option>(),
        8usize,
        concat!("Alignment of ", stringify!(edns_option))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_option),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_option),
            "::",
            stringify!(opt_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_option),
            "::",
            stringify!(opt_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_option),
            "::",
            stringify!(opt_data)
        )
    );
}
extern "C" {
    #[doc = " Obtain size in the packet of an rr type, that is before dname type.\n Do TYPE_DNAME, and type STR, yourself. Gives size for most regular types.\n @param rdf: the rdf type from the descriptor.\n @return: size in octets. 0 on failure."]
    pub fn get_rdf_size(rdf: sldns_rdf_type) -> usize;
}
extern "C" {
    #[doc = " Parse the packet.\n @param pkt: packet, position at call must be at start of packet.\n\tat end position is after packet.\n @param msg: where to store results.\n @param region: how to alloc results.\n @return: 0 if OK, or rcode on error."]
    pub fn parse_packet(
        pkt: *mut sldns_buffer,
        msg: *mut msg_parse,
        region: *mut regional,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " After parsing the packet, extract EDNS data from packet.\n If not present this is noted in the data structure.\n If a parse error happens, an error code is returned.\n\n Quirks:\n\to ignores OPT rdata.\n\to ignores OPT owner name.\n\to ignores extra OPT records, except the last one in the packet.\n\n @param msg: parsed message structure. Modified on exit, if EDNS was present\n \tit is removed from the additional section.\n @param edns: the edns data is stored here. Does not have to be initialised.\n @param region: region to alloc results in (edns option contents)\n @return: 0 on success. or an RCODE on an error.\n\tRCODE formerr if OPT in wrong section, and so on."]
    pub fn parse_extract_edns_from_response_msg(
        msg: *mut msg_parse,
        edns: *mut edns_data,
        region: *mut regional,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Skip RRs from packet\n @param pkt: the packet. position at start must be right after the query\n\tsection. At end, right after EDNS data or no movement if failed.\n @param num: Limit of the number of records we want to parse.\n @return: 0 on success, 1 on failure."]
    pub fn skip_pkt_rrs(
        pkt: *mut sldns_buffer,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If EDNS data follows a query section, extract it and initialize edns struct.\n @param pkt: the packet. position at start must be right after the query\n\tsection. At end, right after EDNS data or no movement if failed.\n @param edns: the edns data allocated by the caller. Does not have to be\n\tinitialised.\n @param cfg: the configuration (with nsid value etc.)\n @param c: commpoint to determine transport (if needed)\n @param repinfo: commreply to determine the client address\n @param now: current time\n @param region: region to alloc results in (edns option contents)\n @return: 0 on success, or an RCODE on error.\n\tRCODE formerr if OPT is badly formatted and so on."]
    pub fn parse_edns_from_query_pkt(
        pkt: *mut sldns_buffer,
        edns: *mut edns_data,
        cfg: *mut config_file,
        c: *mut comm_point,
        repinfo: *mut comm_reply,
        now: time_t,
        region: *mut regional,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calculate hash value for rrset in packet.\n @param pkt: the packet.\n @param dname: pointer to uncompressed dname, or compressed dname in packet.\n @param type: rrset type in host order.\n @param dclass: rrset class in network order.\n @param rrset_flags: rrset flags (same as packed_rrset flags).\n @return hash value"]
    pub fn pkt_hash_rrset(
        pkt: *mut sldns_buffer,
        dname: *mut u8,
        type_: u16,
        dclass: u16,
        rrset_flags: u32,
    ) -> hashvalue_type;
}
extern "C" {
    #[doc = " Lookup in msg hashtable to find a rrset.\n @param msg: with the hashtable.\n @param pkt: packet for compressed names.\n @param h: hash value\n @param rrset_flags: flags of rrset sought for.\n @param dname: name of rrset sought for.\n @param dnamelen: len of dname.\n @param type: rrset type, host order.\n @param dclass: rrset class, network order.\n @return NULL or the rrset_parse if found."]
    pub fn msgparse_hashtable_lookup(
        msg: *mut msg_parse,
        pkt: *mut sldns_buffer,
        h: hashvalue_type,
        rrset_flags: u32,
        dname: *mut u8,
        dnamelen: usize,
        type_: u16,
        dclass: u16,
    ) -> *mut rrset_parse;
}
extern "C" {
    #[doc = " Remove rrset from hash table.\n @param msg: with hashtable.\n @param rrset: with hash value and id info."]
    pub fn msgparse_bucket_remove(msg: *mut msg_parse, rrset: *mut rrset_parse);
}
extern "C" {
    #[doc = " Log the edns options in the edns option list.\n @param level: the verbosity level.\n @param info_str: the informational string to be printed before the options.\n @param list: the edns option list."]
    pub fn log_edns_opt_list(
        level: verbosity_value,
        info_str: *const ::std::os::raw::c_char,
        list: *mut edns_option,
    );
}
extern "C" {
    #[doc = " Remove RR from msgparse RRset.\n @param str: this string is used for logging if verbose. If NULL, there is\n\tno logging of the remove.\n @param pkt: packet in buffer that is removed from. Used to log the name\n \tof the item removed.\n @param rrset: RRset that the RR is removed from.\n @param prev: previous RR in list, or NULL.\n @param rr: RR that is removed.\n @param addr: address used for logging, if verbose, or NULL then it is not\n\tused.\n @param addrlen: length of addr, if that is not NULL.\n @return true if rrset is entirely bad, it would then need to be removed."]
    pub fn msgparse_rrset_remove_rr(
        str_: *const ::std::os::raw::c_char,
        pkt: *mut sldns_buffer,
        rrset: *mut rrset_parse,
        prev: *mut rr_parse,
        rr: *mut rr_parse,
        addr: *mut sockaddr_storage,
        addrlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rrset_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slabhash {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct worker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comm_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auth_zones {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct outside_network {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ub_randstate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mesh_area {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mesh_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct val_anchors {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct val_neg_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iter_forwards {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iter_hints {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct respip_set {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct respip_client_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct respip_addr_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_stack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct errinf_strlist {
    #[doc = " next item in list"]
    pub next: *mut errinf_strlist,
    #[doc = " config option string"]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = " EDE code companion to the error str"]
    pub reason_bogus: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_errinf_strlist() {
    const UNINIT: ::std::mem::MaybeUninit<errinf_strlist> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<errinf_strlist>(),
        24usize,
        concat!("Size of: ", stringify!(errinf_strlist))
    );
    assert_eq!(
        ::std::mem::align_of::<errinf_strlist>(),
        8usize,
        concat!("Alignment of ", stringify!(errinf_strlist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(errinf_strlist),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(errinf_strlist),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason_bogus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(errinf_strlist),
            "::",
            stringify!(reason_bogus)
        )
    );
}
pub const inplace_cb_list_type_inplace_cb_reply: inplace_cb_list_type = 0;
pub const inplace_cb_list_type_inplace_cb_reply_cache: inplace_cb_list_type = 1;
pub const inplace_cb_list_type_inplace_cb_reply_local: inplace_cb_list_type = 2;
pub const inplace_cb_list_type_inplace_cb_reply_servfail: inplace_cb_list_type = 3;
pub const inplace_cb_list_type_inplace_cb_query: inplace_cb_list_type = 4;
pub const inplace_cb_list_type_inplace_cb_query_response: inplace_cb_list_type = 5;
pub const inplace_cb_list_type_inplace_cb_edns_back_parsed: inplace_cb_list_type = 6;
pub const inplace_cb_list_type_inplace_cb_types_total: inplace_cb_list_type = 7;
pub type inplace_cb_list_type = ::std::os::raw::c_uint;
#[doc = " Known edns option. Can be populated during modules' init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct edns_known_option {
    #[doc = " type of this edns option"]
    pub opt_code: u16,
    #[doc = " whether the option needs to bypass the cache stage"]
    pub bypass_cache_stage: ::std::os::raw::c_int,
    #[doc = " whether the option needs mesh aggregation"]
    pub no_aggregation: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_edns_known_option() {
    const UNINIT: ::std::mem::MaybeUninit<edns_known_option> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<edns_known_option>(),
        12usize,
        concat!("Size of: ", stringify!(edns_known_option))
    );
    assert_eq!(
        ::std::mem::align_of::<edns_known_option>(),
        4usize,
        concat!("Alignment of ", stringify!(edns_known_option))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_known_option),
            "::",
            stringify!(opt_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bypass_cache_stage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_known_option),
            "::",
            stringify!(bypass_cache_stage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_aggregation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edns_known_option),
            "::",
            stringify!(no_aggregation)
        )
    );
}
#[doc = " Inplace callback list of registered routines to be called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inplace_cb {
    #[doc = " next in list"]
    pub next: *mut inplace_cb,
    #[doc = " Inplace callback routine"]
    pub cb: *mut ::std::os::raw::c_void,
    pub cb_arg: *mut ::std::os::raw::c_void,
    #[doc = " module id"]
    pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_inplace_cb() {
    const UNINIT: ::std::mem::MaybeUninit<inplace_cb> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<inplace_cb>(),
        32usize,
        concat!("Size of: ", stringify!(inplace_cb))
    );
    assert_eq!(
        ::std::mem::align_of::<inplace_cb>(),
        8usize,
        concat!("Alignment of ", stringify!(inplace_cb))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inplace_cb),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inplace_cb),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_arg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inplace_cb),
            "::",
            stringify!(cb_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(inplace_cb),
            "::",
            stringify!(id)
        )
    );
}
#[doc = " Inplace callback function called before replying.\n Called as func(qinfo, qstate, rep, rcode, edns, opt_list_out, repinfo,\n                region, id, python_callback)\n Where:\n\tqinfo: the query info.\n\tqstate: the module state. NULL when calling before the query reaches the\n\t\tmesh states.\n\trep: reply_info. Could be NULL.\n\trcode: the return code.\n\tedns: the edns_data of the reply. When qstate is NULL, it is also used as\n\t\tthe edns input.\n\topt_list_out: the edns options list for the reply.\n\trepinfo: reply information for a communication point. NULL when calling\n\t\tduring the mesh states; the same could be found from\n\t\tqstate->mesh_info->reply_list.\n\tregion: region to store data.\n\tid: module id.\n\tpython_callback: only used for registering a python callback function."]
pub type inplace_cb_reply_func_type = ::std::option::Option<
    unsafe extern "C" fn(
        qinfo: *mut query_info,
        qstate: *mut module_qstate,
        rep: *mut reply_info,
        rcode: ::std::os::raw::c_int,
        edns: *mut edns_data,
        opt_list_out: *mut *mut edns_option,
        repinfo: *mut comm_reply,
        region: *mut regional,
        start_time: *mut timeval,
        id: ::std::os::raw::c_int,
        callback: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Inplace callback function called before sending the query to a nameserver.\n Called as func(qinfo, flags, qstate, addr, addrlen, zone, zonelen, region,\n                id, python_callback)\n Where:\n\tqinfo: query info.\n\tflags: flags of the query.\n\tqstate: query state.\n\taddr: to which server to send the query.\n\taddrlen: length of addr.\n\tzone: name of the zone of the delegation point. wireformat dname.\n\t\tThis is the delegation point name for which the server is deemed\n\t\tauthoritative.\n\tzonelen: length of zone.\n\tregion: region to store data.\n\tid: module id.\n\tpython_callback: only used for registering a python callback function."]
pub type inplace_cb_query_func_type = ::std::option::Option<
    unsafe extern "C" fn(
        qinfo: *mut query_info,
        flags: u16,
        qstate: *mut module_qstate,
        addr: *mut sockaddr_storage,
        addrlen: socklen_t,
        zone: *mut u8,
        zonelen: usize,
        region: *mut regional,
        id: ::std::os::raw::c_int,
        callback: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Inplace callback function called after parsing edns on query reply.\n Called as func(qstate, id, cb_args)\n Where:\n\tqstate: the query state.\n\tid: module id.\n\tcb_args: argument passed when registering callback."]
pub type inplace_cb_edns_back_parsed_func_type = ::std::option::Option<
    unsafe extern "C" fn(
        qstate: *mut module_qstate,
        id: ::std::os::raw::c_int,
        cb_args: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Inplace callback function called after parsing query response.\n Called as func(qstate, response, id, cb_args)\n Where:\n\tqstate: the query state.\n\tresponse: query response.\n\tid: module id.\n\tcb_args: argument passed when registering callback."]
pub type inplace_cb_query_response_func_type = ::std::option::Option<
    unsafe extern "C" fn(
        qstate: *mut module_qstate,
        response: *mut dns_msg,
        id: ::std::os::raw::c_int,
        cb_args: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Function called when looking for (expired) cached answers during the serve\n expired logic.\n Called as func(qstate, lookup_qinfo)\n Where:\n\tqstate: the query state.\n\tlookup_qinfo: the qinfo to lookup for."]
pub type serve_expired_lookup_func_type = ::std::option::Option<
    unsafe extern "C" fn(qstate: *mut module_qstate, lookup_qinfo: *mut query_info) -> *mut dns_msg,
>;
#[doc = " Module environment.\n Services and data provided to the module."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_env {
    #[doc = " config file with config options"]
    pub cfg: *mut config_file,
    #[doc = " shared message cache"]
    pub msg_cache: *mut slabhash,
    #[doc = " shared rrset cache"]
    pub rrset_cache: *mut rrset_cache,
    #[doc = " shared infrastructure cache (edns, lameness)"]
    pub infra_cache: *mut infra_cache,
    #[doc = " shared key cache"]
    pub key_cache: *mut key_cache,
    #[doc = " Send serviced DNS query to server. UDP/TCP and EDNS is handled.\n operate() should return with wait_reply. Later on a callback\n will cause operate() to be called with event timeout or reply.\n The time until a timeout is calculated from roundtrip timing,\n several UDP retries are attempted.\n @param qinfo: query info.\n @param flags: host order flags word, with opcode and CD bit.\n @param dnssec: if set, EDNS record will have bits set.\n\tIf EDNS_DO bit is set, DO bit is set in EDNS records.\n\tIf BIT_CD is set, CD bit is set in queries with EDNS records.\n @param want_dnssec: if set, the validator wants DNSSEC.  Without\n \tEDNS, the answer is likely to be useless for this domain.\n @param nocaps: do not use caps_for_id, use the qname as given.\n\t(ignored if caps_for_id is disabled).\n @param check_ratelimit: if set, will check ratelimit before sending out.\n @param addr: where to.\n @param addrlen: length of addr.\n @param zone: delegation point name.\n @param zonelen: length of zone name.\n @param tcp_upstream: use TCP for upstream queries.\n @param ssl_upstream: use SSL for upstream queries.\n @param tls_auth_name: if ssl_upstream, use this name with TLS\n \tauthentication.\n @param q: which query state to reactivate upon return.\n @param was_ratelimited: it will signal back if the query failed to pass the\n\tratelimit check.\n @return: false on failure (memory or socket related). no query was\n\tsent. Or returns an outbound entry with qsent and qstate set.\n\tThis outbound_entry will be used on later module invocations\n\tthat involve this query (timeout, error or reply)."]
    pub send_query: ::std::option::Option<
        unsafe extern "C" fn(
            qinfo: *mut query_info,
            flags: u16,
            dnssec: ::std::os::raw::c_int,
            want_dnssec: ::std::os::raw::c_int,
            nocaps: ::std::os::raw::c_int,
            check_ratelimit: ::std::os::raw::c_int,
            addr: *mut sockaddr_storage,
            addrlen: socklen_t,
            zone: *mut u8,
            zonelen: usize,
            tcp_upstream: ::std::os::raw::c_int,
            ssl_upstream: ::std::os::raw::c_int,
            tls_auth_name: *mut ::std::os::raw::c_char,
            q: *mut module_qstate,
            was_ratelimited: *mut ::std::os::raw::c_int,
        ) -> *mut outbound_entry,
    >,
    #[doc = " Detach-subqueries.\n Remove all sub-query references from this query state.\n Keeps super-references of those sub-queries correct.\n Updates stat items in mesh_area structure.\n @param qstate: used to find mesh state."]
    pub detach_subs: ::std::option::Option<unsafe extern "C" fn(qstate: *mut module_qstate)>,
    #[doc = " Attach subquery.\n Creates it if it does not exist already.\n Keeps sub and super references correct.\n Updates stat items in mesh_area structure.\n Pass if it is priming query or not.\n return:\n o if error (malloc) happened.\n o need to initialise the new state (module init; it is a new state).\n   so that the next run of the query with this module is successful.\n o no init needed, attachment successful.\n\n @param qstate: the state to find mesh state, and that wants to\n \treceive the results from the new subquery.\n @param qinfo: what to query for (copied).\n @param qflags: what flags to use (RD, CD flag or not).\n @param prime: if it is a (stub) priming query.\n @param valrec: validation lookup recursion, does not need validation\n @param newq: If the new subquery needs initialisation, it is\n \treturned, otherwise NULL is returned.\n @return: false on error, true if success (and init may be needed)."]
    pub attach_sub: ::std::option::Option<
        unsafe extern "C" fn(
            qstate: *mut module_qstate,
            qinfo: *mut query_info,
            qflags: u16,
            prime: ::std::os::raw::c_int,
            valrec: ::std::os::raw::c_int,
            newq: *mut *mut module_qstate,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Add detached query.\n Creates it if it does not exist already.\n Does not make super/sub references.\n Performs a cycle detection - for double check - and fails if there is\n \tone.\n Updates stat items in mesh_area structure.\n Pass if it is priming query or not.\n return:\n \to if error (malloc) happened.\n \to need to initialise the new state (module init; it is a new state).\n \t  so that the next run of the query with this module is successful.\n \to no init needed, attachment successful.\n \to added subquery, created if it did not exist already.\n\n @param qstate: the state to find mesh state, and that wants to receive\n \tthe results from the new subquery.\n @param qinfo: what to query for (copied).\n @param qflags: what flags to use (RD / CD flag or not).\n @param prime: if it is a (stub) priming query.\n @param valrec: if it is a validation recursion query (lookup of key, DS).\n @param newq: If the new subquery needs initialisation, it is returned,\n \totherwise NULL is returned.\n @param sub: The added mesh state, created if it did not exist already.\n @return: false on error, true if success (and init may be needed)."]
    pub add_sub: ::std::option::Option<
        unsafe extern "C" fn(
            qstate: *mut module_qstate,
            qinfo: *mut query_info,
            qflags: u16,
            prime: ::std::os::raw::c_int,
            valrec: ::std::os::raw::c_int,
            newq: *mut *mut module_qstate,
            sub: *mut *mut mesh_state,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Kill newly attached sub. If attach_sub returns newq for\n initialisation, but that fails, then this routine will cleanup and\n delete the freshly created sub.\n @param newq: the new subquery that is no longer needed.\n \tIt is removed."]
    pub kill_sub: ::std::option::Option<unsafe extern "C" fn(newq: *mut module_qstate)>,
    #[doc = " Detect if adding a dependency for qstate on name,type,class will\n create a dependency cycle.\n @param qstate: given mesh querystate.\n @param qinfo: query info for dependency.\n @param flags: query flags of dependency, RD/CD flags.\n @param prime: if dependency is a priming query or not.\n @param valrec: validation lookup recursion, does not need validation\n @return true if the name,type,class exists and the given\n \tqstate mesh exists as a dependency of that name. Thus\n \tif qstate becomes dependent on name,type,class then a\n \tcycle is created."]
    pub detect_cycle: ::std::option::Option<
        unsafe extern "C" fn(
            qstate: *mut module_qstate,
            qinfo: *mut query_info,
            flags: u16,
            prime: ::std::os::raw::c_int,
            valrec: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " region for temporary usage. May be cleared after operate() call."]
    pub scratch: *mut regional,
    #[doc = " buffer for temporary usage. May be cleared after operate() call."]
    pub scratch_buffer: *mut sldns_buffer,
    #[doc = " internal data for daemon - worker thread."]
    pub worker: *mut worker,
    #[doc = " the worker event base"]
    pub worker_base: *mut comm_base,
    #[doc = " the outside network"]
    pub outnet: *mut outside_network,
    #[doc = " mesh area with query state dependencies"]
    pub mesh: *mut mesh_area,
    #[doc = " allocation service"]
    pub alloc: *mut alloc_cache,
    #[doc = " random table to generate random numbers"]
    pub rnd: *mut ub_randstate,
    #[doc = " time in seconds, converted to integer"]
    pub now: *mut time_t,
    #[doc = " time in microseconds. Relatively recent."]
    pub now_tv: *mut timeval,
    #[doc = " is validation required for messages, controls client-facing\n validation status (AD bits) and servfails"]
    pub need_to_validate: ::std::os::raw::c_int,
    #[doc = " trusted key storage; these are the configured keys, if not NULL,\n otherwise configured by validator. These are the trust anchors,\n and are not primed and ready for validation, but on the bright\n side, they are read only memory, thus no locks and fast."]
    pub anchors: *mut val_anchors,
    #[doc = " negative cache, configured by the validator. if not NULL,\n contains NSEC record lookup trees."]
    pub neg_cache: *mut val_neg_cache,
    #[doc = " the 5011-probe timer (if any)"]
    pub probe_timer: *mut comm_timer,
    #[doc = " auth zones"]
    pub auth_zones: *mut auth_zones,
    #[doc = " Mapping of forwarding zones to targets.\n iterator forwarder information."]
    pub fwds: *mut iter_forwards,
    #[doc = " iterator stub information.\n The hints -- these aren't stored in the cache because they don't\n expire. The hints are always used to \"prime\" the cache. Note\n that both root hints and stub zone \"hints\" are stored in this\n data structure."]
    pub hints: *mut iter_hints,
    #[doc = " module specific data. indexed by module id."]
    pub modinfo: [*mut ::std::os::raw::c_void; 16usize],
    pub inplace_cb_lists: [*mut inplace_cb; 7usize],
    #[doc = " Shared array of known edns options (size MAX_KNOWN_EDNS_OPTS).\n Filled by edns literate modules during init."]
    pub edns_known_options: *mut edns_known_option,
    pub edns_known_options_num: usize,
    #[doc = " EDNS client string information"]
    pub edns_strings: *mut edns_strings,
    #[doc = " module stack"]
    pub modstack: *mut module_stack,
    #[doc = " the cachedb enabled value, copied and stored here."]
    pub cachedb_enabled: ::std::os::raw::c_int,
    pub unique_mesh: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_module_env() {
    const UNINIT: ::std::mem::MaybeUninit<module_env> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<module_env>(),
        448usize,
        concat!("Size of: ", stringify!(module_env))
    );
    assert_eq!(
        ::std::mem::align_of::<module_env>(),
        8usize,
        concat!("Alignment of ", stringify!(module_env))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cfg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(cfg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_cache) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(msg_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrset_cache) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(rrset_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).infra_cache) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(infra_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_cache) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(key_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_query) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(send_query)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detach_subs) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(detach_subs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attach_sub) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(attach_sub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_sub) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(add_sub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kill_sub) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(kill_sub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detect_cycle) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(detect_cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scratch) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(scratch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scratch_buffer) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(scratch_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).worker) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(worker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).worker_base) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(worker_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outnet) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(outnet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mesh) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(mesh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rnd) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(rnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).now) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(now)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).now_tv) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(now_tv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).need_to_validate) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(need_to_validate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).anchors) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(anchors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).neg_cache) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(neg_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).probe_timer) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(probe_timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_zones) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(auth_zones)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fwds) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(fwds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hints) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(hints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modinfo) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(modinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inplace_cb_lists) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(inplace_cb_lists)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edns_known_options) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(edns_known_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edns_known_options_num) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(edns_known_options_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edns_strings) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(edns_strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modstack) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(modstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cachedb_enabled) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(cachedb_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unique_mesh) as usize - ptr as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(module_env),
            "::",
            stringify!(unique_mesh)
        )
    );
}
#[doc = " initial state - new query"]
pub const module_ext_state_module_state_initial: module_ext_state = 0;
#[doc = " waiting for reply to outgoing network query"]
pub const module_ext_state_module_wait_reply: module_ext_state = 1;
#[doc = " module is waiting for another module"]
pub const module_ext_state_module_wait_module: module_ext_state = 2;
#[doc = " module is waiting for another module; that other is restarted"]
pub const module_ext_state_module_restart_next: module_ext_state = 3;
#[doc = " module is waiting for sub-query"]
pub const module_ext_state_module_wait_subquery: module_ext_state = 4;
#[doc = " module could not finish the query"]
pub const module_ext_state_module_error: module_ext_state = 5;
#[doc = " module is finished with query"]
pub const module_ext_state_module_finished: module_ext_state = 6;
#[doc = " External visible states of the module state machine\n Modules may also have an internal state.\n Modules are supposed to run to completion or until blocked."]
pub type module_ext_state = ::std::os::raw::c_uint;
#[doc = " new query"]
pub const module_ev_module_event_new: module_ev = 0;
#[doc = " query passed by other module"]
pub const module_ev_module_event_pass: module_ev = 1;
#[doc = " reply inbound from server"]
pub const module_ev_module_event_reply: module_ev = 2;
#[doc = " no reply, timeout or other error"]
pub const module_ev_module_event_noreply: module_ev = 3;
#[doc = " reply is there, but capitalisation check failed"]
pub const module_ev_module_event_capsfail: module_ev = 4;
#[doc = " next module is done, and its reply is awaiting you"]
pub const module_ev_module_event_moddone: module_ev = 5;
#[doc = " error"]
pub const module_ev_module_event_error: module_ev = 6;
#[doc = " Events that happen to modules, that start or wakeup modules."]
pub type module_ev = ::std::os::raw::c_uint;
#[doc = " Linked list of sockaddrs\n May be allocated such that only 'len' bytes of addr exist for the structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_list {
    #[doc = " next in list"]
    pub next: *mut sock_list,
    #[doc = " length of addr"]
    pub len: socklen_t,
    #[doc = " sockaddr"]
    pub addr: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_sock_list() {
    const UNINIT: ::std::mem::MaybeUninit<sock_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sock_list>(),
        144usize,
        concat!("Size of: ", stringify!(sock_list))
    );
    assert_eq!(
        ::std::mem::align_of::<sock_list>(),
        8usize,
        concat!("Alignment of ", stringify!(sock_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_list),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_list),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sock_list),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct respip_action_info {
    _unused: [u8; 0],
}
#[doc = " Struct to hold relevant data for serve expired"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serve_expired_data {
    pub timer: *mut comm_timer,
    pub get_cached_answer: serve_expired_lookup_func_type,
}
#[test]
fn bindgen_test_layout_serve_expired_data() {
    const UNINIT: ::std::mem::MaybeUninit<serve_expired_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<serve_expired_data>(),
        16usize,
        concat!("Size of: ", stringify!(serve_expired_data))
    );
    assert_eq!(
        ::std::mem::align_of::<serve_expired_data>(),
        8usize,
        concat!("Alignment of ", stringify!(serve_expired_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(serve_expired_data),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_cached_answer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(serve_expired_data),
            "::",
            stringify!(get_cached_answer)
        )
    );
}
#[doc = " Module state, per query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_qstate {
    #[doc = " which query is being answered: name, type, class"]
    pub qinfo: query_info,
    #[doc = " flags uint16 from query"]
    pub query_flags: u16,
    #[doc = " if this is a (stub or root) priming query (with hints)"]
    pub is_priming: ::std::os::raw::c_int,
    #[doc = " if this is a validation recursion query that does not get\n validation itself"]
    pub is_valrec: ::std::os::raw::c_int,
    #[doc = " the client network address is needed for the client-subnet option\n  when prefetching, but we can't use reply_list in mesh_info, because\n  we don't want to send a reply for the internal query."]
    pub client_addr: sockaddr_storage,
    #[doc = " comm_reply contains server replies"]
    pub reply: *mut comm_reply,
    #[doc = " the reply message, with message for client and calling module"]
    pub return_msg: *mut dns_msg,
    #[doc = " the rcode, in case of error, instead of a reply message"]
    pub return_rcode: ::std::os::raw::c_int,
    #[doc = " origin of the reply (can be NULL from cache, list for cnames)"]
    pub reply_origin: *mut sock_list,
    #[doc = " IP blacklist for queries"]
    pub blacklist: *mut sock_list,
    #[doc = " region for this query. Cleared when query process finishes."]
    pub region: *mut regional,
    #[doc = " failure reason information if val-log-level is high"]
    pub errinf: *mut errinf_strlist,
    #[doc = " which module is executing"]
    pub curmod: ::std::os::raw::c_int,
    #[doc = " module states"]
    pub ext_state: [module_ext_state; 16usize],
    #[doc = " module specific data for query. indexed by module id."]
    pub minfo: [*mut ::std::os::raw::c_void; 16usize],
    #[doc = " environment for this query"]
    pub env: *mut module_env,
    #[doc = " mesh related information for this query"]
    pub mesh_info: *mut mesh_state,
    #[doc = " how many seconds before expiry is this prefetched (0 if not)"]
    pub prefetch_leeway: time_t,
    #[doc = " serve expired data"]
    pub serve_expired_data: *mut serve_expired_data,
    #[doc = " incoming edns options from the front end"]
    pub edns_opts_front_in: *mut edns_option,
    #[doc = " outgoing edns options to the back end"]
    pub edns_opts_back_out: *mut edns_option,
    #[doc = " incoming edns options from the back end"]
    pub edns_opts_back_in: *mut edns_option,
    #[doc = " outgoing edns options to the front end"]
    pub edns_opts_front_out: *mut edns_option,
    #[doc = " whether modules should answer from the cache"]
    pub no_cache_lookup: ::std::os::raw::c_int,
    #[doc = " whether modules should store answer in the cache"]
    pub no_cache_store: ::std::os::raw::c_int,
    #[doc = " whether to refetch a fresh answer on finishing this state"]
    pub need_refetch: ::std::os::raw::c_int,
    #[doc = " whether the query (or a subquery) was ratelimited"]
    pub was_ratelimited: ::std::os::raw::c_int,
    #[doc = " time when query was started. This is when the qstate is created.\n This is used so that type NS data cannot be overwritten by them\n expiring while the lookup is in progress, using data fetched from\n those servers. By comparing expiry time with qstarttime for type NS."]
    pub qstarttime: time_t,
    #[doc = " whether a message from cachedb will be used for the reply"]
    pub is_cachedb_answer: ::std::os::raw::c_int,
    #[doc = " Attributes of clients that share the qstate that may affect IP-based\n actions."]
    pub client_info: *mut respip_client_info,
    #[doc = " Extended result of response-ip action processing, mainly\n  for logging purposes."]
    pub respip_action_info: *mut respip_action_info,
    #[doc = " if the query is rpz passthru, no further rpz processing for it"]
    pub rpz_passthru: ::std::os::raw::c_int,
    pub tcp_required: ::std::os::raw::c_int,
    #[doc = " whether the reply should be dropped"]
    pub is_drop: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_module_qstate() {
    const UNINIT: ::std::mem::MaybeUninit<module_qstate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<module_qstate>(),
        560usize,
        concat!("Size of: ", stringify!(module_qstate))
    );
    assert_eq!(
        ::std::mem::align_of::<module_qstate>(),
        8usize,
        concat!("Alignment of ", stringify!(module_qstate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(qinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(query_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_priming) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(is_priming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_valrec) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(is_valrec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_addr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(client_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reply) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(reply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_msg) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(return_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_rcode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(return_rcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reply_origin) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(reply_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blacklist) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(blacklist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).region) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(region)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errinf) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(errinf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curmod) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(curmod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ext_state) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(ext_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minfo) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(minfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).env) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(env)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mesh_info) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(mesh_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefetch_leeway) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(prefetch_leeway)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serve_expired_data) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(serve_expired_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edns_opts_front_in) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(edns_opts_front_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edns_opts_back_out) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(edns_opts_back_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edns_opts_back_in) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(edns_opts_back_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edns_opts_front_out) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(edns_opts_front_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_cache_lookup) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(no_cache_lookup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_cache_store) as usize - ptr as usize },
        500usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(no_cache_store)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).need_refetch) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(need_refetch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).was_ratelimited) as usize - ptr as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(was_ratelimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qstarttime) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(qstarttime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_cachedb_answer) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(is_cachedb_answer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_info) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(client_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).respip_action_info) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(respip_action_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rpz_passthru) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(rpz_passthru)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcp_required) as usize - ptr as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(tcp_required)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_drop) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(module_qstate),
            "::",
            stringify!(is_drop)
        )
    );
}
#[doc = " Module functionality block"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_func_block {
    #[doc = " text string name of module"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " init the module. Called once for the global state.\n This is the place to apply settings from the config file.\n @param env: module environment.\n @param id: module id number.\n return: 0 on error"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut module_env,
            id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " de-init, delete, the module. Called once for the global state.\n @param env: module environment.\n @param id: module id number."]
    pub deinit: ::std::option::Option<
        unsafe extern "C" fn(env: *mut module_env, id: ::std::os::raw::c_int),
    >,
    #[doc = " accept a new query, or work further on existing query.\n Changes the qstate->ext_state to be correct on exit.\n @param ev: event that causes the module state machine to\n\t(re-)activate.\n @param qstate: the query state.\n\tNote that this method is not allowed to change the\n\tquery state 'identity', that is query info, qflags,\n\tand priming status.\n\tAttach a subquery to get results to a different query.\n @param id: module id number that operate() is called on.\n @param outbound: if not NULL this event is due to the reply/timeout\n\tor error on this outbound query.\n @return: if at exit the ext_state is:\n\to wait_module: next module is started. (with pass event).\n\to error or finished: previous module is resumed.\n\to otherwise it waits until that event happens (assumes\n\t  the service routine to make subrequest or send message\n\t  have been called."]
    pub operate: ::std::option::Option<
        unsafe extern "C" fn(
            qstate: *mut module_qstate,
            event: module_ev,
            id: ::std::os::raw::c_int,
            outbound: *mut outbound_entry,
        ),
    >,
    #[doc = " inform super querystate about the results from this subquerystate.\n Is called when the querystate is finished.  The method invoked is\n the one from the current module active in the super querystate.\n @param qstate: the query state that is finished.\n\tExamine return_rcode and return_reply in the qstate.\n @param id: module id for this module.\n\tThis coincides with the current module for the super qstate.\n @param super: the super querystate that needs to be informed."]
    pub inform_super: ::std::option::Option<
        unsafe extern "C" fn(
            qstate: *mut module_qstate,
            id: ::std::os::raw::c_int,
            super_: *mut module_qstate,
        ),
    >,
    #[doc = " clear module specific data"]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(qstate: *mut module_qstate, id: ::std::os::raw::c_int),
    >,
    #[doc = " How much memory is the module specific data using.\n @param env: module environment.\n @param id: the module id.\n @return the number of bytes that are alloced."]
    pub get_mem: ::std::option::Option<
        unsafe extern "C" fn(env: *mut module_env, id: ::std::os::raw::c_int) -> usize,
    >,
}
#[test]
fn bindgen_test_layout_module_func_block() {
    const UNINIT: ::std::mem::MaybeUninit<module_func_block> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<module_func_block>(),
        56usize,
        concat!("Size of: ", stringify!(module_func_block))
    );
    assert_eq!(
        ::std::mem::align_of::<module_func_block>(),
        8usize,
        concat!("Alignment of ", stringify!(module_func_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_func_block),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(module_func_block),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deinit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(module_func_block),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(module_func_block),
            "::",
            stringify!(operate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inform_super) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(module_func_block),
            "::",
            stringify!(inform_super)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(module_func_block),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mem) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(module_func_block),
            "::",
            stringify!(get_mem)
        )
    );
}
extern "C" {
    #[doc = " Debug utility: module external qstate to string\n @param s: the state value.\n @return descriptive string."]
    pub fn strextstate(s: module_ext_state) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Debug utility: module event to string\n @param e: the module event value.\n @return descriptive string."]
    pub fn strmodulevent(e: module_ev) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Append text to the error info for validation.\n @param qstate: query state.\n @param str: copied into query region and appended.\n Failures to allocate are logged."]
    pub fn errinf(qstate: *mut module_qstate, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn errinf_ede(
        qstate: *mut module_qstate,
        str_: *const ::std::os::raw::c_char,
        reason_bogus: sldns_ede_code,
    );
}
extern "C" {
    #[doc = " Append text to error info:  from 1.2.3.4\n @param qstate: query state.\n @param origin: sock list with origin of trouble.\n  Every element added.\n  If NULL: nothing is added.\n  if 0len element: 'from cache' is added."]
    pub fn errinf_origin(qstate: *mut module_qstate, origin: *mut sock_list);
}
extern "C" {
    #[doc = " Append text to error info:  for RRset name type class\n @param qstate: query state.\n @param rr: rrset_key."]
    pub fn errinf_rrset(qstate: *mut module_qstate, rr: *mut ub_packed_rrset_key);
}
extern "C" {
    #[doc = " Append text to error info:  str dname\n @param qstate: query state.\n @param str: explanation string\n @param dname: the dname."]
    pub fn errinf_dname(
        qstate: *mut module_qstate,
        str_: *const ::std::os::raw::c_char,
        dname: *mut u8,
    );
}
extern "C" {
    #[doc = " Create error info in string.  For validation failures.\n @param qstate: query state.\n @param region: the region for the result or NULL for malloced result.\n @return string or NULL on malloc failure (already logged).\n    This string is malloced if region is NULL and has to be freed by caller."]
    pub fn errinf_to_str_bogus(
        qstate: *mut module_qstate,
        region: *mut regional,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Check the sldns_ede_code of the qstate->errinf.\n @param qstate: query state.\n @return the latest explicitly set sldns_ede_code or LDNS_EDE_NONE."]
    pub fn errinf_to_reason_bogus(qstate: *mut module_qstate) -> sldns_ede_code;
}
extern "C" {
    #[doc = " Create error info in string.  For other servfails.\n @param qstate: query state.\n @return string or NULL on malloc failure (already logged)."]
    pub fn errinf_to_str_servfail(qstate: *mut module_qstate) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create error info in string.  For misc failures that are not servfail.\n @param qstate: query state.\n @return string or NULL on malloc failure (already logged)."]
    pub fn errinf_to_str_misc(qstate: *mut module_qstate) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Initialize the edns known options by allocating the required space.\n @param env: the module environment.\n @return false on failure (no memory)."]
    pub fn edns_known_options_init(env: *mut module_env) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the allocated space for the known edns options.\n @param env: the module environment."]
    pub fn edns_known_options_delete(env: *mut module_env);
}
extern "C" {
    #[doc = " Register a known edns option. Overwrite the flags if it is already\n registered. Used before creating workers to register known edns options.\n @param opt_code: the edns option code.\n @param bypass_cache_stage: whether the option interacts with the cache.\n @param no_aggregation: whether the option implies more specific\n\taggregation.\n @param env: the module environment.\n @return true on success, false on failure (registering more options than\n\tallowed or trying to register after the environment is copied to the\n\tthreads.)"]
    pub fn edns_register_option(
        opt_code: u16,
        bypass_cache_stage: ::std::os::raw::c_int,
        no_aggregation: ::std::os::raw::c_int,
        env: *mut module_env,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register an inplace callback function.\n @param cb: pointer to the callback function.\n @param type: inplace callback type.\n @param cbarg: argument for the callback function, or NULL.\n @param env: the module environment.\n @param id: module id.\n @return true on success, false on failure (out of memory or trying to\n\tregister after the environment is copied to the threads.)"]
    pub fn inplace_cb_register(
        cb: *mut ::std::os::raw::c_void,
        type_: inplace_cb_list_type,
        cbarg: *mut ::std::os::raw::c_void,
        env: *mut module_env,
        id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete callback for specified type and module id.\n @param env: the module environment.\n @param type: inplace callback type.\n @param id: module id."]
    pub fn inplace_cb_delete(
        env: *mut module_env,
        type_: inplace_cb_list_type,
        id: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Delete all the inplace callback linked lists.\n @param env: the module environment."]
    pub fn inplace_cb_lists_delete(env: *mut module_env);
}
extern "C" {
    #[doc = " Check if an edns option is known.\n @param opt_code: the edns option code.\n @param env: the module environment.\n @return pointer to registered option if the edns option is known,\n\tNULL otherwise."]
    pub fn edns_option_is_known(opt_code: u16, env: *mut module_env) -> *mut edns_known_option;
}
extern "C" {
    #[doc = " Check if an edns option needs to bypass the reply from cache stage.\n @param list: the edns options.\n @param env: the module environment.\n @return true if an edns option needs to bypass the cache stage,\n\tfalse otherwise."]
    pub fn edns_bypass_cache_stage(
        list: *mut edns_option,
        env: *mut module_env,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if an unique mesh state is required. Might be triggered by EDNS option\n or set for the complete env.\n @param list: the edns options.\n @param env: the module environment.\n @return true if an edns option needs a unique mesh state,\n\tfalse otherwise."]
    pub fn unique_mesh_state(list: *mut edns_option, env: *mut module_env)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Log the known edns options.\n @param level: the desired verbosity level.\n @param env: the module environment."]
    pub fn log_edns_known_options(level: verbosity_value, env: *mut module_env);
}
extern "C" {
    #[doc = " Copy state that may have happened in the subquery and is always relevant to\n the super.\n @param qstate: query state that finished.\n @param id: module id.\n @param super: the qstate to inform."]
    pub fn copy_state_to_super(
        qstate: *mut module_qstate,
        id: ::std::os::raw::c_int,
        super_: *mut module_qstate,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_view {
    _unused: [u8; 0],
}
#[doc = " Views storage, shared."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct views {
    #[doc = " lock on the view tree"]
    pub lock: lock_rw_type,
    #[doc = " rbtree of struct view"]
    pub vtree: rbtree_type,
}
#[test]
fn bindgen_test_layout_views() {
    const UNINIT: ::std::mem::MaybeUninit<views> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<views>(),
        80usize,
        concat!("Size of: ", stringify!(views))
    );
    assert_eq!(
        ::std::mem::align_of::<views>(),
        8usize,
        concat!("Alignment of ", stringify!(views))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(views),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtree) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(views),
            "::",
            stringify!(vtree)
        )
    );
}
#[doc = " View. Named structure holding local authority zones."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct view {
    #[doc = " rbtree node, key is name"]
    pub node: rbnode_type,
    #[doc = " view name.\n Has to be right after rbnode_t due to pointer arithmetic in\n view_create's lock protect"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " view specific local authority zones"]
    pub local_zones: *mut local_zones,
    #[doc = " response-ip configuration data for this view"]
    pub respip_set: *mut respip_set,
    #[doc = " Fallback to global local_zones when there is no match in the view\n specific tree. 1 for yes, 0 for no"]
    pub isfirst: ::std::os::raw::c_int,
    #[doc = " lock on the data in the structure\n For the node and name you need to also hold the views_tree lock to\n change them."]
    pub lock: lock_rw_type,
}
#[test]
fn bindgen_test_layout_view() {
    const UNINIT: ::std::mem::MaybeUninit<view> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<view>(),
        128usize,
        concat!("Size of: ", stringify!(view))
    );
    assert_eq!(
        ::std::mem::align_of::<view>(),
        8usize,
        concat!("Alignment of ", stringify!(view))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(view),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(view),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_zones) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(view),
            "::",
            stringify!(local_zones)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).respip_set) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(view),
            "::",
            stringify!(respip_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isfirst) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(view),
            "::",
            stringify!(isfirst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(view),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    #[doc = " Create views storage\n @return new struct or NULL on error."]
    pub fn views_create() -> *mut views;
}
extern "C" {
    #[doc = " Delete views storage\n @param v: views to delete."]
    pub fn views_delete(v: *mut views);
}
extern "C" {
    #[doc = " Apply config settings;\n Takes care of locking.\n @param v: view is set up.\n @param cfg: config data.\n @return false on error."]
    pub fn views_apply_cfg(v: *mut views, cfg: *mut config_file) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two view entries in rbtree. Sort canonical.\n @param v1: view 1\n @param v2: view 2\n @return: negative, positive or 0 comparison value."]
    pub fn view_cmp(
        v1: *const ::std::os::raw::c_void,
        v2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete one view\n @param v: view to delete."]
    pub fn view_delete(v: *mut view);
}
extern "C" {
    #[doc = " Debug helper. Print all views\n Takes care of locking.\n @param v: the views tree"]
    pub fn views_print(v: *mut views);
}
extern "C" {
    #[doc = " Find a view by name.\n @param vs: views\n @param name: name of the view we are looking for\n @param write: 1 for obtaining write lock on found view, 0 for read lock\n @return: locked view or NULL."]
    pub fn views_find_view(
        vs: *mut views,
        name: *const ::std::os::raw::c_char,
        write: ::std::os::raw::c_int,
    ) -> *mut view;
}
#[doc = " implementation of buffers to ease operations\n\n sldns_buffers can contain arbitrary information, per octet. You can write\n to the current end of a buffer, read from the current position, and\n access any data within it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sldns_buffer {
    #[doc = " The current position used for reading/writing"]
    pub _position: usize,
    #[doc = " The read/write limit"]
    pub _limit: usize,
    #[doc = " The amount of data the buffer can contain"]
    pub _capacity: usize,
    #[doc = " The data contained in the buffer"]
    pub _data: *mut u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_sldns_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<sldns_buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sldns_buffer>(),
        40usize,
        concat!("Size of: ", stringify!(sldns_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<sldns_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(sldns_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_buffer),
            "::",
            stringify!(_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._limit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_buffer),
            "::",
            stringify!(_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_buffer),
            "::",
            stringify!(_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sldns_buffer),
            "::",
            stringify!(_data)
        )
    );
}
impl sldns_buffer {
    #[inline]
    pub fn _fixed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__fixed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _status_err(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__status_err(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _fixed: ::std::os::raw::c_uint,
        _status_err: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _fixed: u32 = unsafe { ::std::mem::transmute(_fixed) };
            _fixed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _status_err: u32 = unsafe { ::std::mem::transmute(_status_err) };
            _status_err as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " creates a new buffer with the specified capacity.\n\n \\param[in] capacity the size (in bytes) to allocate for the buffer\n \\return the created buffer"]
    pub fn sldns_buffer_new(capacity: usize) -> *mut sldns_buffer;
}
extern "C" {
    #[doc = " creates a buffer with the specified data.  The data IS copied\n and MEMORY allocations are done.  The buffer is not fixed and can\n be resized using buffer_reserve().\n\n \\param[in] buffer pointer to the buffer to put the data in\n \\param[in] data the data to encapsulate in the buffer\n \\param[in] size the size of the data"]
    pub fn sldns_buffer_new_frm_data(
        buffer: *mut sldns_buffer,
        data: *mut ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    #[doc = " Setup a buffer with the data pointed to. No data copied, no memory allocs.\n The buffer is fixed.\n \\param[in] buffer pointer to the buffer to put the data in\n \\param[in] data the data to encapsulate in the buffer\n \\param[in] size the size of the data"]
    pub fn sldns_buffer_init_frm_data(
        buffer: *mut sldns_buffer,
        data: *mut ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    #[doc = " changes the buffer's capacity.  The data is reallocated so any\n pointers to the data may become invalid.  The buffer's limit is set\n to the buffer's new capacity.\n \\param[in] buffer the buffer\n \\param[in] capacity the capacity to use\n \\return whether this failed or succeeded"]
    pub fn sldns_buffer_set_capacity(
        buffer: *mut sldns_buffer,
        capacity: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ensures BUFFER can contain at least AMOUNT more bytes.  The buffer's\n capacity is increased if necessary using buffer_set_capacity().\n\n The buffer's limit is always set to the (possibly increased)\n capacity.\n \\param[in] buffer the buffer\n \\param[in] amount amount to use\n \\return whether this failed or succeeded"]
    pub fn sldns_buffer_reserve(buffer: *mut sldns_buffer, amount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " prints to the buffer, increasing the capacity if required using\n buffer_reserve(). The buffer's position is set to the terminating '\\\\0'\n Returns the number of characters written (not including the\n terminating '\\\\0') or -1 on failure."]
    pub fn sldns_buffer_printf(
        buffer: *mut sldns_buffer,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " frees the buffer.\n \\param[in] *buffer the buffer to be freed"]
    pub fn sldns_buffer_free(buffer: *mut sldns_buffer);
}
extern "C" {
    #[doc = " Copy contents of the from buffer to the result buffer and then flips\n the result buffer. Data will be silently truncated if the result buffer is\n too small.\n \\param[out] *result resulting buffer which is copied to.\n \\param[in] *from what to copy to result."]
    pub fn sldns_buffer_copy(result: *mut sldns_buffer, from: *mut sldns_buffer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_strlist {
    _unused: [u8; 0],
}
#[doc = " unset type, used for unset tag_action elements"]
pub const localzone_type_local_zone_unset: localzone_type = 0;
#[doc = " drop query"]
pub const localzone_type_local_zone_deny: localzone_type = 1;
#[doc = " answer with error"]
pub const localzone_type_local_zone_refuse: localzone_type = 2;
#[doc = " answer nxdomain or nodata"]
pub const localzone_type_local_zone_static: localzone_type = 3;
#[doc = " resolve normally"]
pub const localzone_type_local_zone_transparent: localzone_type = 4;
#[doc = " do not block types at localdata names"]
pub const localzone_type_local_zone_typetransparent: localzone_type = 5;
#[doc = " answer with data at zone apex"]
pub const localzone_type_local_zone_redirect: localzone_type = 6;
#[doc = " remove default AS112 blocking contents for zone\n nodefault is used in config not during service."]
pub const localzone_type_local_zone_nodefault: localzone_type = 7;
#[doc = " log client address, but no block (transparent)"]
pub const localzone_type_local_zone_inform: localzone_type = 8;
#[doc = " log client address, and block (drop)"]
pub const localzone_type_local_zone_inform_deny: localzone_type = 9;
#[doc = " log client address, and direct"]
pub const localzone_type_local_zone_inform_redirect: localzone_type = 10;
#[doc = " resolve normally, even when there is local data"]
pub const localzone_type_local_zone_always_transparent: localzone_type = 11;
#[doc = " resolve normally, even when there is local data but return NODATA for A queries"]
pub const localzone_type_local_zone_block_a: localzone_type = 12;
#[doc = " answer with error, even when there is local data"]
pub const localzone_type_local_zone_always_refuse: localzone_type = 13;
#[doc = " answer with nxdomain, even when there is local data"]
pub const localzone_type_local_zone_always_nxdomain: localzone_type = 14;
#[doc = " answer with noerror/nodata, even when there is local data"]
pub const localzone_type_local_zone_always_nodata: localzone_type = 15;
#[doc = " drop query, even when there is local data"]
pub const localzone_type_local_zone_always_deny: localzone_type = 16;
#[doc = " answer with 0.0.0.0 or ::0 or noerror/nodata, even when there is\n local data"]
pub const localzone_type_local_zone_always_null: localzone_type = 17;
#[doc = " answer not from the view, but global or no-answer"]
pub const localzone_type_local_zone_noview: localzone_type = 18;
#[doc = " truncate the response; client should retry via tcp"]
pub const localzone_type_local_zone_truncate: localzone_type = 19;
#[doc = " Invalid type, cannot be used to generate answer"]
pub const localzone_type_local_zone_invalid: localzone_type = 20;
#[doc = " Local zone type\n This type determines processing for queries that did not match\n local-data directly."]
pub type localzone_type = ::std::os::raw::c_uint;
#[doc = " Authoritative local zones storage, shared."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_zones {
    #[doc = " lock on the localzone tree"]
    pub lock: lock_rw_type,
    #[doc = " rbtree of struct local_zone"]
    pub ztree: rbtree_type,
}
#[test]
fn bindgen_test_layout_local_zones() {
    const UNINIT: ::std::mem::MaybeUninit<local_zones> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<local_zones>(),
        80usize,
        concat!("Size of: ", stringify!(local_zones))
    );
    assert_eq!(
        ::std::mem::align_of::<local_zones>(),
        8usize,
        concat!("Alignment of ", stringify!(local_zones))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zones),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ztree) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zones),
            "::",
            stringify!(ztree)
        )
    );
}
#[doc = " Local zone. A locally served authoritative zone."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_zone {
    #[doc = " rbtree node, key is name and class"]
    pub node: rbnode_type,
    #[doc = " parent zone, if any."]
    pub parent: *mut local_zone,
    #[doc = " zone name, in uncompressed wireformat"]
    pub name: *mut u8,
    #[doc = " length of zone name"]
    pub namelen: usize,
    #[doc = " number of labels in zone name"]
    pub namelabs: ::std::os::raw::c_int,
    #[doc = " the class of this zone.\n uses 'dclass' to not conflict with c++ keyword class."]
    pub dclass: u16,
    #[doc = " lock on the data in the structure\n For the node, parent, name, namelen, namelabs, dclass, you\n need to also hold the zones_tree lock to change them (or to\n delete this zone)"]
    pub lock: lock_rw_type,
    #[doc = " how to process zone"]
    pub type_: localzone_type,
    #[doc = " tag bitlist"]
    pub taglist: *mut u8,
    #[doc = " length of the taglist (in bytes)"]
    pub taglen: usize,
    #[doc = " netblock addr_tree with struct local_zone_override information\n or NULL if there are no override elements"]
    pub override_tree: *mut rbtree_type,
    #[doc = " in this region the zone's data is allocated.\n the struct local_zone itself is malloced."]
    pub region: *mut regional,
    #[doc = " local data for this zone\n rbtree of struct local_data"]
    pub data: rbtree_type,
    #[doc = " if data contains zone apex SOA data, this is a ptr to it."]
    pub soa: *mut ub_packed_rrset_key,
    #[doc = " if data contains zone apex SOA data, this is a ptr to an\n artificial negative SOA rrset (TTL is the minimum of the TTL and the\n SOA.MINIMUM)."]
    pub soa_negative: *mut ub_packed_rrset_key,
}
#[test]
fn bindgen_test_layout_local_zone() {
    const UNINIT: ::std::mem::MaybeUninit<local_zone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<local_zone>(),
        208usize,
        concat!("Size of: ", stringify!(local_zone))
    );
    assert_eq!(
        ::std::mem::align_of::<local_zone>(),
        8usize,
        concat!("Alignment of ", stringify!(local_zone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namelen) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namelabs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(namelabs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dclass) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(dclass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).taglist) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(taglist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).taglen) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(taglen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_tree) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(override_tree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).region) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(region)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).soa) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(soa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).soa_negative) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone),
            "::",
            stringify!(soa_negative)
        )
    );
}
#[doc = " Local data. One domain name, and the RRs to go with it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_data {
    #[doc = " rbtree node, key is name only"]
    pub node: rbnode_type,
    #[doc = " domain name"]
    pub name: *mut u8,
    #[doc = " length of name"]
    pub namelen: usize,
    #[doc = " number of labels in name"]
    pub namelabs: ::std::os::raw::c_int,
    #[doc = " the data rrsets, with different types, linked list.\n If this list is NULL, the node is an empty non-terminal."]
    pub rrsets: *mut local_rrset,
}
#[test]
fn bindgen_test_layout_local_data() {
    const UNINIT: ::std::mem::MaybeUninit<local_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<local_data>(),
        72usize,
        concat!("Size of: ", stringify!(local_data))
    );
    assert_eq!(
        ::std::mem::align_of::<local_data>(),
        8usize,
        concat!("Alignment of ", stringify!(local_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_data),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(local_data),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namelen) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(local_data),
            "::",
            stringify!(namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namelabs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(local_data),
            "::",
            stringify!(namelabs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrsets) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(local_data),
            "::",
            stringify!(rrsets)
        )
    );
}
#[doc = " A local data RRset"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_rrset {
    #[doc = " next in list"]
    pub next: *mut local_rrset,
    #[doc = " RRset data item"]
    pub rrset: *mut ub_packed_rrset_key,
}
#[test]
fn bindgen_test_layout_local_rrset() {
    const UNINIT: ::std::mem::MaybeUninit<local_rrset> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<local_rrset>(),
        16usize,
        concat!("Size of: ", stringify!(local_rrset))
    );
    assert_eq!(
        ::std::mem::align_of::<local_rrset>(),
        8usize,
        concat!("Alignment of ", stringify!(local_rrset))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_rrset),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rrset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(local_rrset),
            "::",
            stringify!(rrset)
        )
    );
}
#[doc = " Local zone override information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_zone_override {
    #[doc = " node in addrtree"]
    pub node: addr_tree_node,
    #[doc = " override for local zone type"]
    pub type_: localzone_type,
}
#[test]
fn bindgen_test_layout_local_zone_override() {
    const UNINIT: ::std::mem::MaybeUninit<local_zone_override> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<local_zone_override>(),
        192usize,
        concat!("Size of: ", stringify!(local_zone_override))
    );
    assert_eq!(
        ::std::mem::align_of::<local_zone_override>(),
        8usize,
        concat!("Alignment of ", stringify!(local_zone_override))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone_override),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(local_zone_override),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = " Create local zones storage\n @return new struct or NULL on error."]
    pub fn local_zones_create() -> *mut local_zones;
}
extern "C" {
    #[doc = " Delete local zones storage\n @param zones: to delete."]
    pub fn local_zones_delete(zones: *mut local_zones);
}
extern "C" {
    #[doc = " Apply config settings; setup the local authoritative data.\n Takes care of locking.\n @param zones: is set up.\n @param cfg: config data.\n @return false on error."]
    pub fn local_zones_apply_cfg(
        zones: *mut local_zones,
        cfg: *mut config_file,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two local_zone entries in rbtree. Sort hierarchical but not\n canonical\n @param z1: zone 1\n @param z2: zone 2\n @return: -1, 0, +1 comparison value."]
    pub fn local_zone_cmp(
        z1: *const ::std::os::raw::c_void,
        z2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two local_data entries in rbtree. Sort canonical.\n @param d1: data 1\n @param d2: data 2\n @return: -1, 0, +1 comparison value."]
    pub fn local_data_cmp(
        d1: *const ::std::os::raw::c_void,
        d2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete one zone\n @param z: to delete."]
    pub fn local_zone_delete(z: *mut local_zone);
}
extern "C" {
    #[doc = " Lookup zone that contains the given name, class and taglist.\n User must lock the tree or result zone.\n @param zones: the zones tree\n @param name: dname to lookup\n @param len: length of name.\n @param labs: labelcount of name.\n @param dclass: class to lookup.\n @param dtype: type to lookup, if type DS a zone higher is used for zonecuts.\n @param taglist: taglist to lookup.\n @param taglen: length of taglist.\n @param ignoretags: lookup zone by name and class, regardless the\n local-zone's tags.\n @return closest local_zone or NULL if no covering zone is found."]
    pub fn local_zones_tags_lookup(
        zones: *mut local_zones,
        name: *mut u8,
        len: usize,
        labs: ::std::os::raw::c_int,
        dclass: u16,
        dtype: u16,
        taglist: *mut u8,
        taglen: usize,
        ignoretags: ::std::os::raw::c_int,
    ) -> *mut local_zone;
}
extern "C" {
    #[doc = " Lookup zone that contains the given name, class.\n User must lock the tree or result zone.\n @param zones: the zones tree\n @param name: dname to lookup\n @param len: length of name.\n @param labs: labelcount of name.\n @param dclass: class to lookup.\n @param dtype: type of the record, if type DS then a zone higher up is found\n   pass 0 to just plain find a zone for a name.\n @return closest local_zone or NULL if no covering zone is found."]
    pub fn local_zones_lookup(
        zones: *mut local_zones,
        name: *mut u8,
        len: usize,
        labs: ::std::os::raw::c_int,
        dclass: u16,
        dtype: u16,
    ) -> *mut local_zone;
}
extern "C" {
    #[doc = " Debug helper. Print all zones\n Takes care of locking.\n @param zones: the zones tree"]
    pub fn local_zones_print(zones: *mut local_zones);
}
extern "C" {
    #[doc = " Answer authoritatively for local zones.\n Takes care of locking.\n @param zones: the stored zones (shared, read only).\n @param env: the module environment.\n @param qinfo: query info (parsed).\n @param edns: edns info (parsed).\n @param buf: buffer with query ID and flags, also for reply.\n @param temp: temporary storage region.\n @param repinfo: source address for checks. may be NULL.\n @param taglist: taglist for checks. May be NULL.\n @param taglen: length of the taglist.\n @param tagactions: local zone actions for tags. May be NULL.\n @param tagactionssize: length of the tagactions.\n @param tag_datas: array per tag of strlist with rdata strings. or NULL.\n @param tag_datas_size: size of tag_datas array.\n @param tagname: array of tag name strings (for debug output).\n @param num_tags: number of items in tagname array.\n @param view: answer using this view. May be NULL.\n @return true if answer is in buffer. false if query is not answered\n by authority data. If the reply should be dropped altogether, the return\n value is true, but the buffer is cleared (empty).\n It can also return true if a non-exact alias answer is found.  In this\n case qinfo->local_alias points to the corresponding alias RRset but the\n answer is NOT encoded in buffer.  It's the caller's responsibility to\n complete the alias chain (if needed) and encode the final set of answer.\n Data pointed to by qinfo->local_alias is allocated in 'temp' or refers to\n configuration data.  So the caller will need to make a deep copy of it\n if it needs to keep it beyond the lifetime of 'temp' or a dynamic update\n to local zone data."]
    pub fn local_zones_answer(
        zones: *mut local_zones,
        env: *mut module_env,
        qinfo: *mut query_info,
        edns: *mut edns_data,
        buf: *mut sldns_buffer,
        temp: *mut regional,
        repinfo: *mut comm_reply,
        taglist: *mut u8,
        taglen: usize,
        tagactions: *mut u8,
        tagactionssize: usize,
        tag_datas: *mut *mut config_strlist,
        tag_datas_size: usize,
        tagname: *mut *mut ::std::os::raw::c_char,
        num_tags: ::std::os::raw::c_int,
        view: *mut view,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Answer using the local zone only (not local data used).\n @param z: zone for query.\n @param env: module environment.\n @param qinfo: query.\n @param edns: edns from query.\n @param repinfo: source address for checks. may be NULL.\n @param buf: buffer for answer.\n @param temp: temp region for encoding.\n @param ld: local data, if NULL, no such name exists in localdata.\n @param lz_type: type of the local zone.\n @return 1 if a reply is to be sent, 0 if not."]
    pub fn local_zones_zone_answer(
        z: *mut local_zone,
        env: *mut module_env,
        qinfo: *mut query_info,
        edns: *mut edns_data,
        repinfo: *mut comm_reply,
        buf: *mut sldns_buffer,
        temp: *mut regional,
        ld: *mut local_data,
        lz_type: localzone_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse the string into localzone type.\n\n @param str: string to parse\n @param t: local zone type returned here.\n @return 0 on parse error."]
    pub fn local_zone_str2type(
        str_: *const ::std::os::raw::c_char,
        t: *mut localzone_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Print localzone type to a string.  Pointer to a constant string.\n\n @param t: local zone type.\n @return constant string that describes type."]
    pub fn local_zone_type2str(t: localzone_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Find zone that with exactly given name, class.\n User must lock the tree or result zone.\n @param zones: the zones tree\n @param name: dname to lookup\n @param len: length of name.\n @param labs: labelcount of name.\n @param dclass: class to lookup.\n @return the exact local_zone or NULL."]
    pub fn local_zones_find(
        zones: *mut local_zones,
        name: *mut u8,
        len: usize,
        labs: ::std::os::raw::c_int,
        dclass: u16,
    ) -> *mut local_zone;
}
extern "C" {
    #[doc = " Find zone that with exactly or smaller name/class\n User must lock the tree or result zone.\n @param zones: the zones tree\n @param name: dname to lookup\n @param len: length of name.\n @param labs: labelcount of name.\n @param dclass: class to lookup.\n @param exact: 1 on return is this is an exact match.\n @return the exact or smaller local_zone or NULL."]
    pub fn local_zones_find_le(
        zones: *mut local_zones,
        name: *mut u8,
        len: usize,
        labs: ::std::os::raw::c_int,
        dclass: u16,
        exact: *mut ::std::os::raw::c_int,
    ) -> *mut local_zone;
}
extern "C" {
    #[doc = " Add a new zone. Caller must hold the zones lock.\n Adjusts the other zones as well (parent pointers) after insertion.\n The zone must NOT exist (returns NULL and logs error).\n @param zones: the zones tree\n @param name: dname to add\n @param len: length of name.\n @param labs: labelcount of name.\n @param dclass: class to add.\n @param tp: type.\n @return local_zone or NULL on error, caller must printout memory error."]
    pub fn local_zones_add_zone(
        zones: *mut local_zones,
        name: *mut u8,
        len: usize,
        labs: ::std::os::raw::c_int,
        dclass: u16,
        tp: localzone_type,
    ) -> *mut local_zone;
}
extern "C" {
    #[doc = " Delete a zone. Caller must hold the zones lock.\n Adjusts the other zones as well (parent pointers) after insertion.\n @param zones: the zones tree\n @param zone: the zone to delete from tree. Also deletes zone from memory."]
    pub fn local_zones_del_zone(zones: *mut local_zones, zone: *mut local_zone);
}
extern "C" {
    #[doc = " Add RR data into the localzone data.\n Looks up the zone, if no covering zone, a transparent zone with the\n name of the RR is created.\n @param zones: the zones tree. Not locked by caller.\n @param rr: string with on RR.\n @return false on failure."]
    pub fn local_zones_add_RR(
        zones: *mut local_zones,
        rr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove data from domain name in the tree.\n All types are removed. No effect if zone or name does not exist.\n @param zones: zones tree.\n @param name: dname to remove\n @param len: length of name.\n @param labs: labelcount of name.\n @param dclass: class to remove."]
    pub fn local_zones_del_data(
        zones: *mut local_zones,
        name: *mut u8,
        len: usize,
        labs: ::std::os::raw::c_int,
        dclass: u16,
    );
}
extern "C" {
    #[doc = " Form wireformat from text format domain name.\n @param str: the domain name in text \"www.example.com\"\n @param res: resulting wireformat is stored here with malloc.\n @param len: length of resulting wireformat.\n @param labs: number of labels in resulting wireformat.\n @return false on error, syntax or memory. Also logged."]
    pub fn parse_dname(
        str_: *const ::std::os::raw::c_char,
        res: *mut *mut u8,
        len: *mut usize,
        labs: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find local data tag string match for the given type (in qinfo) in the list.\n If found, 'r' will be filled with corresponding rrset information.\n @param qinfo: contains name, type, and class for the data\n @param list: stores local tag data to be searched\n @param r: rrset key to be filled for matched data\n @param temp: region to allocate rrset in 'r'\n @return 1 if a match is found and rrset is built; otherwise 0 including\n errors."]
    pub fn local_data_find_tag_datas(
        qinfo: *const query_info,
        list: *mut config_strlist,
        r: *mut ub_packed_rrset_key,
        temp: *mut regional,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " See if two sets of tag lists (in the form of bitmap) have the same tag that\n has an action.  If so, '*tag' will be set to the found tag index, and the\n corresponding action will be returned in the form of local zone type.\n Otherwise the passed type (lzt) will be returned as the default action.\n Pointers except tagactions must not be NULL.\n @param taglist: 1st list of tags\n @param taglen: size of taglist in bytes\n @param taglist2: 2nd list of tags\n @param taglen2: size of taglist2 in bytes\n @param tagactions: local data actions for tags. May be NULL.\n @param tagactionssize: length of the tagactions.\n @param lzt: default action (local zone type) if no tag action is found.\n @param tag: see above.\n @param tagname: array of tag name strings (for debug output).\n @param num_tags: number of items in tagname array.\n @return found tag action or the default action."]
    pub fn local_data_find_tag_action(
        taglist: *const u8,
        taglen: usize,
        taglist2: *const u8,
        taglen2: usize,
        tagactions: *const u8,
        tagactionssize: usize,
        lzt: localzone_type,
        tag: *mut ::std::os::raw::c_int,
        tagname: *const *mut ::std::os::raw::c_char,
        num_tags: ::std::os::raw::c_int,
    ) -> localzone_type;
}
extern "C" {
    #[doc = " Enter defaults to local zone.\n @param zones: to add defaults to\n @param cfg: containing list of zones to exclude from default set.\n @return 1 on success; 0 otherwise."]
    pub fn local_zone_enter_defaults(
        zones: *mut local_zones,
        cfg: *mut config_file,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parses resource record string into wire format, also returning its field values.\n @param str: input resource record\n @param nm: domain name field\n @param type: record type field\n @param dclass: record class field\n @param ttl: ttl field\n @param rr: buffer for the parsed rr in wire format\n @param len: buffer length\n @param rdata: rdata field\n @param rdata_len: rdata field length\n @return 1 on success; 0 otherwise."]
    pub fn rrstr_get_rr_content(
        str_: *const ::std::os::raw::c_char,
        nm: *mut *mut u8,
        type_: *mut u16,
        dclass: *mut u16,
        ttl: *mut time_t,
        rr: *mut u8,
        len: usize,
        rdata: *mut *mut u8,
        rdata_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Insert specified rdata into the specified resource record.\n @param region: allocator\n @param pd: data portion of the destination resource record\n @param rdata: source rdata\n @param rdata_len: source rdata length\n @param ttl: time to live\n @param rrstr: resource record in text form (for logging)\n @return 1 on success; 0 otherwise."]
    pub fn rrset_insert_rr(
        region: *mut regional,
        pd: *mut packed_rrset_data,
        rdata: *mut u8,
        rdata_len: usize,
        ttl: time_t,
        rrstr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove RR from rrset that is created using localzone's rrset_insert_rr.\n @param pd: the RRset containing the RR to remove\n @param index: index of RR to remove\n @return: 1 on success; 0 otherwise."]
    pub fn local_rrset_remove_rr(pd: *mut packed_rrset_data, index: usize)
        -> ::std::os::raw::c_int;
}
#[doc = " no respip action"]
pub const respip_action_respip_none: respip_action = 0;
#[doc = " don't answer"]
pub const respip_action_respip_deny: respip_action = 1;
#[doc = " redirect as per provided data"]
pub const respip_action_respip_redirect: respip_action = 6;
#[doc = " log query source and answer query"]
pub const respip_action_respip_inform: respip_action = 8;
#[doc = " log query source and don't answer query"]
pub const respip_action_respip_inform_deny: respip_action = 9;
#[doc = " log query source and redirect"]
pub const respip_action_respip_inform_redirect: respip_action = 10;
#[doc = " resolve normally, even when there is response-ip data"]
pub const respip_action_respip_always_transparent: respip_action = 11;
#[doc = " answer with 'refused' response"]
pub const respip_action_respip_always_refuse: respip_action = 13;
#[doc = " answer with 'no such domain' response"]
pub const respip_action_respip_always_nxdomain: respip_action = 14;
#[doc = " answer with nodata response"]
pub const respip_action_respip_always_nodata: respip_action = 15;
#[doc = " answer with nodata response"]
pub const respip_action_respip_always_deny: respip_action = 16;
#[doc = " RPZ: truncate answer in order to force switch to tcp"]
pub const respip_action_respip_truncate: respip_action = 19;
#[doc = " serves response data (if any), else, drops queries."]
pub const respip_action_respip_refuse: respip_action = 2;
#[doc = " serves response data, else, nodata answer."]
pub const respip_action_respip_static: respip_action = 3;
#[doc = " gives response data (if any), else nodata answer."]
pub const respip_action_respip_transparent: respip_action = 4;
#[doc = " gives response data (if any), else nodata answer."]
pub const respip_action_respip_typetransparent: respip_action = 5;
#[doc = " type invalid"]
pub const respip_action_respip_invalid: respip_action = 20;
#[doc = " Valid response ip actions for the IP-response-driven-action feature;\n defined here instead of in the respip module to enable sharing of enum\n values with the localzone_type enum.\n Note that these values except 'none' are the same as localzone types of\n the 'same semantics'.  It's intentional as we use these values via\n access-control-tags, which can be shared for both response ip actions and\n local zones."]
pub type respip_action = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Get local data from local zone and encode answer.\n @param z: local zone to use\n @param env: module env\n @param qinfo: qinfo\n @param edns: edns data, for message encoding\n @param repinfo: reply info, for message encoding\n @param buf: commpoint buffer\n @param temp: scratchpad region\n @param labs: number of labels in qname\n @param ldp: where to store local data\n @param lz_type: type of local zone\n @param tag: matching tag index\n @param tag_datas: alc specific tag data list\n @param tag_datas_size: size of tag_datas\n @param tagname: list of names of tags, for logging purpose\n @param num_tags: number of tags\n @return 1 on success"]
    pub fn local_data_answer(
        z: *mut local_zone,
        env: *mut module_env,
        qinfo: *mut query_info,
        edns: *mut edns_data,
        repinfo: *mut comm_reply,
        buf: *mut sldns_buffer,
        temp: *mut regional,
        labs: ::std::os::raw::c_int,
        ldp: *mut *mut local_data,
        lz_type: localzone_type,
        tag: ::std::os::raw::c_int,
        tag_datas: *mut *mut config_strlist,
        tag_datas_size: usize,
        tagname: *mut *mut ::std::os::raw::c_char,
        num_tags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add RR to local zone.\n @param z: local zone to add RR to\n @param nm: dname of RR\n @param nmlen: length of nm\n @param nmlabs: number of labels of nm\n @param rrtype: RR type\n @param rrclass: RR class\n @param ttl: TTL of RR to add\n @param rdata: RDATA of RR to add\n @param rdata_len: length of rdata\n @param rrstr: RR in string format, for logging\n @return: 1 on success"]
    pub fn local_zone_enter_rr(
        z: *mut local_zone,
        nm: *mut u8,
        nmlen: usize,
        nmlabs: ::std::os::raw::c_int,
        rrtype: u16,
        rrclass: u16,
        ttl: time_t,
        rdata: *mut u8,
        rdata_len: usize,
        rrstr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find a data node by exact name for a local zone\n @param z: local_zone containing data tree\n @param nm: name of local-data element to find\n @param nmlen: length of nm\n @param nmlabs: labs of nm\n @return local_data on exact match, NULL otherwise."]
    pub fn local_zone_find_data(
        z: *mut local_zone,
        nm: *mut u8,
        nmlen: usize,
        nmlabs: ::std::os::raw::c_int,
    ) -> *mut local_data;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serviced_query {
    _unused: [u8; 0],
}
#[doc = " The outbound list. This structure is part of the module specific query\n state."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct outbound_list {
    #[doc = " The linked list of outbound query entries."]
    pub first: *mut outbound_entry,
}
#[test]
fn bindgen_test_layout_outbound_list() {
    const UNINIT: ::std::mem::MaybeUninit<outbound_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<outbound_list>(),
        8usize,
        concat!("Size of: ", stringify!(outbound_list))
    );
    assert_eq!(
        ::std::mem::align_of::<outbound_list>(),
        8usize,
        concat!("Alignment of ", stringify!(outbound_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(outbound_list),
            "::",
            stringify!(first)
        )
    );
}
#[doc = " Outbound list entry. A serviced query sent by a module processing the\n query from the qstate. Double linked list to aid removal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct outbound_entry {
    #[doc = " next in list"]
    pub next: *mut outbound_entry,
    #[doc = " prev in list"]
    pub prev: *mut outbound_entry,
    #[doc = " The query that was sent out"]
    pub qsent: *mut serviced_query,
    #[doc = " the module query state that sent it"]
    pub qstate: *mut module_qstate,
}
#[test]
fn bindgen_test_layout_outbound_entry() {
    const UNINIT: ::std::mem::MaybeUninit<outbound_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<outbound_entry>(),
        32usize,
        concat!("Size of: ", stringify!(outbound_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<outbound_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(outbound_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(outbound_entry),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(outbound_entry),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qsent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(outbound_entry),
            "::",
            stringify!(qsent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qstate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(outbound_entry),
            "::",
            stringify!(qstate)
        )
    );
}
extern "C" {
    #[doc = " Init the user allocated outbound list structure\n @param list: the list structure."]
    pub fn outbound_list_init(list: *mut outbound_list);
}
extern "C" {
    #[doc = " Clear the user owner outbound list structure.\n Deletes serviced queries.\n @param list: the list structure. It is cleared, but the list struct itself\n \tis callers responsibility to delete."]
    pub fn outbound_list_clear(list: *mut outbound_list);
}
extern "C" {
    #[doc = " Insert new entry into the list. Caller must allocate the entry with malloc.\n qstate and qsent are set by caller.\n @param list: the list to add to.\n @param e: entry to add, it is only half initialised at call start, fully\n\tinitialised at call end."]
    pub fn outbound_list_insert(list: *mut outbound_list, e: *mut outbound_entry);
}
extern "C" {
    #[doc = " Remove an entry from the list, and deletes it.\n Deletes serviced query in the entry.\n @param list: the list to remove from.\n @param e: the entry to remove."]
    pub fn outbound_list_remove(list: *mut outbound_list, e: *mut outbound_entry);
}
extern "C" {
    #[doc = " Get the module function block.\n @return: function block with function pointers to module methods."]
    pub fn dynlibmod_get_funcblock() -> *mut module_func_block;
}
extern "C" {
    #[doc = " dynlib module init"]
    pub fn dynlibmod_init(env: *mut module_env, id: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " dynlib module deinit"]
    pub fn dynlibmod_deinit(env: *mut module_env, id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " dynlib module operate on a query"]
    pub fn dynlibmod_operate(
        qstate: *mut module_qstate,
        event: module_ev,
        id: ::std::os::raw::c_int,
        outbound: *mut outbound_entry,
    );
}
extern "C" {
    #[doc = " dynlib module"]
    pub fn dynlibmod_inform_super(
        qstate: *mut module_qstate,
        id: ::std::os::raw::c_int,
        super_: *mut module_qstate,
    );
}
extern "C" {
    #[doc = " dynlib module cleanup query state"]
    pub fn dynlibmod_clear(qstate: *mut module_qstate, id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " dynlib module alloc size routine"]
    pub fn dynlibmod_get_mem(env: *mut module_env, id: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn dynlib_inplace_cb_reply_generic(
        qinfo: *mut query_info,
        qstate: *mut module_qstate,
        rep: *mut reply_info,
        rcode: ::std::os::raw::c_int,
        edns: *mut edns_data,
        opt_list_out: *mut *mut edns_option,
        repinfo: *mut comm_reply,
        region: *mut regional,
        start_time: *mut timeval,
        id: ::std::os::raw::c_int,
        callback: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dynlib_inplace_cb_query_generic(
        qinfo: *mut query_info,
        flags: u16,
        qstate: *mut module_qstate,
        addr: *mut sockaddr_storage,
        addrlen: socklen_t,
        zone: *mut u8,
        zonelen: usize,
        region: *mut regional,
        id: ::std::os::raw::c_int,
        callback: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dynlib_inplace_cb_edns_back_parsed(
        qstate: *mut module_qstate,
        id: ::std::os::raw::c_int,
        cb_args: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dynlib_inplace_cb_query_response(
        qstate: *mut module_qstate,
        response: *mut dns_msg,
        id: ::std::os::raw::c_int,
        cb_args: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inplace_cb_register_wrapped(
        cb: *mut ::std::os::raw::c_void,
        type_: inplace_cb_list_type,
        cbarg: *mut ::std::os::raw::c_void,
        env: *mut module_env,
        id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inplace_cb_delete_wrapped(
        env: *mut module_env,
        type_: inplace_cb_list_type,
        id: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cb_pair {
    pub cb: *mut ::std::os::raw::c_void,
    pub cb_arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cb_pair() {
    const UNINIT: ::std::mem::MaybeUninit<cb_pair> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cb_pair>(),
        16usize,
        concat!("Size of: ", stringify!(cb_pair))
    );
    assert_eq!(
        ::std::mem::align_of::<cb_pair>(),
        8usize,
        concat!("Alignment of ", stringify!(cb_pair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cb_pair),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cb_pair),
            "::",
            stringify!(cb_arg)
        )
    );
}
#[doc = " Global state for the module."]
pub type func_init_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut module_env,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type func_deinit_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut module_env, arg2: ::std::os::raw::c_int)>;
pub type func_operate_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut module_qstate,
        arg2: module_ev,
        arg3: ::std::os::raw::c_int,
        arg4: *mut outbound_entry,
    ),
>;
pub type func_inform_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut module_qstate,
        arg2: ::std::os::raw::c_int,
        arg3: *mut module_qstate,
    ),
>;
pub type func_clear_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut module_qstate, arg2: ::std::os::raw::c_int),
>;
pub type func_get_mem_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut module_env, arg2: ::std::os::raw::c_int) -> usize,
>;
pub type inplace_cb_delete_wrapped_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut module_env,
        arg2: inplace_cb_list_type,
        arg3: ::std::os::raw::c_int,
    ),
>;
pub type inplace_cb_register_wrapped_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: inplace_cb_list_type,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut module_env,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dynlibmod_env {
    #[doc = " Dynamic library filename."]
    pub fname: *const ::std::os::raw::c_char,
    #[doc = " dynamic library handle"]
    pub dynamic_library: *mut ::std::os::raw::c_void,
    #[doc = " Module init function"]
    pub func_init: func_init_t,
    #[doc = " Module deinit function"]
    pub func_deinit: func_deinit_t,
    #[doc = " Module operate function"]
    pub func_operate: func_operate_t,
    #[doc = " Module super_inform function"]
    pub func_inform: func_inform_t,
    #[doc = " Module clear function"]
    pub func_clear: func_clear_t,
    #[doc = " Module get_mem function"]
    pub func_get_mem: func_get_mem_t,
    #[doc = " Wrapped inplace callback functions to circumvent callback whitelisting"]
    pub inplace_cb_delete_wrapped: inplace_cb_delete_wrapped_t,
    pub inplace_cb_register_wrapped: inplace_cb_register_wrapped_t,
    #[doc = " Pointer to any data the dynamic library might want to keep"]
    pub dyn_env: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_dynlibmod_env() {
    const UNINIT: ::std::mem::MaybeUninit<dynlibmod_env> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dynlibmod_env>(),
        88usize,
        concat!("Size of: ", stringify!(dynlibmod_env))
    );
    assert_eq!(
        ::std::mem::align_of::<dynlibmod_env>(),
        8usize,
        concat!("Alignment of ", stringify!(dynlibmod_env))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fname) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dynlibmod_env),
            "::",
            stringify!(fname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_library) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dynlibmod_env),
            "::",
            stringify!(dynamic_library)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_init) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dynlibmod_env),
            "::",
            stringify!(func_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_deinit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dynlibmod_env),
            "::",
            stringify!(func_deinit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_operate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dynlibmod_env),
            "::",
            stringify!(func_operate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_inform) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dynlibmod_env),
            "::",
            stringify!(func_inform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_clear) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dynlibmod_env),
            "::",
            stringify!(func_clear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_get_mem) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dynlibmod_env),
            "::",
            stringify!(func_get_mem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inplace_cb_delete_wrapped) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dynlibmod_env),
            "::",
            stringify!(inplace_cb_delete_wrapped)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inplace_cb_register_wrapped) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dynlibmod_env),
            "::",
            stringify!(inplace_cb_register_wrapped)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dyn_env) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dynlibmod_env),
            "::",
            stringify!(dyn_env)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_at {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ax25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_dl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_eon {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_inarp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ipx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_iso {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ns {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_x25 {
    pub _address: u8,
}
#[doc = " shared infrastructure cache (edns, lameness)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct infra_cache {
    pub _address: u8,
}
#[doc = " the 5011-probe timer (if any)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comm_timer {
    pub _address: u8,
}
#[doc = " EDNS client string information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct edns_strings {
    pub _address: u8,
}
